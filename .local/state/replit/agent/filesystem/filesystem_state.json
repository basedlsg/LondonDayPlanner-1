{"file_contents":{"README.md":{"content":"# NYC Day Planner\n\nAn intelligent day planner that generates personalized, time-optimized itineraries for exploring New York City using advanced natural language processing and the Google Places API.\n\n## Features\n\n- **Natural Language Input**: Simply describe your plans in plain English (e.g., \"I'm at Brooklyn Bridge and need a coffee shop to work until my dinner at Carbone in Greenwich Village at 8pm\")\n- **Smart Scheduling**: Automatically fills your day with interesting activities based on location and time\n- **Time-Aware Planning**: \n  - Supports both 12-hour and 24-hour time formats\n  - Considers typical activity durations\n  - Automatically schedules lunch during appropriate hours\n  - Accounts for travel time between locations\n- **Contextual Recommendations**:\n  - Morning activities (bakeries, markets, coffee spots)\n  - Midday venues (museums, galleries, parks)\n  - Afternoon activities (shopping, cafes, walks)\n  - Evening entertainment (bars, theaters, live music)\n\n## How It Works\n\n1. **Input Your Plans**:\n   - Select your preferred date\n   - Choose a start time\n   - Describe your plans in the text area\n\n2. **Get Your Itinerary**:\n   - The app analyzes your input to identify:\n     - Starting location\n     - Fixed appointments (e.g., dinner reservations)\n     - Specific preferences (e.g., \"quiet coffee shop\")\n   - Generates a sequential itinerary with:\n     - Verified locations from Google Places\n     - Estimated travel times\n     - Suggested activities for free time periods\n\n3. **Export Options**:\n   - Export to calendar (ICS format)\n   - View travel times between locations\n\n## Technical Architecture\n\n### Frontend\n- React with TypeScript\n- Real-time form validation\n- Dynamic itinerary display\n- Responsive design for all devices\n\n### Backend\n- Express server\n- Natural language processing for request parsing\n- Google Places API integration\n- Smart scheduling algorithm\n- PostgreSQL database for storing itineraries\n\n### Key Components\n- Time verification system\n- Location-aware activity suggestions\n- Travel time calculations\n- Intelligent gap filling for unscheduled periods\n\n## Example Use Cases\n\n1. **Work & Dinner Plans**:\n   \"I'm at Grand Central Station and need a quiet café to work until my dinner at Carbone in Greenwich Village at 8pm\"\n\n2. **Tourist Day Out**:\n   \"Starting from Times Square at 10am, I want to see some museums and have dinner in SoHo at 7pm\"\n\n3. **Shopping & Entertainment**:\n   \"Meeting friends at Fifth Avenue at 11am for shopping, then we have theater tickets for 7:30pm in Broadway\"\n\nThe app will create a balanced itinerary that includes appropriate meal times, interesting activities, and accounts for travel between locations.\n","size_bytes":2698},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","size_bytes":325},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","size_bytes":80},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      colors: {\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1))\",\n          \"2\": \"hsl(var(--chart-2))\",\n          \"3\": \"hsl(var(--chart-3))\",\n          \"4\": \"hsl(var(--chart-4))\",\n          \"5\": \"hsl(var(--chart-5))\",\n        },\n        sidebar: {\n          DEFAULT: \"hsl(var(--sidebar-background))\",\n          foreground: \"hsl(var(--sidebar-foreground))\",\n          primary: \"hsl(var(--sidebar-primary))\",\n          \"primary-foreground\": \"hsl(var(--sidebar-primary-foreground))\",\n          accent: \"hsl(var(--sidebar-accent))\",\n          \"accent-foreground\": \"hsl(var(--sidebar-accent-foreground))\",\n          border: \"hsl(var(--sidebar-border))\",\n          ring: \"hsl(var(--sidebar-ring))\",\n        },\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: {\n            height: \"0\",\n          },\n          to: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n        },\n        \"accordion-up\": {\n          from: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n          to: {\n            height: \"0\",\n          },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","size_bytes":2787},"test-venue-preference.js":{"content":"// A simple test script to verify venue preference extraction\n\n// Test queries with venue preferences\nconst testQueries = [\n  // Test 1: Traditional Jewish deli (specific cuisine + venue type)\n  \"I want breakfast at a traditional Jewish deli in Midtown\",\n  \n  // Test 2: Hipster art gallery (ambiance + venue type)\n  \"I'd like to visit a hipster art gallery in Chelsea in the afternoon\",\n  \n  // Test 3: Authentic Italian restaurant (authenticity + cuisine)\n  \"Take me to an authentic Italian restaurant in Little Italy for dinner\",\n  \n  // Test 4: Specialty coffee shop (quality descriptor + venue type)\n  \"I want to grab coffee at a specialty coffee shop in Greenwich Village\",\n  \n  // Test 5: Trendy rooftop bar (ambiance + specific venue subtype)\n  \"Find me a trendy rooftop bar in the East Village for drinks tonight\",\n  \n  // Test 6: Famous bagel shop (reputation + specific food item + venue type)\n  \"I want to get a famous NY bagel from an authentic Jewish deli in Lower East Side\",\n  \n  // Test 7: Multiple venue preferences\n  \"I want breakfast at a famous Jewish deli in Lower East Side and then visit a hipster coffee shop in Williamsburg\"\n];\n\n// Function to run the tests\nasync function runTests() {\n  console.log(\"=== VENUE PREFERENCE EXTRACTION TEST ===\");\n  console.log(\"Testing with the following queries:\");\n  testQueries.forEach((q, i) => console.log(`${i+1}. ${q}`));\n  console.log(\"\\nResults:\");\n\n  // Run each test query\n  for (let i = 0; i < testQueries.length; i++) {\n    const query = testQueries[i];\n    console.log(`\\n--- Test ${i+1}: \"${query}\" ---`);\n    \n    try {\n      const response = await fetch('http://localhost:5000/api/plan', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ query }),\n      });\n      \n      if (!response.ok) {\n        console.error(`Error response: ${response.status}`);\n        continue;\n      }\n      \n      const data = await response.json();\n      \n      // Display the results for each test\n      if (data && data.places && data.places.length > 0) {\n        console.log(`✅ Found ${data.places.length} places in response`);\n        \n        data.places.forEach((place, idx) => {\n          // Add numbering for multiple places\n          const placePrefix = data.places.length > 1 ? `[${idx+1}] ` : '';\n          console.log(`${placePrefix}Place: ${place.name} (${place.address})`);\n          console.log(`${placePrefix}Types: ${place.details.types.join(', ')}`);\n          console.log(`${placePrefix}Rating: ${place.details.rating}`);\n          \n          // Show alternative venues - these demonstrate that the venue preference is working\n          if (place.alternatives && place.alternatives.length > 0) {\n            console.log(`${placePrefix}Alternatives: ${place.alternatives.map(a => a.name).join(', ')}`);\n          } else {\n            console.log(`${placePrefix}Alternatives: None found`);\n          }\n        });\n      } else {\n        console.log(\"❌ No places found in response\");\n      }\n    } catch (error) {\n      console.error(`Error testing query \"${query}\": ${error.message}`);\n    }\n  }\n}\n\n// Run the tests\nrunTests().catch(console.error);","size_bytes":3205},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport themePlugin from \"@replit/vite-plugin-shadcn-theme-json\";\nimport path, { dirname } from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\nimport { fileURLToPath } from \"url\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport default defineConfig({\n  base: '/NYC/',\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    themePlugin(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(__dirname, \"shared\"),\n    },\n  },\n  root: path.resolve(__dirname, \"client\"),\n  build: {\n    outDir: path.resolve(__dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n});\n","size_bytes":1025},"docs/design-system.md":{"content":"# London Day Planner Design System\n\n## Brand Identity\nOur design system reflects a premium, elegant, and youthful aesthetic that appeals to modern travelers and professionals. The interface should feel sophisticated yet approachable, mixing minimalist design with thoughtful interactions.\n\n## Color Palette\n\n### Primary Colors\n- Primary: `#2D3250` (Deep Navy)\n- Secondary: `#7C73E6` (Soft Purple)\n- Accent: `#FF6B6B` (Coral Pink)\n\n### Neutral Palette\n- Background: `#FFFFFF` (Pure White)\n- Surface: `#F8F9FC` (Light Gray)\n- Border: `#E2E8F0` (Soft Gray)\n\n### Text Colors\n- Primary Text: `#1A202C` (Dark Gray)\n- Secondary Text: `#4A5568` (Medium Gray)\n- Muted Text: `#718096` (Light Gray)\n\n### Semantic Colors\n- Success: `#48BB78` (Green)\n- Warning: `#ECC94B` (Yellow)\n- Error: `#F56565` (Red)\n- Info: `#4299E1` (Blue)\n\n## Typography\n\n### Font Families\n- Primary: Inter\n- Headings: Montserrat\n- Monospace: JetBrains Mono (for time displays)\n\n### Font Sizes\n- xs: 0.75rem (12px)\n- sm: 0.875rem (14px)\n- base: 1rem (16px)\n- lg: 1.125rem (18px)\n- xl: 1.25rem (20px)\n- 2xl: 1.5rem (24px)\n- 3xl: 1.875rem (30px)\n- 4xl: 2.25rem (36px)\n\n### Font Weights\n- Light: 300\n- Regular: 400\n- Medium: 500\n- Semibold: 600\n- Bold: 700\n\n## Spacing System\nUsing a 4-point grid system:\n- xs: 0.25rem (4px)\n- sm: 0.5rem (8px)\n- base: 1rem (16px)\n- lg: 1.5rem (24px)\n- xl: 2rem (32px)\n- 2xl: 3rem (48px)\n- 3xl: 4rem (64px)\n\n## Component Styling\n\n### Buttons\n- Border Radius: 0.5rem (8px)\n- Height: 2.5rem (40px)\n- Padding: 0.75rem 1.5rem\n- Transition: 150ms ease\n\nStates:\n- Default: Solid background\n- Hover: Slight brightness increase (105%)\n- Active: Slight brightness decrease (95%)\n- Disabled: 40% opacity\n\n### Input Fields\n- Border Radius: 0.5rem (8px)\n- Height: 2.75rem (44px)\n- Border: 1px solid border color\n- Background: White\n- Padding: 0.75rem 1rem\n\nStates:\n- Focus: 2px ring in primary color\n- Error: Red border and error message\n- Disabled: Light gray background\n\n### Cards\n- Border Radius: 1rem (16px)\n- Border: 1px solid border color\n- Shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1)\n- Background: White\n- Padding: 1.5rem\n\n### Timeline Items\n- Connector Line: 2px solid border color\n- Icon Background: Primary color at 10% opacity\n- Icon Color: Primary color\n- Spacing between items: 1.5rem\n\n## Layout Guidelines\n\n### Grid System\n- 12-column grid\n- Maximum width: 1280px\n- Gutter width: 2rem\n- Column gap: 1rem\n\n### Breakpoints\n- sm: 640px\n- md: 768px\n- lg: 1024px\n- xl: 1280px\n- 2xl: 1536px\n\n### Container Padding\n- Mobile: 1rem\n- Tablet: 2rem\n- Desktop: 4rem\n\n## Micro-interactions\n\n### Transitions\n- Duration: 150ms\n- Timing Function: ease\n- Properties: opacity, transform, background-color\n\n### Hover Effects\n- Scale: 1.02\n- Shadow increase\n- Color brightness adjustment\n\n### Loading States\n- Skeleton loading for content\n- Subtle pulse animation\n- Progress indicators for actions\n\n## Best Practices\n\n### Accessibility\n- Minimum contrast ratio: 4.5:1\n- Focus indicators always visible\n- Interactive elements: minimum 44x44px touch target\n- Proper heading hierarchy\n\n### Responsive Design\n- Mobile-first approach\n- Fluid typography\n- Flexible grid system\n- Adaptive spacing\n\n### Visual Hierarchy\n- Clear section separation\n- Consistent spacing\n- Visual weight distribution\n- Strategic use of color and typography\n\n### Performance\n- Optimize transitions\n- Lazy load images\n- Minimize layout shifts\n- Efficient animation techniques\n","size_bytes":3418},"docs/layouts.md":{"content":"# Layout System Documentation\n\n## Grid System\n\nOur layout system uses a modern, flexible grid that adapts to different screen sizes while maintaining consistent spacing and alignment.\n\n### Base Grid\n- 12-column system\n- Fluid gutters (min: 16px, max: 24px)\n- Maximum content width: 1280px\n- Responsive breakpoints with smooth transitions\n\n### Spacing Scale\n```\nxs: 0.25rem (4px)\nsm: 0.5rem (8px)\nmd: 1rem (16px)\nlg: 1.5rem (24px)\nxl: 2rem (32px)\n2xl: 3rem (48px)\n3xl: 4rem (64px)\n```\n\n## Page Layouts\n\n### Home Page\n```\n|- Header (full width)\n|- Hero Section (centered, max-width)\n|- Plan Form (card layout)\n  |- Date/Time Selection\n  |- Plan Description\n  |- Submit Button\n|- Itinerary Display\n  |- Timeline\n  |- Activity Cards\n|- Footer\n```\n\n### Responsive Behavior\n- Mobile: Single column, stacked layout\n- Tablet: Two column where appropriate\n- Desktop: Full grid utilization\n- Wide: Maximum width with balanced margins\n\n## Container System\n\n### Default Container\n- Centered content\n- Responsive padding\n- Maximum width constraint\n- Smooth scaling\n\n```css\n.container {\n  width: 100%;\n  margin-left: auto;\n  margin-right: auto;\n  padding-left: 1rem;\n  padding-right: 1rem;\n  max-width: 1280px;\n}\n\n@media (min-width: 640px) {\n  .container {\n    padding-left: 2rem;\n    padding-right: 2rem;\n  }\n}\n```\n\n### Container Variants\n1. Narrow\n   - Max-width: 768px\n   - Centered content\n   - Ideal for forms\n\n2. Wide\n   - Max-width: 1536px\n   - Full-width sections\n   - Hero areas\n\n3. Full Bleed\n   - No max-width\n   - Edge-to-edge content\n   - Background elements\n\n## Spacing Guidelines\n\n### Vertical Rhythm\n- Consistent spacing between sections\n- Proportional margins and padding\n- Clear visual hierarchy\n\n### Component Spacing\n- Card padding: 1.5rem\n- Section margins: 2rem\n- Form field gaps: 1rem\n\n## Responsive Design\n\n### Breakpoints\n```\nsm: 640px  (Mobile landscape)\nmd: 768px  (Tablet)\nlg: 1024px (Desktop)\nxl: 1280px (Wide desktop)\n2xl: 1536px (Extra wide)\n```\n\n### Mobile First\n- Base styles for mobile\n- Progressive enhancement\n- Fluid typography\n- Flexible layouts\n\n### Touch Targets\n- Minimum size: 44x44px\n- Adequate spacing\n- Clear feedback states\n\n## Animation Guidelines\n\n### Page Transitions\n- Smooth fade-in\n- Content slide-up\n- Progressive loading\n\n### Component Animations\n- Subtle scale on hover\n- Smooth color transitions\n- Loading states\n\n## Best Practices\n\n1. Consistency\n- Use standard spacing\n- Maintain alignment\n- Follow grid system\n\n2. Accessibility\n- Logical tab order\n- Keyboard navigation\n- Screen reader flow\n\n3. Performance\n- Minimize layout shifts\n- Optimize for paint\n- Reduce reflows\n\n4. Responsive Testing\n- Test all breakpoints\n- Verify touch interactions\n- Check content flow\n","size_bytes":2710},"server/config.ts":{"content":"/**\n * Central configuration for API keys and feature flags\n * \n * This module centralizes all environment variables and configuration settings,\n * providing validation and feature flag management.\n */\n\nimport { z } from \"zod\";\n\n// API key validation schemas - using simple length validation to be more flexible\nconst apiKeySchemas = {\n  GEMINI_API_KEY: z.string().min(1),  // Always accept key if present, validation patterns will be checked later\n  GOOGLE_PLACES_API_KEY: z.string().min(1),  // Always accept key if present, validation patterns will be checked later\n  WEATHER_API_KEY: z.string().optional(),\n  GOOGLE_CLIENT_ID: z.string().optional()  // OAuth Client ID for Google authentication\n};\n\n// Legacy API key validation patterns - kept for compatibility\nconst API_KEY_PATTERNS = {\n  GEMINI: /^[A-Za-z0-9-_]{32,}$/,\n  GOOGLE: /^[A-Za-z0-9-_]{39}$/,\n  WEATHER: /^[A-Za-z0-9-_]{32}$/\n} as const;\n\n// Feature flag definitions with dependencies\nconst featureFlags = {\n  AI_PROCESSING: {\n    enabled: true,\n    required: [\"GEMINI_API_KEY\"],\n    fallback: false,\n    description: \"Use AI for natural language understanding\"\n  },\n  USE_GEMINI: {\n    enabled: true,\n    required: [\"GEMINI_API_KEY\"],\n    fallback: false,\n    description: \"Use Gemini 1.5 Pro AI for enhanced request understanding\"\n  },\n  WEATHER_AWARE: {\n    enabled: true,\n    required: [\"WEATHER_API_KEY\"],\n    fallback: false,\n    description: \"Use weather data to adjust recommendations\"\n  },\n  PLACES_API: {\n    enabled: true,\n    required: [\"GOOGLE_PLACES_API_KEY\"],\n    fallback: false,\n    description: \"Google Places API integration\"\n  }\n};\n\n// Define environment variable schema with validation - legacy structure\nconst envSchema = z.object({\n  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),\n  GEMINI_API_KEY: z.string().optional(),\n  GOOGLE_PLACES_API_KEY: z.string().optional(),\n  WEATHER_API_KEY: z.string().optional(),\n  GOOGLE_CLIENT_ID: z.string().optional(),\n  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  FEATURE_FLAGS: z.record(z.boolean()).optional(),\n});\n\n// Configuration types\nexport type Environment = z.infer<typeof envSchema>['NODE_ENV'];\nexport type LogLevel = z.infer<typeof envSchema>['LOG_LEVEL'];\n\nexport interface FeatureConfig {\n  enabled: boolean;\n  fallbackEnabled: boolean;\n  required: boolean;\n}\n\nexport interface ApiConfig {\n  key: string;\n  pattern: RegExp;\n  required: boolean;\n}\n\n// Legacy feature and API configurations - kept for compatibility\nexport const FEATURE_CONFIG: Record<string, FeatureConfig> = {\n  AI_PROCESSING: {\n    enabled: true,\n    fallbackEnabled: true,\n    required: false\n  },\n  PLACES_API: {\n    enabled: true,\n    fallbackEnabled: true,\n    required: true\n  },\n  WEATHER_API: {\n    enabled: true,\n    fallbackEnabled: false,\n    required: false\n  },\n  USE_GEMINI: {\n    enabled: true,\n    fallbackEnabled: false,\n    required: false\n  }\n} as const;\n\nexport const API_CONFIG: Record<string, ApiConfig> = {\n  GEMINI_API_KEY: {\n    key: '',\n    pattern: API_KEY_PATTERNS.GEMINI,\n    required: false\n  },\n  GOOGLE_PLACES_API_KEY: {\n    key: '',\n    pattern: API_KEY_PATTERNS.GOOGLE,\n    required: true\n  },\n  WEATHER_API_KEY: {\n    key: '',\n    pattern: API_KEY_PATTERNS.WEATHER,\n    required: false\n  },\n  GOOGLE_CLIENT_ID: {\n    key: '',\n    pattern: /.+/,  // Any non-empty string\n    required: false\n  }\n} as const;\n\n// Configuration singleton\nclass Config {\n  private static instance: Config;\n  private apiKeys: Record<string, string | undefined> = {};\n  private features: Record<string, boolean> = {};\n  private env: z.infer<typeof envSchema>;\n  private legacyFeatures: typeof FEATURE_CONFIG;\n  private legacyApis: typeof API_CONFIG;\n  private initialized = false;\n\n  private constructor() {\n    // Initialize environment\n    try {\n      this.env = envSchema.parse(process.env);\n    } catch (error) {\n      console.error('Environment validation failed:', error);\n      this.env = envSchema.parse({});\n    }\n    \n    // Initialize legacy structures\n    this.legacyFeatures = FEATURE_CONFIG;\n    this.legacyApis = API_CONFIG;\n    \n    // Load API keys first - CRITICAL: Must be done before initializing feature flags\n    this.loadApiKeys();\n    \n    // Update legacy API configurations\n    this.updateLegacyApiConfig();\n    \n    // Now initialize feature flags with loaded API keys\n    this.initializeFeatureFlags();\n    \n    // Initialize legacy feature flags based on API key availability\n    this.updateLegacyFeatureConfig();\n  }\n\n  public static getInstance(): Config {\n    if (!Config.instance) {\n      Config.instance = new Config();\n    }\n    return Config.instance;\n  }\n\n  public initialize(): void {\n    if (this.initialized) return;\n    \n    // Log configuration status\n    this.logConfigStatus();\n    \n    this.initialized = true;\n  }\n\n  private loadApiKeys(): void {\n    // Load and validate API keys - directly from process.env\n    for (const key of Object.keys(apiKeySchemas)) {\n      const envValue = process.env[key];\n      console.log(`Direct environment check - ${key}: ${!!envValue} (length: ${envValue ? envValue.length : 0})`);\n      \n      this.apiKeys[key] = envValue;\n      \n      // Also update legacy API configuration\n      if (this.legacyApis[key as keyof typeof API_CONFIG]) {\n        this.legacyApis[key as keyof typeof API_CONFIG].key = this.apiKeys[key] || '';\n      }\n    }\n    \n    // Force set the keys to ensure they are properly assigned\n    this.apiKeys[\"GEMINI_API_KEY\"] = process.env.GEMINI_API_KEY;\n    this.apiKeys[\"GOOGLE_PLACES_API_KEY\"] = process.env.GOOGLE_PLACES_API_KEY;\n    this.apiKeys[\"WEATHER_API_KEY\"] = process.env.WEATHER_API_KEY;\n    this.apiKeys[\"GOOGLE_CLIENT_ID\"] = process.env.GOOGLE_CLIENT_ID;\n    \n    // Debug log the API keys without revealing their values\n    for (const [key, value] of Object.entries(this.apiKeys)) {\n      console.log(`API Key loaded: ${key} = ${!!value} (length: ${value ? value.length : 0})`);\n    }\n  }\n\n  private updateLegacyApiConfig(): void {\n    // Update legacy API configurations\n    Object.keys(this.legacyApis).forEach(key => {\n      const value = this.apiKeys[key];\n      if (value) {\n        this.legacyApis[key as keyof typeof API_CONFIG].key = value;\n      }\n    });\n  }\n\n  private updateLegacyFeatureConfig(): void {\n    // Update legacy feature configurations\n    Object.keys(this.legacyFeatures).forEach(feature => {\n      const apiKey = this.legacyApis[`${feature.split('_')[0]}_API_KEY` as keyof typeof API_CONFIG];\n      if (apiKey) {\n        this.legacyFeatures[feature as keyof typeof FEATURE_CONFIG].enabled = !!apiKey.key;\n      }\n      \n      // Also update from new feature flags\n      if (this.features[feature]) {\n        this.legacyFeatures[feature as keyof typeof FEATURE_CONFIG].enabled = this.features[feature];\n      }\n    });\n  }\n\n  private initializeFeatureFlags(): void {\n    // Set default feature flags\n    for (const [feature, config] of Object.entries(featureFlags)) {\n      // Check if all required API keys are available\n      const hasRequiredKeys = config.required.every(key => \n        this.isApiKeyValid(key)\n      );\n      \n      // Enable feature if all requirements are met\n      this.features[feature] = config.enabled && hasRequiredKeys;\n      \n      // Log initialization\n      if (this.features[feature]) {\n        console.log(`${feature} feature flag status: true`);\n      } else {\n        console.log(`${feature} feature flag status: false (missing requirements or disabled)`);\n      }\n    }\n  }\n\n  private isApiKeyValid(key: string): boolean {\n    const value = this.apiKeys[key];\n    \n    // Log the key existence (without revealing the actual key)\n    console.log(`${key} present: ${!!value} (length: ${value ? value.length : 0})`);\n    \n    // Always return true if the key exists (simpler validation)\n    if (value && value.length > 0) {\n      console.log(`${key} validation: true`);\n      return true;\n    }\n    \n    console.log(`${key} validation: false`);\n    return false;\n  }\n\n  // Environment access\n  public get environment(): Environment {\n    return this.env.NODE_ENV;\n  }\n\n  public get logLevel(): LogLevel {\n    return this.env.LOG_LEVEL;\n  }\n\n  // API key access\n  public getApiKey(key: string): string | undefined {\n    return this.apiKeys[key];\n  }\n\n  // Feature flag access\n  public isFeatureEnabled(feature: string): boolean {\n    // First check new feature flags\n    if (this.features[feature] !== undefined) {\n      return this.features[feature];\n    }\n    \n    // Fall back to legacy feature flags\n    if (this.legacyFeatures[feature as keyof typeof FEATURE_CONFIG]) {\n      return this.legacyFeatures[feature as keyof typeof FEATURE_CONFIG].enabled;\n    }\n    \n    return false;\n  }\n\n  public isFallbackEnabled(feature: keyof typeof FEATURE_CONFIG): boolean {\n    return this.legacyFeatures[feature].fallbackEnabled;\n  }\n\n  public isFeatureRequired(feature: keyof typeof FEATURE_CONFIG): boolean {\n    return this.legacyFeatures[feature].required;\n  }\n\n  public validateApiKey(key: string): boolean {\n    // Simplified validation - just check if key exists and has length\n    const value = this.apiKeys[key];\n    return value !== undefined && value.length > 0;\n  }\n\n  private logConfigStatus(): void {\n    // Log configuration status (without revealing sensitive values)\n    const redactedConfig = {\n      features: this.features,\n      apiKeysPresent: Object.entries(this.apiKeys).reduce((acc, [key, value]) => {\n        acc[key] = !!value;\n        return acc;\n      }, {} as Record<string, boolean>),\n      environment: this.environment\n    };\n    \n    console.log('Application configuration:', redactedConfig);\n  }\n\n  public getRedactedConfig(): Record<string, unknown> {\n    return {\n      environment: this.environment,\n      logLevel: this.logLevel,\n      features: Object.entries(this.features).map(([feature, enabled]) => ({\n        feature,\n        enabled\n      })),\n      apis: Object.entries(this.apiKeys).map(([key, value]) => ({\n        key,\n        configured: !!value,\n        valid: this.validateApiKey(key)\n      }))\n    };\n  }\n}\n\n// Initialize configuration\nconst config = Config.getInstance();\nconfig.initialize();\n\n// Helper functions for easier access\nexport function getApiKey(key: string): string | undefined {\n  return config.getApiKey(key);\n}\n\nexport function isFeatureEnabled(feature: string): boolean {\n  return config.isFeatureEnabled(feature);\n}\n\nexport function isFallbackEnabled(feature: keyof typeof FEATURE_CONFIG): boolean {\n  return config.isFallbackEnabled(feature);\n}\n\nexport function isFeatureRequired(feature: keyof typeof FEATURE_CONFIG): boolean {\n  return config.isFeatureRequired(feature);\n}\n\nexport function validateApiKey(key: string): boolean {\n  return config.validateApiKey(key);\n}\n\n// Export feature flags for direct access if needed\nexport const FEATURES = Object.entries(FEATURE_CONFIG).reduce(\n  (acc, [key, config]) => ({ ...acc, [key]: config.enabled }),\n  {} as Record<keyof typeof FEATURE_CONFIG, boolean>\n);\n\nexport { config };\nexport default config;","size_bytes":11068},"server/db.ts":{"content":"\nimport { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-serverless';\nimport ws from \"ws\";\nimport * as schema from \"@shared/schema\";\nimport type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';\n\nneonConfig.webSocketConstructor = ws;\n\nconst databaseUrl = process.env.DATABASE_URL;\nif (!databaseUrl) {\n  console.error(\"DATABASE_URL not found. Please add the DATABASE_URL secret in the Deployments tab.\");\n  process.exit(1);\n}\n\nlet pool: Pool;\nlet db: PostgresJsDatabase<typeof schema>;\n\ntry {\n  // Initialize pool and db instances\n  pool = new Pool({ \n    connectionString: databaseUrl,\n    max: 20,\n    ssl: process.env.NODE_ENV === 'production'\n  });\n  db = drizzle(pool, { schema });\n  console.log('Database connection initialized successfully');\n} catch (error) {\n  console.error(\"Failed to initialize database connection:\", error);\n  process.exit(1);\n}\n\n// Export the initialized variables\nexport { pool, db };\n","size_bytes":967},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\nimport session from 'express-session';\nimport MemoryStore from 'memorystore';\n\n// Import config module\nimport './config';\n\n// Set up session store with memory store for now\nconst MemStoreSession = MemoryStore(session);\n\n// Check for session secret\nif (!process.env.SESSION_SECRET) {\n  console.warn('Warning: SESSION_SECRET not set in environment. Using a default secret. This is not secure for production.');\n}\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\n// Configure session middleware with memory store temporarily\napp.use(session({\n  store: new MemStoreSession({\n    checkPeriod: 86400000 // prune expired entries every 24h\n  }),\n  secret: process.env.SESSION_SECRET || 'nyc-day-planner-dev-secret',\n  resave: false,\n  saveUninitialized: false,\n  cookie: { \n    secure: process.env.NODE_ENV === 'production',\n    maxAge: 30 * 24 * 60 * 60 * 1000 // 30 days\n  }\n}));\n\n// Serve static files for NYC route\napp.use('/NYC', express.static('dist/public'));\n// Also serve at root for custom domain access\napp.use('/', express.static('dist/public'));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"…\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  console.log(\"Starting application...\");\n\n  const server = await registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on port 5000\n  // this serves both the API and the client\n  const port = 5000;\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true,\n  }, () => {\n    log(`serving on port ${port}`);\n  });\n})();","size_bytes":2916},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer } from \"http\";\nimport { storage } from \"./storage\";\nimport { searchPlace } from \"./lib/googlePlaces\";\nimport { calculateTravelTime } from \"./lib/itinerary\";\nimport { parseItineraryRequest } from \"./lib/nlp-fixed\";\nimport { StructuredRequest } from \"@shared/types\";\nimport { insertPlaceSchema, insertItinerarySchema, Place, PlaceDetails } from \"@shared/schema\";\nimport { z } from \"zod\";\nimport { format } from 'date-fns';\nimport { formatInTimeZone, toZonedTime } from 'date-fns-tz';\nimport { findAreasByCharacteristics, findQuietAreas, getAreaCrowdLevel, NYCArea, nycAreas } from \"./data/new-york-areas\";\nimport { getWeatherForecast, isVenueOutdoor, isWeatherSuitableForOutdoor, getWeatherAwareVenue } from \"./lib/weatherService\";\n\n// Import the timeUtils module\nimport { \n  parseAndNormalizeTime, \n  NYC_TIMEZONE, \n  formatISOToNYCTime, \n  timeStringToNYCISOString \n} from './lib/timeUtils';\n\n/**\n * Detect the appropriate activity type from query and activity text\n * Used to improve type detection for vague queries\n * \n * @param query The original user query\n * @param activity The specific activity text\n * @returns Place type string for Google Places API\n */\nfunction detectActivityTypeFromQuery(query: string, activity: string): string {\n  // Normalize queries to lowercase for matching\n  const normalizedQuery = query.toLowerCase();\n  const normalizedActivity = activity.toLowerCase();\n  \n  // Food-related detection - check both query and activity text\n  const foodKeywords = [\n    'sandwich', 'lunch', 'dinner', 'breakfast', 'brunch', 'food', \n    'restaurant', 'eat', 'meal', 'burger', 'steak', 'pizza', \n    'sushi', 'dining', 'hungry'\n  ];\n  \n  // Check for food keywords in both query and activity\n  const isFoodRelated = foodKeywords.some(keyword => \n    normalizedQuery.includes(keyword) || normalizedActivity.includes(keyword)\n  );\n  \n  if (isFoodRelated) {\n    return 'restaurant';\n  }\n  \n  // Coffee/cafe detection - check both query and activity text\n  const cafeKeywords = ['coffee', 'cafe', 'tea', 'espresso'];\n  \n  // Check for cafe keywords in both query and activity\n  const isCafeRelated = cafeKeywords.some(keyword => \n    normalizedQuery.includes(keyword) || normalizedActivity.includes(keyword)\n  );\n  \n  if (isCafeRelated) {\n    return 'cafe';\n  }\n  \n  // Spa/massage detection\n  if (\n    normalizedQuery.includes('spa') || \n    normalizedQuery.includes('massage') || \n    normalizedQuery.includes('relax') || \n    normalizedQuery.includes('treatment')\n  ) {\n    return 'spa';\n  }\n  \n  // Shopping detection\n  if (\n    normalizedQuery.includes('shop') || \n    normalizedQuery.includes('store') || \n    normalizedQuery.includes('buy') || \n    normalizedQuery.includes('mall')\n  ) {\n    return 'shopping_mall';\n  }\n  \n  // Attraction detection\n  if (\n    normalizedQuery.includes('see') || \n    normalizedQuery.includes('visit') || \n    normalizedQuery.includes('tour') || \n    normalizedQuery.includes('attraction')\n  ) {\n    return 'tourist_attraction';\n  }\n  \n  // Nightlife detection\n  if (\n    normalizedQuery.includes('bar') || \n    normalizedQuery.includes('pub') || \n    normalizedQuery.includes('drink') || \n    normalizedQuery.includes('club')\n  ) {\n    return 'bar';\n  }\n  \n  // Default to restaurant as a reasonable fallback for food-related activities\n  if (normalizedActivity.includes('eat') || normalizedActivity.includes('food')) {\n    return 'restaurant';\n  }\n  \n  // Use tourist_attraction as a generic fallback\n  return 'tourist_attraction';\n}\n\n/**\n * Parse a time string to a Date object\n * Provides consistent time parsing throughout the application\n * Uses America/New_York timezone for consistent local time representation\n * \n * @param timeStr Time string to parse (e.g., \"3pm\", \"15:00\", \"evening\", \"at 6\", \"around noon\", \"around 3 PM\")\n * @param baseDate Base date to use (defaults to current date)\n * @returns Date object with the specified time in America/New_York timezone\n */\nfunction parseTimeString(timeStr: string, baseDate?: Date): Date {\n  try {\n    // Using the imported constants and functions from timeUtils that are already imported at the top of the file\n    \n    // Use provided base date or current date\n    const currentDate = baseDate || new Date();\n    \n    // Check if we already have an ISO timestamp (contains 'T' and 'Z')\n    if (timeStr.includes('T') && timeStr.includes('Z')) {\n      try {\n        // Parse the ISO timestamp and return a Date object\n        const date = new Date(timeStr);\n        \n        // Log for debugging\n        console.log(`Parsed ISO timestamp \"${timeStr}\" to NYC time: ${formatInTimeZone(date, NYC_TIMEZONE, 'yyyy-MM-dd HH:mm:ss zzz')}`);\n        \n        return date;\n      } catch (err) {\n        console.warn(`Failed to parse ISO timestamp: ${timeStr}, falling back to manual parsing`);\n        // Fall through to manual parsing\n      }\n    }\n    \n    // Get the normalized time string in 24-hour format (HH:MM)\n    // Now handles \"around X\" phrases properly with our improved timeUtils\n    const normalizedTime = parseAndNormalizeTime(timeStr);\n    \n    // Extract hours and minutes\n    const [hoursStr, minutesStr] = normalizedTime.split(':');\n    const hours = parseInt(hoursStr, 10);\n    const minutes = parseInt(minutesStr, 10);\n    \n    // Create a new date with the specified time based on the provided base date\n    const date = new Date(currentDate);\n    date.setHours(hours, minutes, 0, 0);\n    \n    // Convert to NYC timezone\n    const nycDate = toZonedTime(date, NYC_TIMEZONE);\n    \n    // Format time for logging\n    const displayTime = formatInTimeZone(nycDate, NYC_TIMEZONE, 'h:mm a');\n    const formattedTime = formatInTimeZone(nycDate, NYC_TIMEZONE, 'yyyy-MM-dd HH:mm:ss zzz');\n    \n    console.log(`Parsed time \"${timeStr}\" to normalized time \"${normalizedTime}\" and NYC time: ${displayTime} (${formattedTime})`);\n    \n    return nycDate;\n  } catch (error) {\n    console.error(`Error parsing time:`, error);\n    // Return a default time if parsing fails\n    const defaultDate = baseDate || new Date();\n    // Default to 10:00 AM NYC time if parsing fails\n    defaultDate.setHours(10, 0, 0, 0);\n    \n    // Convert to NYC timezone\n    const nycDate = toZonedTime(defaultDate, 'America/New_York');\n    \n    return nycDate;\n  }\n}\n\nexport function findInterestingActivities(\n  currentLocation: string,\n  availableHours: number,\n  preferences: any,\n  // Optional user preferences\n  dayPart: 'morning' | 'afternoon' | 'evening' | 'night' = 'afternoon'\n): any[] {\n  console.log(\"Finding activities based on preferences:\", preferences);\n  \n  // Check for area matches first\n  const possibleArea = nycAreas.find((a: NYCArea) => \n    a.name.toLowerCase().includes(currentLocation.toLowerCase()) ||\n    a.characteristics.some(c => currentLocation.toLowerCase().includes(c))\n  );\n  \n  const areaParam = possibleArea ? possibleArea.name : undefined;\n  \n  // Start with empty results, we'll fill based on what we find\n  const results = [];\n  \n  // Attempt to find an area in NYC that matches the specified preferences\n  let matchedAreas: NYCArea[] = [];\n  \n  // If we have specific requirements, use them for filtering\n  if (preferences?.requirements && preferences.requirements.length > 0) {\n    matchedAreas = findAreasByCharacteristics(\n      preferences.requirements,\n      possibleArea ? [possibleArea.name] : undefined\n    );\n  } \n  // Otherwise use preference type as a guide\n  else if (preferences?.type) {\n    const typeToCharacteristics: Record<string, string[]> = {\n      'cafe': ['quiet', 'relaxed'],\n      'park': ['outdoor', 'nature'],\n      'restaurant': ['dining', 'food'],\n      'bar': ['lively', 'nightlife'],\n      'shopping': ['shopping', 'busy'],\n      'museum': ['culture', 'quiet'],\n      'art': ['culture', 'creative'],\n      'activity': ['interesting', 'popular'],\n      'tourist_attraction': ['popular', 'must-see']\n    };\n    \n    // Get characteristics matching the preference type, or use 'interesting' as default\n    const characteristics = typeToCharacteristics[preferences.type] || ['interesting'];\n    \n    // Find areas matching these characteristics\n    matchedAreas = findAreasByCharacteristics(\n      characteristics,\n      possibleArea ? [possibleArea.name] : undefined\n    );\n  }\n  \n  // If we got area matches, create suggested activities from them\n  if (matchedAreas.length > 0) {\n    // Limit to top 3 areas\n    matchedAreas = matchedAreas.slice(0, 3);\n    \n    for (const area of matchedAreas) {\n      // Time per activity in hours (roughly)\n      const activityLength = Math.min(1.5, availableHours / matchedAreas.length);\n      \n      // Type of place to suggest based on preferences and time of day\n      let placeType = 'tourist_attraction';\n      \n      if (preferences.type === 'cafe' || preferences.type === 'restaurant' || \n          preferences.type === 'bar' || preferences.type === 'shop') {\n        placeType = preferences.type;\n      } else {\n        // Default types based on time of day if no specific type\n        if (dayPart === 'morning') {\n          placeType = 'cafe';\n        } else if (dayPart === 'afternoon') {\n          placeType = 'tourist_attraction';\n        } else if (dayPart === 'evening' || dayPart === 'night') {\n          placeType = 'bar';\n        }\n      }\n      \n      // Create a suggestion based on area characteristics\n      results.push({\n        activity: `Explore ${area.name}`,\n        location: area.name,\n        duration: Math.round(activityLength * 60), // Convert to minutes\n        type: placeType,\n        description: `Interesting area to explore in ${area.name}. Known for ${area.popularFor.join(', ')}.`\n      });\n    }\n  }\n  \n  // If no area-based suggestions or fewer than needed, add general suggestions\n  if (results.length === 0) {\n    // Default suggestion - tourist_attraction is a good generic fallback\n    results.push({\n      activity: \"See interesting sights\",\n      location: possibleArea ? possibleArea.name : \"NYC\",\n      duration: Math.round(Math.min(2, availableHours) * 60), // Convert to minutes\n      type: \"tourist_attraction\",\n      description: \"Explore interesting attractions and sights in the area.\"\n    });\n  }\n  \n  return results;\n}\n\nexport async function registerRoutes(app: Express) {\n  const httpServer = createServer(app);\n  \n  app.post(\"/api/plan\", async (req, res) => {\n    try {\n      const requestSchema = z.object({\n        query: z.string(),\n        date: z.string().optional(),\n        startTime: z.string().optional()\n      });\n\n      const { query, date, startTime } = requestSchema.parse(req.body);\n\n      // Parse the request using NLP\n      const parsed = await parseItineraryRequest(query);\n      console.log(\"Parsed request:\", parsed);\n      \n      // Flag to control automatic gap-filling (set to false to only use explicitly requested activities)\n      const enableGapFilling = false;\n\n      // If no explicit start location, use the first location mentioned\n      if (!parsed.startLocation) {\n        // Use the first fixed time location or first destination\n        parsed.startLocation = parsed.fixedTimes[0]?.location || parsed.destinations[0];\n        if (!parsed.startLocation) {\n          throw new Error(\"Could not determine a starting location from your request. Please mention where you'd like to start.\");\n        }\n      }\n\n      // Initialize base date and time\n      const baseDate = date ? new Date(date) : new Date();\n      let currentTime = startTime\n        ? parseTimeString(startTime, baseDate)\n        : new Date(baseDate.setHours(9, 0, 0, 0));\n\n      const scheduledPlaces = new Set(); // Track unique places\n      const itineraryPlaces = [];\n\n      // Handle lunch request specifically - only if gap filling is enabled or explicitly requested\n      if (enableGapFilling && parsed.preferences?.type?.includes('lunch')) {\n        console.log(\"Searching for lunch venue near:\", parsed.startLocation);\n        try {\n          // Enhanced search options for lunch\n          const searchOptions: any = {\n            type: 'restaurant',\n            requireOpenNow: true,\n            minRating: 4.0,\n            searchTerm: 'lunch restaurant',\n            keywords: ['restaurant', 'lunch', 'dining']\n          };\n          \n          // Add requirements as keywords for better place matching\n          if (parsed.preferences?.requirements && parsed.preferences.requirements.length > 0) {\n            searchOptions.keywords = [\n              ...searchOptions.keywords,\n              ...parsed.preferences.requirements\n            ];\n          }\n          \n          const venueResult = await searchPlace(parsed.startLocation, searchOptions);\n          \n          if (!venueResult || !venueResult.primary) {\n            console.error(\"Failed to find lunch venue near:\", parsed.startLocation);\n          } else {\n            // Use the primary venue from the result\n            let lunchPlace = venueResult.primary;\n\n            // Apply weather-aware venue selection for lunch\n            if (process.env.WEATHER_API_KEY && lunchPlace.types) {\n              try {\n                const lunchTime = parseTimeString('14:00', baseDate);\n                console.log(\"Checking weather conditions for lunch venue...\");\n                \n                // Determine if venue is outdoors based on its types\n                const isOutdoor = lunchPlace.types && isVenueOutdoor(lunchPlace.types);\n                lunchPlace.isOutdoorVenue = isOutdoor;\n                \n                // Check if it's an outdoor venue and if weather conditions are suitable\n                const { venue: recommendedVenue, weatherSuitable } = await getWeatherAwareVenue(\n                  lunchPlace,\n                  venueResult.alternatives,\n                  lunchPlace.geometry.location.lat,\n                  lunchPlace.geometry.location.lng,\n                  lunchTime\n                );\n                \n                // Set weather information on both the suggested place and alternatives\n                lunchPlace.weatherSuitable = weatherSuitable;\n                \n                // If this venue has alternatives, mark them appropriately\n                if (venueResult.alternatives && venueResult.alternatives.length > 0) {\n                  venueResult.alternatives.forEach(alt => {\n                    alt.isOutdoorVenue = alt.types ? isVenueOutdoor(alt.types) : false;\n                    alt.weatherSuitable = weatherSuitable;\n                  });\n                }\n                \n                // If weather is not suitable and we have an indoor alternative\n                if (!weatherSuitable && recommendedVenue !== lunchPlace) {\n                  console.log(`Weather not optimal for ${lunchPlace.name} - outdoor seating may be uncomfortable`);\n                  console.log(`Suggesting alternative lunch venue: ${recommendedVenue.name}`);\n                  recommendedVenue.weatherAwareRecommendation = true;\n                  lunchPlace = recommendedVenue;\n                }\n              } catch (weatherError) {\n                console.warn(\"Weather service error for lunch venue (proceeding with original):\", weatherError);\n              }\n            }\n\n            console.log(\"Found lunch venue:\", {\n              name: lunchPlace.name,\n              address: lunchPlace.formatted_address,\n              rating: lunchPlace.rating,\n              alternatives: venueResult.alternatives.length\n            });\n\n            const lunchTime = parseTimeString('14:00', baseDate);\n            const newPlace = await storage.createPlace({\n              placeId: lunchPlace.place_id,\n              name: lunchPlace.name,\n              address: lunchPlace.formatted_address,\n              location: lunchPlace.geometry.location,\n              details: lunchPlace,\n              alternatives: venueResult.alternatives,\n              scheduledTime: lunchTime.toISOString(),\n            });\n\n            // Use composite key with lunch location\n            scheduledPlaces.add(`${lunchPlace.place_id}:lunch`);\n            itineraryPlaces.push({\n              place: newPlace,\n              time: lunchTime,\n              isFixed: true\n            });\n          }\n        } catch (error) {\n          console.error(\"Error finding lunch venue:\", error);\n        }\n      }\n\n      // Handle fixed-time appointments first\n      for (const timeSlot of parsed.fixedTimes) {\n        try {\n          console.log(\"Processing fixed time appointment:\", {\n            location: timeSlot.location,\n            time: timeSlot.time,\n            type: timeSlot.type,\n            searchTerm: timeSlot.searchTerm,\n            keywords: timeSlot.keywords,\n            minRating: timeSlot.minRating\n          });\n\n          const appointmentTime = parseTimeString(timeSlot.time, baseDate);\n          \n          // Infer activity type for vague or missing types\n          // NOTE: This is kept as a safety fallback even though Gemini should now provide types directly\n          // It serves as a final safeguard in case the AI doesn't properly categorize an activity\n          if (!timeSlot.type || timeSlot.type === 'activity') {\n            // Infer the type from the query and search term\n            timeSlot.type = detectActivityTypeFromQuery(\n              query, \n              timeSlot.searchTerm || ''\n            );\n            console.log(`Inferred activity type for \"${timeSlot.searchTerm}\": ${timeSlot.type}`);\n          }\n          \n          // Enhanced search options with parameters from fixedTimes\n          const searchOptions: any = {\n            type: timeSlot.type,\n            requireOpenNow: true,\n            // Make a copy of the keywords array if available or use an empty array\n            keywords: Array.isArray(timeSlot.keywords) ? [...timeSlot.keywords] : [],\n            // Use explicitly provided searchTerm or fall back to type\n            searchTerm: timeSlot.searchTerm || timeSlot.type,\n            // Use explicitly provided minRating or default to 0\n            minRating: typeof timeSlot.minRating === 'number' ? timeSlot.minRating : 0\n          };\n          \n          // Add searchPreference directly to the search options if available\n          if (timeSlot.searchPreference) {\n            console.log(`Using search preference for ${timeSlot.location}: \"${timeSlot.searchPreference}\"`);\n            // Add as a dedicated property for direct usage in the Google Places search\n            searchOptions.searchPreference = timeSlot.searchPreference;\n            \n            // Also add to keywords for broader matching\n            if (!searchOptions.keywords) {\n              searchOptions.keywords = [];\n            }\n            searchOptions.keywords.push(timeSlot.searchPreference);\n          }\n          \n          // Only add additional context if we don't have rich search parameters already\n          if ((!timeSlot.searchTerm || !timeSlot.keywords || timeSlot.keywords.length === 0) && timeSlot.type) {\n            // Add keywords based on common activity types only if not provided by Gemini\n            if (timeSlot.type.includes('coffee') || timeSlot.type.includes('cafe')) {\n              searchOptions.keywords.push('coffee', 'espresso', 'cafe');\n              searchOptions.type = 'cafe';\n              // Use activity type as search term only if not explicitly provided\n              if (!timeSlot.searchTerm) {\n                searchOptions.searchTerm = 'coffee shop';\n              }\n            } else if (timeSlot.type.includes('dinner') || \n                      timeSlot.type.includes('lunch') || \n                      timeSlot.type.includes('restaurant')) {\n              searchOptions.keywords.push('restaurant', 'food', 'dining');\n              searchOptions.type = 'restaurant';\n              // Rating expectations are higher for restaurants\n              if (!timeSlot.minRating) {\n                searchOptions.minRating = 4.0;\n              }\n            } else if (timeSlot.type.includes('museum') || timeSlot.type.includes('gallery')) {\n              searchOptions.keywords.push('art', 'museum', 'exhibit');\n              searchOptions.type = 'museum';\n            } else if (timeSlot.type.includes('park') || timeSlot.type.includes('garden')) {\n              searchOptions.keywords.push('park', 'green space', 'outdoor');\n              searchOptions.type = 'park';\n            } else if (timeSlot.type.includes('shopping')) {\n              searchOptions.keywords.push('shopping', 'mall', 'store');\n              searchOptions.type = 'shopping_mall';\n            }\n          }\n          \n          // Search for the venue with enhanced parameters\n          console.log(`Search options for ${timeSlot.location}:`, JSON.stringify(searchOptions, null, 2));\n          \n          // Log original values from fixedTimes for debugging\n          console.log(`Original fixedTimes values:`, {\n            searchTerm: timeSlot.searchTerm,\n            keywords: timeSlot.keywords,\n            minRating: timeSlot.minRating,\n            type: timeSlot.type\n          });\n          \n          // VERIFIED: Now directly using the non-null location from Gemini without additional checks\n          // The location string should now always be valid as enforced by the Gemini prompt\n          const venueResult = await searchPlace(timeSlot.location, searchOptions);\n\n          if (!venueResult || !venueResult.primary) {\n            throw new Error(`Could not find location: ${timeSlot.location}. Try specifying the full name (e.g. \"The Green Park\" instead of \"Green Park\")`);\n          }\n\n          // Use the primary venue from the result\n          const place = venueResult.primary;\n\n          console.log(\"Found location:\", {\n            name: place.name,\n            address: place.formatted_address,\n            type: place.types,\n            alternatives: venueResult.alternatives.length\n          });\n\n          // Create a composite key using place_id + locationName to allow the same venue for different activities\n          const compositeKey = `${place.place_id}:${timeSlot.location}`;\n          \n          if (scheduledPlaces.has(compositeKey)) {\n            console.log(\"Skipping duplicate location-activity combination:\", place.name, \"at\", timeSlot.location);\n            continue;\n          }\n\n          // Try to create the place with better error handling\n          let newPlace;\n          try {\n            newPlace = await storage.createPlace({\n              placeId: place.place_id,\n              name: place.name,\n              address: place.formatted_address,\n              location: place.geometry.location,\n              details: place,\n              alternatives: venueResult.alternatives,\n              scheduledTime: appointmentTime.toISOString(),\n            });\n          } catch (placeError: any) {\n            // If we get a duplicate key error, try to fetch the existing place\n            if (placeError.code === '23505') {\n              console.warn(`Duplicate place found for ${place.name}, trying to fetch existing record`);\n              const existingPlace = await storage.getPlaceByPlaceId(place.place_id);\n              if (existingPlace) {\n                console.log(`Using existing place record for ${place.name}`);\n                newPlace = existingPlace;\n              } else {\n                throw placeError; // Re-throw if we can't recover\n              }\n            } else {\n              throw placeError; // Re-throw other errors\n            }\n          }\n\n          scheduledPlaces.add(compositeKey);\n          itineraryPlaces.push({\n            place: newPlace,\n            time: appointmentTime,\n            isFixed: true\n          });\n        } catch (error: any) {\n          console.error(`Error scheduling ${timeSlot.location}:`, error);\n          throw new Error(`Error scheduling ${timeSlot.location}: ${error.message}`);\n        }\n      }\n\n      // Sort fixed appointments chronologically\n      itineraryPlaces.sort((a, b) => a.time.getTime() - b.time.getTime());\n\n      // Gap-filling logic has been commented out to only include activities explicitly requested by the user\n      /*\n      // Fill gaps with interesting activities based on preferences\n      if (parsed.preferences?.type || parsed.preferences?.requirements) {\n        for (let i = 0; i < itineraryPlaces.length - 1; i++) {\n          // Explicitly type the current and next variables\n          const current: { place: Place, time: Date, isFixed: boolean } = itineraryPlaces[i];\n          const next: { place: Place, time: Date, isFixed: boolean } = itineraryPlaces[i + 1];\n\n          // Calculate gap between activities\n          const gap = next.time.getTime() - (current.time.getTime() + 90 * 60 * 1000);\n       \n          if (gap > 1.5 * 60 * 60 * 1000) { // If gap > 1.5 hours\n            const suggestedActivities = findInterestingActivities(\n              current.place.name,\n              gap / (60 * 60 * 1000),\n              parsed.preferences,\n              getDayPart(next.time)\n            );\n            \n            // Only add the first suggestion to avoid overcrowding\n            if (suggestedActivities.length > 0) {\n              const activity = suggestedActivities[0];\n              \n              try {\n                console.log(`Filling gap between ${current.place.name} and ${next.place.name} with activity: ${activity.activity}`);\n                \n                // Calculate the midpoint time for the gap activity\n                const midpointTime = new Date(current.time.getTime() + gap / 2);\n                \n                // Determine activity type based on day part and preferences\n                const activityType = \n                  parsed.preferences?.type || \n                  (midpointTime.getHours() < 12 ? 'cafe' : \n                  midpointTime.getHours() < 18 ? 'museum' : 'restaurant');\n                \n                // Enhanced search options for the gap activity\n                const searchOptions: any = {\n                  type: activity.type || activityType,\n                  keywords: ['recommended', 'popular'],\n                  minRating: 4.0,\n                  // Use activity description as search term\n                  searchTerm: activity.activity\n                };\n                \n                // If we have requirements from preferences, add them as keywords\n                if (parsed.preferences?.requirements && parsed.preferences.requirements.length > 0) {\n                  searchOptions.keywords = [\n                    ...searchOptions.keywords,\n                    ...parsed.preferences.requirements\n                  ];\n                }\n                \n                const venueResult = await searchPlace(activity.location, searchOptions);\n                \n                if (venueResult && venueResult.primary) {\n                  const place = venueResult.primary;\n                  console.log(`Found gap-filling activity venue: ${place.name}`);\n                  \n                  // Create a composite key with gap location\n                  const compositeKey = `${place.place_id}:gap`;\n                  \n                  if (scheduledPlaces.has(compositeKey)) {\n                    console.log(\"Skipping duplicate gap-filling venue:\", place.name);\n                    continue;\n                  }\n                  \n                  try {\n                    const newPlace = await storage.createPlace({\n                      placeId: place.place_id,\n                      name: place.name,\n                      address: place.formatted_address,\n                      location: place.geometry.location,\n                      details: place,\n                      alternatives: venueResult.alternatives,\n                      scheduledTime: midpointTime.toISOString(),\n                    });\n                    \n                    scheduledPlaces.add(compositeKey);\n                    \n                    // Add to itinerary\n                    itineraryPlaces.push({\n                      place: newPlace,\n                      time: midpointTime,\n                      isFixed: false\n                    });\n                  } catch (error) {\n                    console.error(`Error creating place for gap activity:`, error);\n                  }\n                }\n              } catch (error) {\n                console.error(`Error finding venue for activity \"${activity.activity}\":`, error);\n              }\n            }\n          }\n        }\n      }\n      */\n\n      // Handle cases where preferences exist but no fixed times\n      // Only include activities that were explicitly mentioned by the user\n      if (itineraryPlaces.length === 0 && \n          (parsed.activities && parsed.activities.length > 0)\n        ) {\n        console.log(`No fixed times but found activities`);\n        \n        try {\n          // Use current time as default starting point\n          let currentTime = new Date();\n          \n          // Check if we have multiple activities from Gemini parsing\n          if (parsed.activities && Array.isArray(parsed.activities) && parsed.activities.length > 0) {\n            console.log(`Found ${parsed.activities.length} activities from Gemini with no fixed times`);\n            \n            // Store existing times to check for duplicates\n            const existingTimes: number[] = [];\n            \n            // Process up to 3 activities maximum to avoid overcrowding\n            const maxActivities = Math.min(3, parsed.activities.length);\n            \n            for (let i = 0; i < maxActivities; i++) {\n              const activity = parsed.activities[i];\n              if (!activity || !activity.description) continue;\n              \n              // Schedule activities 90 minutes apart\n              const activityTime = new Date(currentTime.getTime() + (i * 90 * 60 * 1000));\n              console.log(`Scheduling activity \"${activity.description}\" at ${activityTime.toLocaleTimeString()}`);\n              \n              // Create search options from activity parameters\n              const searchOptions: any = {\n                keywords: [],\n                requireOpenNow: true,\n                minRating: 4.0\n              };\n              \n              // Use rich parameters if available\n              if (activity.searchParameters) {\n                searchOptions.type = activity.searchParameters.type;\n                searchOptions.searchTerm = activity.searchParameters.searchTerm || activity.description;\n                searchOptions.keywords = Array.isArray(activity.searchParameters.keywords) ? \n                                      [...activity.searchParameters.keywords] : [];\n                searchOptions.minRating = activity.searchParameters.minRating || 4.0;\n              } else {\n                // Use activity description as search term\n                searchOptions.searchTerm = activity.description;\n              }\n              \n              // Add requirements as keywords\n              if (Array.isArray(activity.requirements) && activity.requirements.length > 0) {\n                searchOptions.keywords = [\n                  ...searchOptions.keywords,\n                  ...activity.requirements\n                ];\n              }\n              \n              try {\n                const venueResult = await searchPlace(activity.description, searchOptions);\n                \n                if (venueResult && venueResult.primary) {\n                  console.log(`Found venue for activity \"${activity.description}\": ${venueResult.primary.name}`);\n                  \n                  // Try to create the place with better error handling\n                  let newPlace;\n                  try {\n                    newPlace = await storage.createPlace({\n                      placeId: venueResult.primary.place_id,\n                      name: venueResult.primary.name,\n                      address: venueResult.primary.formatted_address,\n                      location: venueResult.primary.geometry.location,\n                      details: venueResult.primary,\n                      scheduledTime: activityTime.toISOString(),\n                      alternatives: venueResult.alternatives || []\n                    });\n                  } catch (placeError: any) {\n                    // If we get a duplicate key error, try to fetch the existing place\n                    if (placeError.code === '23505') {\n                      console.warn(`Duplicate place found for ${venueResult.primary.name}, trying to fetch existing record`);\n                      const existingPlace = await storage.getPlaceByPlaceId(venueResult.primary.place_id);\n                      if (existingPlace) {\n                        console.log(`Using existing place record for ${venueResult.primary.name}`);\n                        newPlace = existingPlace;\n                      } else {\n                        throw placeError; // Re-throw if we can't recover\n                      }\n                    } else {\n                      throw placeError; // Re-throw other errors\n                    }\n                  }\n                  \n                  // Add to itinerary\n                  itineraryPlaces.push({\n                    place: newPlace,\n                    time: activityTime,\n                    isFixed: false\n                  });\n                  \n                  // Mark this place as scheduled with composite key\n                  scheduledPlaces.add(`${venueResult.primary.place_id}:${activity.description}`);\n                  existingTimes.push(activityTime.getTime());\n                }\n              } catch (error) {\n                console.error(`Error finding venue for activity \"${activity.description}\":`, error);\n              }\n            }\n            \n            // If we successfully added activities, skip the fallback single venue logic\n            if (itineraryPlaces.length > 0) {\n              console.log(`Successfully added ${itineraryPlaces.length} activities from Gemini parsing`);\n              // Skip the fallback logic\n              return res.json(await storage.createItinerary({\n                query,\n                places: itineraryPlaces.map(sp => sp.place),\n                travelTimes: [], // No travel times for now\n              }));\n            }\n          }\n        } catch (error) {\n          console.error(\"Error processing activities with no fixed times:\", error);\n        }\n      }\n\n      // Final chronological sort\n      itineraryPlaces.sort((a, b) => a.time.getTime() - b.time.getTime());\n\n      // Calculate travel times between places\n      const travelTimes = [];\n      let lastPlace: PlaceDetails | null = null;\n\n      for (const scheduledPlace of itineraryPlaces) {\n        // First check if we have valid objects for calculating travel time\n        if (lastPlace && \n            scheduledPlace.place.details && \n            typeof scheduledPlace.place.details === 'object' && \n            'name' in scheduledPlace.place.details && \n            'formatted_address' in scheduledPlace.place.details &&\n            'geometry' in scheduledPlace.place.details) {\n          \n          // Type assertion to help TypeScript understand the structure\n          const currentPlaceDetails = scheduledPlace.place.details as PlaceDetails;\n          \n          try {\n            const travelTime = calculateTravelTime(lastPlace, currentPlaceDetails);\n            travelTimes.push({\n              from: lastPlace.name,\n              to: scheduledPlace.place.name,\n              duration: travelTime,\n              arrivalTime: scheduledPlace.time.toISOString()\n            });\n          } catch (error) {\n            console.error(\"Error calculating travel time:\", error);\n            // Add fallback travel time calculation if main calculation fails\n            travelTimes.push({\n              from: lastPlace.name,\n              to: scheduledPlace.place.name,\n              duration: 30, // Default 30 minutes as fallback\n              arrivalTime: scheduledPlace.time.toISOString()\n            });\n          }\n        }\n        \n        // Update last place reference for next iteration\n        if (scheduledPlace.place.details && \n            typeof scheduledPlace.place.details === 'object' && \n            'name' in scheduledPlace.place.details && \n            'formatted_address' in scheduledPlace.place.details &&\n            'geometry' in scheduledPlace.place.details &&\n            'place_id' in scheduledPlace.place.details) {\n          lastPlace = scheduledPlace.place.details as PlaceDetails;\n        }\n      }\n\n      // Create the final itinerary\n      const userId = req.session.userId;\n      console.log(`Creating itinerary with user ID: ${userId || 'none (anonymous)'}`);\n      const itinerary = await storage.createItinerary({\n        query,\n        places: itineraryPlaces.map(sp => sp.place),\n        travelTimes,\n      }, userId); // Associate with the current user if they're logged in\n\n      res.json(itinerary);\n    } catch (error: any) {\n      console.error(\"Error creating itinerary:\", error);\n      res.status(400).json({ message: error.message });\n    }\n  });\n\n  app.get(\"/api/itinerary/:id\", async (req, res) => {\n    const id = parseInt(req.params.id);\n    const itinerary = await storage.getItinerary(id);\n\n    if (!itinerary) {\n      res.status(404).json({ message: \"Itinerary not found\" });\n      return;\n    }\n\n    res.json(itinerary);\n  });\n\n  // Add endpoint to get weather forecast for specific coordinates\n  app.get(\"/api/weather\", async (req, res) => {\n    try {\n      const lat = parseFloat(req.query.lat as string);\n      const lng = parseFloat(req.query.lng as string);\n      \n      if (isNaN(lat) || isNaN(lng)) {\n        return res.status(400).json({ message: \"Valid latitude and longitude are required\" });\n      }\n      \n      if (!process.env.WEATHER_API_KEY) {\n        return res.status(503).json({ message: \"Weather service is not configured\" });\n      }\n      \n      const forecast = await getWeatherForecast(lat, lng);\n      res.json({\n        current: forecast.current,\n        hourly: forecast.hourly?.slice(0, 24), // Return 24 hours of forecasts\n        location: { lat, lng }\n      });\n    } catch (error: any) {\n      console.error(\"Weather API error:\", error);\n      res.status(500).json({ message: error.message });\n    }\n  });\n  \n  // Test endpoint for timezone functionality\n  app.get(\"/api/test-timezone\", (req, res) => {\n    // Create a test with different time formats\n    const testTimes = [\n      \"3pm\",\n      \"15:00\",\n      \"morning\",\n      \"noon\",\n      \"evening\",\n      \"at 6\",\n      \"around 3 PM\"\n    ];\n    \n    const results = testTimes.map(timeStr => {\n      // Process the time using our new functions\n      const normalizedTime = parseAndNormalizeTime(timeStr);\n      const isoTime = timeStringToNYCISOString(timeStr);\n      const displayTime = formatISOToNYCTime(isoTime);\n      \n      return {\n        original: timeStr,\n        normalized: normalizedTime,\n        iso: isoTime,\n        display: displayTime\n      };\n    });\n    \n    res.status(200).json({\n      message: \"NYC timezone test results\",\n      currentNYCTime: formatInTimeZone(new Date(), NYC_TIMEZONE, 'yyyy-MM-dd h:mm:ss a zzz'),\n      results\n    });\n  });\n\n  return httpServer;\n}\n\n// Helper function to determine the part of the day (for recommendations)\nfunction getDayPart(date: Date): 'morning' | 'afternoon' | 'evening' | 'night' {\n  const hour = date.getHours();\n  \n  if (hour >= 5 && hour < 12) {\n    return 'morning';\n  } else if (hour >= 12 && hour < 17) {\n    return 'afternoon';\n  } else if (hour >= 17 && hour < 22) {\n    return 'evening';\n  } else {\n    return 'night';\n  }\n}","size_bytes":39649},"server/storage.ts":{"content":"import { \n  type Place, \n  type InsertPlace, \n  type Itinerary, \n  type InsertItinerary, \n  type User, \n  type UserItinerary, \n  type InsertLocalUser,\n  type InsertGoogleUser\n} from \"@shared/schema\";\nimport { db } from './db';\nimport { users, itineraries, places, userItineraries } from '@shared/schema';\nimport { eq, desc, or } from 'drizzle-orm';\n\n// Configure in-memory fallback for development\nconst USE_IN_MEMORY_FALLBACK = process.env.NODE_ENV === 'development';\nconst inMemoryStorage = {\n  places: new Map<string, Place>(),\n  itineraries: new Map<number, Itinerary>(),\n  users: new Map<string, User>(),\n  userItineraries: new Map<string, number[]>(),\n  nextPlaceId: 1,\n  nextItineraryId: 1\n};\n\nexport interface IStorage {\n  // Place operations\n  getPlace(placeId: string): Promise<Place | undefined>;\n  getPlaceByPlaceId(placeId: string): Promise<Place | undefined>;\n  createPlace(place: InsertPlace): Promise<Place>;\n  \n  // Itinerary operations\n  createItinerary(itinerary: InsertItinerary, userId?: string): Promise<Itinerary>;\n  getItinerary(id: number): Promise<Itinerary | undefined>;\n  getUserItineraries(userId: string): Promise<Itinerary[]>;\n  \n  // User operations\n  getUserById(id: string): Promise<User | undefined>;\n  getUserByEmail(email: string): Promise<User | undefined>;\n  getUserByGoogleId(googleId: string): Promise<User | undefined>;\n  createLocalUser(userData: InsertLocalUser, passwordHash: string): Promise<User>;\n  createGoogleUser(userData: InsertGoogleUser): Promise<User>;\n}\n\n// Database-backed storage implementation\nexport class DbStorage implements IStorage {\n  async getPlace(placeId: string): Promise<Place | undefined> {\n    const results = await db.select()\n      .from(places)\n      .where(eq(places.placeId, placeId))\n      .limit(1);\n    \n    return results.length > 0 ? results[0] : undefined;\n  }\n  \n  // This method is an alias to getPlace for better semantic meaning and compatibility\n  async getPlaceByPlaceId(placeId: string): Promise<Place | undefined> {\n    return this.getPlace(placeId);\n  }\n\n  async createPlace(insertPlace: InsertPlace): Promise<Place> {\n    try {\n      // First check if this place already exists by placeId\n      const existingPlace = await db.select()\n        .from(places)\n        .where(eq(places.placeId, insertPlace.placeId))\n        .limit(1);\n      \n      // If place already exists, just return it\n      if (existingPlace.length > 0) {\n        console.log(`Place \"${insertPlace.name}\" already exists, returning existing record`);\n        return existingPlace[0];\n      }\n      \n      // If not, create a new place\n      const [place] = await db.insert(places)\n        .values(insertPlace)\n        .returning();\n      \n      return place;\n    } catch (error: any) {\n      console.error(\"Error creating place:\", error);\n      \n      // For duplicate key errors, try to get the existing record\n      if (error.code === '23505') { // PostgreSQL duplicate key error\n        try {\n          // Retrieve the existing place\n          const existingPlace = await db.select()\n            .from(places)\n            .where(eq(places.placeId, insertPlace.placeId))\n            .limit(1);\n          \n          if (existingPlace.length > 0) {\n            console.log(`Recovered existing place \"${insertPlace.name}\" after duplicate key error`);\n            return existingPlace[0];\n          }\n        } catch (innerError) {\n          console.error(\"Error retrieving existing place:\", innerError);\n        }\n      }\n      \n      throw error;\n    }\n  }\n\n  async createItinerary(insertItinerary: InsertItinerary, userId?: string): Promise<Itinerary> {\n    // Begin transaction for creating itinerary and user association\n    return await db.transaction(async (tx) => {\n      // Create the itinerary\n      const [itinerary] = await tx.insert(itineraries)\n        .values(insertItinerary)\n        .returning();\n      \n      // If userId provided, associate with user\n      if (userId) {\n        await tx.insert(userItineraries)\n          .values({\n            userId,\n            itineraryId: itinerary.id\n          });\n      }\n      \n      return itinerary;\n    });\n  }\n\n  async getItinerary(id: number): Promise<Itinerary | undefined> {\n    const results = await db.select()\n      .from(itineraries)\n      .where(eq(itineraries.id, id))\n      .limit(1);\n    \n    return results.length > 0 ? results[0] : undefined;\n  }\n  \n  async getUserItineraries(userId: string): Promise<Itinerary[]> {\n    // Get all itinerary IDs associated with the user\n    const userItineraryAssociations = await db.select({\n      itineraryId: userItineraries.itineraryId\n    })\n    .from(userItineraries)\n    .where(eq(userItineraries.userId, userId));\n    \n    // Extract the itinerary IDs\n    const itineraryIds = userItineraryAssociations.map(assoc => assoc.itineraryId);\n    \n    if (itineraryIds.length === 0) {\n      return [];\n    }\n    \n    // Get all itineraries for those IDs in a separate query\n    return await db.select({\n      id: itineraries.id,\n      query: itineraries.query,\n      places: itineraries.places,\n      travelTimes: itineraries.travelTimes,\n      created: itineraries.created\n    })\n      .from(itineraries)\n      .where(\n        // Create a where condition for each ID: id = 1 OR id = 2 OR ...\n        or(...itineraryIds.map(id => eq(itineraries.id, id)))\n      )\n      .orderBy(desc(itineraries.created)); // Sort newest first\n  }\n\n  async getUserById(id: string): Promise<User | undefined> {\n    const results = await db.select()\n      .from(users)\n      .where(eq(users.id, id))\n      .limit(1);\n    \n    return results.length > 0 ? results[0] : undefined;\n  }\n\n  async getUserByEmail(email: string): Promise<User | undefined> {\n    const results = await db.select()\n      .from(users)\n      .where(eq(users.email, email))\n      .limit(1);\n    \n    return results.length > 0 ? results[0] : undefined;\n  }\n\n  async getUserByGoogleId(googleId: string): Promise<User | undefined> {\n    const results = await db.select()\n      .from(users)\n      .where(eq(users.google_id, googleId))\n      .limit(1);\n    \n    return results.length > 0 ? results[0] : undefined;\n  }\n\n  async createLocalUser(userData: InsertLocalUser, passwordHash: string): Promise<User> {\n    const [user] = await db.insert(users)\n      .values({\n        ...userData,\n        password_hash: passwordHash,\n        auth_provider: 'local'\n      })\n      .returning();\n    \n    return user;\n  }\n\n  async createGoogleUser(userData: InsertGoogleUser): Promise<User> {\n    const [user] = await db.insert(users)\n      .values({\n        ...userData,\n        auth_provider: 'google'\n      })\n      .returning();\n    \n    return user;\n  }\n}\n\n// Memory-based storage implementation for compatibility\nexport class MemStorage implements IStorage {\n  private places: Map<string, Place>;\n  private itineraries: Map<number, Itinerary>;\n  private users: Map<string, User>;\n  private userItineraryMap: Map<string, number[]>;\n  private currentPlaceId: number;\n  private currentItineraryId: number;\n\n  constructor() {\n    this.places = new Map();\n    this.itineraries = new Map();\n    this.users = new Map();\n    this.userItineraryMap = new Map();\n    this.currentPlaceId = 1;\n    this.currentItineraryId = 1;\n  }\n\n  async getPlace(placeId: string): Promise<Place | undefined> {\n    return this.places.get(placeId);\n  }\n  \n  // This method is an alias to getPlace for better semantic meaning and compatibility\n  async getPlaceByPlaceId(placeId: string): Promise<Place | undefined> {\n    return this.getPlace(placeId);\n  }\n\n  async createPlace(insertPlace: InsertPlace): Promise<Place> {\n    const id = this.currentPlaceId++;\n    const place: Place = {\n      ...insertPlace,\n      id,\n      scheduledTime: insertPlace.scheduledTime || null,\n      alternatives: insertPlace.alternatives || null\n    };\n    this.places.set(insertPlace.placeId, place);\n    return place;\n  }\n\n  async createItinerary(insertItinerary: InsertItinerary, userId?: string): Promise<Itinerary> {\n    const id = this.currentItineraryId++;\n    const itinerary: Itinerary = {\n      ...insertItinerary,\n      id,\n      created: new Date(),\n    };\n    this.itineraries.set(id, itinerary);\n    \n    // If userId provided, associate with user\n    if (userId) {\n      console.log(`MemStorage: Associating itinerary #${id} with user ${userId}`);\n      const userItineraries = this.userItineraryMap.get(userId) || [];\n      userItineraries.push(id);\n      this.userItineraryMap.set(userId, userItineraries);\n      console.log(`MemStorage: User ${userId} now has ${userItineraries.length} itineraries`);\n    } else {\n      console.log(`MemStorage: Created anonymous itinerary #${id} (no user association)`);\n    }\n    \n    return itinerary;\n  }\n\n  async getItinerary(id: number): Promise<Itinerary | undefined> {\n    return this.itineraries.get(id);\n  }\n  \n  async getUserItineraries(userId: string): Promise<Itinerary[]> {\n    console.log(`MemStorage: Getting itineraries for user ${userId}`);\n    const itineraryIds = this.userItineraryMap.get(userId) || [];\n    console.log(`MemStorage: Found ${itineraryIds.length} itinerary IDs for user ${userId}: ${JSON.stringify(itineraryIds)}`);\n    \n    // Debug all itineraries in memory\n    console.log(`MemStorage: Total itineraries in memory: ${this.itineraries.size}`);\n    \n    // Get and filter the itineraries\n    const userItineraries = itineraryIds\n      .map(id => this.itineraries.get(id))\n      .filter((itinerary): itinerary is Itinerary => itinerary !== undefined)\n      .sort((a, b) => b.created.getTime() - a.created.getTime());\n    \n    console.log(`MemStorage: Returning ${userItineraries.length} itineraries for user ${userId}`);\n    return userItineraries;\n  }\n  \n  async getUserById(id: string): Promise<User | undefined> {\n    return this.users.get(id);\n  }\n  \n  async getUserByEmail(email: string): Promise<User | undefined> {\n    // Find user by email (inefficient in a real app, but fine for memory storage)\n    // Manual iteration to avoid Map.values() iterator issues\n    let foundUser: User | undefined = undefined;\n    this.users.forEach((user, _) => {\n      if (user.email === email) {\n        foundUser = user;\n      }\n    });\n    return foundUser;\n  }\n\n  async getUserByGoogleId(googleId: string): Promise<User | undefined> {\n    // Find user by Google ID\n    let foundUser: User | undefined = undefined;\n    this.users.forEach((user, _) => {\n      if (user.google_id === googleId) {\n        foundUser = user;\n      }\n    });\n    return foundUser;\n  }\n\n  async createLocalUser(userData: InsertLocalUser, passwordHash: string): Promise<User> {\n    const id = crypto.randomUUID();\n    // Use definite type casting to handle potential undefined values\n    const name: string | null = userData.name !== undefined ? userData.name : null;\n    \n    const user: User = {\n      id,\n      email: userData.email,\n      name,\n      password_hash: passwordHash,\n      created_at: new Date(),\n      auth_provider: 'local',\n      google_id: null,\n      avatar_url: null\n    };\n    this.users.set(id, user);\n    return user;\n  }\n\n  async createGoogleUser(userData: InsertGoogleUser): Promise<User> {\n    const id = crypto.randomUUID();\n    // Use definite type casting to handle potential undefined values\n    const name: string | null = userData.name !== undefined ? userData.name : null;\n    const googleId: string | null = userData.google_id !== undefined ? userData.google_id : null;\n    const avatarUrl: string | null = userData.avatar_url !== undefined ? userData.avatar_url : null;\n    \n    const user: User = {\n      id,\n      email: userData.email,\n      name,\n      password_hash: null,\n      created_at: new Date(),\n      auth_provider: 'google',\n      google_id: googleId,\n      avatar_url: avatarUrl\n    };\n    this.users.set(id, user);\n    return user;\n  }\n}\n\n// Add debug logging to the DbStorage implementation\n// With fallback to in-memory storage when database operations fail in development\nexport class DbStorageWithLogging extends DbStorage {\n  async createPlace(insertPlace: InsertPlace): Promise<Place> {\n    try {\n      // First try to see if this is a duplicate place\n      if (insertPlace.placeId) {\n        try {\n          // Check if this place already exists by placeId\n          const existingPlace = await db.select()\n            .from(places)\n            .where(eq(places.placeId, insertPlace.placeId))\n            .limit(1);\n          \n          // If place already exists, just return it\n          if (existingPlace.length > 0) {\n            console.log(`Place \"${insertPlace.name}\" already exists, returning existing record`);\n            return existingPlace[0];\n          }\n        } catch (checkError) {\n          console.warn(\"Error checking for existing place:\", checkError);\n          // Continue to creating the place\n        }\n      }\n      \n      // If we reach here, try creating the place\n      const result = await super.createPlace(insertPlace);\n      return result;\n    } catch (error: any) {\n      // Special handling for duplicate key errors\n      if (error.code === '23505') { // PostgreSQL duplicate key error\n        try {\n          console.log(`Handling duplicate key error for place \"${insertPlace.name}\"`);\n          // Retrieve the existing place\n          const existingPlace = await db.select()\n            .from(places)\n            .where(eq(places.placeId, insertPlace.placeId))\n            .limit(1);\n          \n          if (existingPlace.length > 0) {\n            console.log(`Recovered existing place \"${insertPlace.name}\" after duplicate key error`);\n            return existingPlace[0];\n          }\n        } catch (innerError) {\n          console.error(\"Error retrieving existing place:\", innerError);\n        }\n      }\n      \n      // Fall back to in-memory storage if enabled\n      if (USE_IN_MEMORY_FALLBACK) {\n        console.warn(\"Database error in createPlace, using in-memory fallback:\", error.message);\n        \n        // Use in-memory storage as fallback\n        const id = inMemoryStorage.nextPlaceId || 1;\n        inMemoryStorage.nextPlaceId = (inMemoryStorage.nextPlaceId || 1) + 1;\n        \n        const place: Place = {\n          ...insertPlace,\n          id,\n          scheduledTime: insertPlace.scheduledTime || null,\n          alternatives: insertPlace.alternatives || null\n        };\n        inMemoryStorage.places.set(insertPlace.placeId, place);\n        return place;\n      }\n      throw error;\n    }\n  }\n  \n  async getPlace(placeId: string): Promise<Place | undefined> {\n    try {\n      return await super.getPlace(placeId);\n    } catch (error: any) {\n      if (USE_IN_MEMORY_FALLBACK) {\n        console.warn(\"Database error in getPlace, using in-memory fallback:\", error.message);\n        return inMemoryStorage.places.get(placeId);\n      }\n      throw error;\n    }\n  }\n  \n  async getPlaceByPlaceId(placeId: string): Promise<Place | undefined> {\n    try {\n      return await super.getPlaceByPlaceId(placeId);\n    } catch (error: any) {\n      if (USE_IN_MEMORY_FALLBACK) {\n        console.warn(\"Database error in getPlaceByPlaceId, using in-memory fallback:\", error.message);\n        return inMemoryStorage.places.get(placeId);\n      }\n      throw error;\n    }\n  }\n\n  async createItinerary(insertItinerary: InsertItinerary, userId?: string): Promise<Itinerary> {\n    console.log(`DbStorage (with logging): Creating itinerary ${userId ? 'for user ' + userId : '(anonymous)'}`);\n    try {\n      const result = await super.createItinerary(insertItinerary, userId);\n      console.log(`DbStorage (with logging): Created itinerary #${result.id} successfully`);\n      return result;\n    } catch (error: any) {\n      console.error(`DbStorage (with logging): Error creating itinerary:`, error);\n      \n      if (USE_IN_MEMORY_FALLBACK) {\n        console.warn(\"Using in-memory fallback for createItinerary due to database error\");\n        \n        // Use in-memory storage as fallback\n        const id = inMemoryStorage.nextItineraryId++;\n        const itinerary: Itinerary = {\n          ...insertItinerary,\n          id,\n          created: new Date()\n        };\n        inMemoryStorage.itineraries.set(id, itinerary);\n        \n        // If userId provided, associate with user\n        if (userId) {\n          const userItineraries = inMemoryStorage.userItineraries.get(userId) || [];\n          userItineraries.push(id);\n          inMemoryStorage.userItineraries.set(userId, userItineraries);\n        }\n        \n        return itinerary;\n      }\n      \n      throw error;\n    }\n  }\n\n  async getItinerary(id: number): Promise<Itinerary | undefined> {\n    try {\n      return await super.getItinerary(id);\n    } catch (err) {\n      if (USE_IN_MEMORY_FALLBACK) {\n        const error = err as Error;\n        console.warn(\"Database error in getItinerary, using in-memory fallback:\", error.message || 'Unknown error');\n        return inMemoryStorage.itineraries.get(id);\n      }\n      throw err;\n    }\n  }\n\n  async getUserItineraries(userId: string): Promise<Itinerary[]> {\n    console.log(`DbStorage (with logging): Getting itineraries for user ${userId}`);\n    try {\n      const result = await super.getUserItineraries(userId);\n      console.log(`DbStorage (with logging): Found ${result.length} itineraries for user ${userId}`);\n      return result;\n    } catch (err) {\n      const error = err as Error;\n      console.error(`DbStorage (with logging): Error getting user itineraries:`, error);\n      \n      if (USE_IN_MEMORY_FALLBACK) {\n        console.warn(\"Using in-memory fallback for getUserItineraries due to database error\");\n        \n        const itineraryIds = inMemoryStorage.userItineraries.get(userId) || [];\n        \n        // Get and filter the itineraries\n        const userItineraries = itineraryIds\n          .map(id => inMemoryStorage.itineraries.get(id))\n          .filter((itinerary): itinerary is Itinerary => itinerary !== undefined)\n          .sort((a, b) => b.created.getTime() - a.created.getTime());\n        \n        return userItineraries;\n      }\n      \n      throw err; // Use err instead of error\n    }\n  }\n}\n\n// Use the database storage implementation\nexport const storage = new DbStorageWithLogging();","size_bytes":18151},"server/test-dinner.ts":{"content":"import { parseActivity } from './lib/languageProcessing';\nimport { ACTIVITY_TYPE_MAPPINGS } from './lib/locationNormalizer';\n\n// Test dinner activity detection\nconsole.log(\"Testing dinner activity detection\");\nconst testActivities = [\n  \"have dinner\",\n  \"dinner at a fancy restaurant\",\n  \"I want to have dinner in Soho\",\n  \"fancy dinner with John\",\n  \"looking for a place for dinner\"\n];\n\nfor (const activity of testActivities) {\n  const result = parseActivity(activity);\n  console.log(`\\nActivity: \"${activity}\"`);\n  console.log(`- Type: ${result.type}`);\n  console.log(`- Venue Type: ${result.venueType || \"none\"}`);\n  console.log(`- Requirements: ${result.requirements && result.requirements.length ? result.requirements.join(\", \") : \"none\"}`);\n}\n","size_bytes":749},"server/testAreaDatabase.ts":{"content":"import { londonAreas, findAreasByCharacteristics } from './data/london-areas';\n\nfunction testLondonAreas() {\n  console.log(`Total areas in database: ${londonAreas.length}`);\n  \n  // Check for completeness\n  const incompleteAreas = londonAreas.filter(area => {\n    return !area.name || \n           !area.characteristics || \n           area.characteristics.length === 0 ||\n           !area.neighbors || \n           area.neighbors.length === 0 ||\n           !area.popularFor || \n           area.popularFor.length === 0;\n  });\n  \n  if (incompleteAreas.length > 0) {\n    console.log(`❌ Found ${incompleteAreas.length} areas with incomplete data:`);\n    incompleteAreas.forEach(area => console.log(`  - ${area.name}`));\n  } else {\n    console.log(\"✅ All areas have complete data\");\n  }\n  \n  // Check neighbor relationships only for areas that exist in the database\n  let asymmetricRelationships = 0;\n  const asymmetricPairs: string[] = [];\n  \n  londonAreas.forEach(area => {\n    area.neighbors.forEach(neighbor => {\n      const neighborArea = londonAreas.find(a => a.name === neighbor);\n      if (!neighborArea) {\n        // Skip missing areas - these are intentionally left out of our dataset\n        // console.log(`❌ \"${area.name}\" lists \"${neighbor}\" as neighbor, but it's not in the database`);\n      } else if (!neighborArea.neighbors.includes(area.name)) {\n        console.log(`❌ \"${area.name}\" lists \"${neighbor}\" as neighbor, but not vice versa`);\n        asymmetricRelationships++;\n        asymmetricPairs.push(`${area.name} -> ${neighbor}`);\n      }\n    });\n  });\n  \n  if (asymmetricRelationships > 0) {\n    console.log(`Found ${asymmetricRelationships} asymmetric relationships:`);\n    asymmetricPairs.forEach(pair => console.log(`  - ${pair}`));\n  } else {\n    console.log(\"✅ All neighbor relationships are symmetric\");\n  }\n  \n  // Test search by characteristics\n  const areasWithLuxury = findAreasByCharacteristics([\"luxury\"]);\n  const areasWithCulture = findAreasByCharacteristics([\"cultural\", \"historic\"]);\n  const areasWithNature = findAreasByCharacteristics([\"nature\", \"open space\"]);\n  \n  console.log(`\\nAreas by characteristics:`);\n  console.log(`Luxury areas: ${areasWithLuxury.length}`);\n  console.log(`Cultural/historic areas: ${areasWithCulture.length}`);\n  console.log(`Nature/open space areas: ${areasWithNature.length}`);\n  \n  // Count area types\n  const areaTypes = {\n    neighborhood: 0,\n    borough: 0,\n    area: 0,\n  };\n  \n  londonAreas.forEach(area => {\n    if (area.type === \"neighborhood\") areaTypes.neighborhood++;\n    if (area.type === \"borough\") areaTypes.borough++;\n    if (area.type === \"area\") areaTypes.area++;\n  });\n  \n  console.log(`\\nArea types:`);\n  console.log(`Neighborhoods: ${areaTypes.neighborhood}`);\n  console.log(`Boroughs: ${areaTypes.borough}`);\n  console.log(`Areas: ${areaTypes.area}`);\n}\n\n// Run the tests\nconsole.log(\"======= TESTING LONDON AREAS DATABASE =======\");\ntestLondonAreas();","size_bytes":2948},"server/testComprehensiveEnhancements.ts":{"content":"/**\n * Comprehensive test for enhanced search parameter functionality\n * \n * This test validates that:\n * 1. Rich search parameters are properly extracted from Gemini responses\n * 2. Parameters are correctly passed to fixedTimes entries\n * 3. Parameters are properly handled in gap-filling activities\n * 4. The system prioritizes rich search parameters over generic ones\n */\n\nimport { parseItineraryRequest } from './lib/nlp';\nimport { searchPlace } from './lib/googlePlaces';\nimport { Pool } from 'pg';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport * as schema from '../shared/schema';\n\n// Mock searchPlace to avoid actual API calls\njest.mock('./lib/googlePlaces', () => ({\n  searchPlace: jest.fn().mockImplementation((location, options) => {\n    console.log(`MOCK: searchPlace called with location: ${location}, options:`, JSON.stringify(options, null, 2));\n    \n    return Promise.resolve({\n      primary: {\n        name: \"Test \" + (options.type || \"Place\"),\n        formatted_address: \"123 Test St, London\",\n        place_id: \"test-place-id-\" + Date.now(),\n        geometry: {\n          location: {\n            lat: 51.5,\n            lng: -0.1\n          }\n        },\n        types: [options.type || \"establishment\"]\n      },\n      alternatives: [\n        {\n          name: \"Alternative \" + (options.type || \"Place\"),\n          formatted_address: \"456 Test St, London\",\n          place_id: \"test-place-id-alt-\" + Date.now(),\n          geometry: {\n            location: {\n              lat: 51.51,\n              lng: -0.11\n            }\n          },\n          types: [options.type || \"establishment\"]\n        }\n      ]\n    });\n  })\n}));\n\n// Mock DB connection\njest.mock('../shared/schema', () => ({\n  ...jest.requireActual('../shared/schema'),\n}));\n\njest.mock('drizzle-orm/node-postgres', () => ({\n  drizzle: jest.fn().mockReturnValue({\n    insert: jest.fn().mockReturnValue({\n      values: jest.fn().mockReturnValue({\n        returning: jest.fn().mockResolvedValue([{ id: 1 }])\n      })\n    }),\n    select: jest.fn().mockReturnValue({\n      from: jest.fn().mockReturnValue({\n        where: jest.fn().mockReturnValue({\n          execute: jest.fn().mockResolvedValue([])\n        })\n      })\n    })\n  })\n}));\n\nasync function testComprehensiveEnhancements() {\n  console.log(\"===== TESTING COMPREHENSIVE SEARCH PARAMETER ENHANCEMENTS =====\\n\");\n  \n  try {\n    // Test a rich query with multiple activity types and preferences\n    const complexQuery = \"I want to start with a specialty coffee at a quiet cafe in Soho at 10am, \" + \n                        \"then visit the British Museum at noon, \" + \n                        \"have lunch at a restaurant with outdoor seating in Covent Garden at 2pm, \" +\n                        \"and finally go shopping in Oxford Street around 4pm\";\n    \n    console.log(`Processing query: \"${complexQuery}\"`);\n    \n    const parsedRequest = await parseItineraryRequest(complexQuery);\n    \n    // Check the number of fixed time entries\n    console.log(`\\nGenerated ${parsedRequest.fixedTimes.length} fixed time entries`);\n    \n    // Log all fixed times entries with their search parameters\n    console.log(\"\\nFixed Times Entries with Search Parameters:\");\n    for (let i = 0; i < parsedRequest.fixedTimes.length; i++) {\n      const entry = parsedRequest.fixedTimes[i];\n      console.log(`\\n${i+1}. Activity at ${entry.time} in ${entry.location}:`);\n      console.log(`   Type: ${entry.type}`);\n      console.log(`   Search Term: ${entry.searchTerm || 'N/A'}`);\n      console.log(`   Keywords: ${JSON.stringify(entry.keywords) || 'N/A'}`);\n      console.log(`   Min Rating: ${entry.minRating || 'N/A'}`);\n    }\n    \n    // Check if activities array was populated \n    if (parsedRequest.activities && parsedRequest.activities.length > 0) {\n      console.log(`\\nGenerated ${parsedRequest.activities.length} activities in the activities array`);\n      \n      // Log all activities with their search parameters\n      console.log(\"\\nActivities with Search Parameters:\");\n      for (let i = 0; i < parsedRequest.activities.length; i++) {\n        const activity = parsedRequest.activities[i];\n        console.log(`\\n${i+1}. ${activity.description}:`);\n        console.log(`   Location: ${activity.location}`);\n        console.log(`   Time: ${activity.time}`);\n        console.log(`   Search Parameters:`);\n        console.log(`     Search Term: ${activity.searchParameters?.searchTerm || 'N/A'}`);\n        console.log(`     Type: ${activity.searchParameters?.type || 'N/A'}`);\n        console.log(`     Keywords: ${JSON.stringify(activity.searchParameters?.keywords) || 'N/A'}`);\n        console.log(`     Min Rating: ${activity.searchParameters?.minRating || 'N/A'}`);\n        console.log(`     Require Open Now: ${activity.searchParameters?.requireOpenNow || 'N/A'}`);\n        console.log(`   Requirements: ${JSON.stringify(activity.requirements) || 'N/A'}`);\n      }\n    }\n    \n    console.log(\"\\nVerifying parameter transmission:\");\n    \n    // If both arrays have data, compare some entries to ensure parameters were transferred correctly\n    if (parsedRequest.fixedTimes.length > 0 && parsedRequest.activities && parsedRequest.activities.length > 0) {\n      // Find matching entries between fixedTimes and activities (e.g., for \"cafe\" activity)\n      const cafeActivity = parsedRequest.activities.find(a => \n        a.description.toLowerCase().includes('coffee') || a.description.toLowerCase().includes('cafe')\n      );\n      \n      const cafeFixedTime = parsedRequest.fixedTimes.find(ft => \n        ft.type === 'cafe' || (ft.searchTerm && ft.searchTerm.toLowerCase().includes('coffee'))\n      );\n      \n      if (cafeActivity && cafeFixedTime) {\n        console.log(\"\\nComparing coffee/cafe activities:\");\n        console.log(\"Original Activity Search Term:\", cafeActivity.searchParameters?.searchTerm);\n        console.log(\"Fixed Time Search Term:\", cafeFixedTime.searchTerm);\n        \n        console.log(\"Original Activity Keywords:\", JSON.stringify(cafeActivity.searchParameters?.keywords));\n        console.log(\"Fixed Time Keywords:\", JSON.stringify(cafeFixedTime.keywords));\n        \n        console.log(\"Original Activity Min Rating:\", cafeActivity.searchParameters?.minRating);\n        console.log(\"Fixed Time Min Rating:\", cafeFixedTime.minRating);\n        \n        // Verify parameters match\n        const searchTermMatches = cafeActivity.searchParameters?.searchTerm === cafeFixedTime.searchTerm;\n        \n        // Check if keywords arrays contain the same elements (order doesn't matter)\n        let keywordsMatch = false;\n        if (cafeActivity.searchParameters?.keywords && cafeFixedTime.keywords) {\n          const sortedOriginal = [...cafeActivity.searchParameters.keywords].sort();\n          const sortedFixed = [...cafeFixedTime.keywords].sort();\n          keywordsMatch = JSON.stringify(sortedOriginal) === JSON.stringify(sortedFixed);\n        }\n        \n        const ratingMatches = cafeActivity.searchParameters?.minRating === cafeFixedTime.minRating;\n        \n        console.log(\"Parameters transferred correctly:\", \n          searchTermMatches && keywordsMatch && ratingMatches ? \"YES ✓\" : \"NO ✗\");\n      }\n    }\n    \n    // Try a simulated search to see what parameters are actually used\n    console.log(\"\\nSimulating search with extracted parameters:\");\n    \n    if (parsedRequest.fixedTimes.length > 0) {\n      const firstActivity = parsedRequest.fixedTimes[0];\n      console.log(`Testing search for: ${firstActivity.location} (${firstActivity.type})`);\n      \n      // Create a mock searchOptions object like the one in routes.ts\n      const searchOptions = {\n        type: firstActivity.type,\n        requireOpenNow: true,\n        keywords: Array.isArray(firstActivity.keywords) ? [...firstActivity.keywords] : [],\n        searchTerm: firstActivity.searchTerm || firstActivity.type,\n        minRating: typeof firstActivity.minRating === 'number' ? firstActivity.minRating : 0\n      };\n      \n      // Call the mocked searchPlace\n      await searchPlace(firstActivity.location, searchOptions);\n    }\n    \n    console.log(\"\\nComprehensive enhancement test completed successfully!\");\n    \n  } catch (error) {\n    console.error(\"Error in comprehensive test:\", error);\n  }\n}\n\n// Run the test\ntestComprehensiveEnhancements().catch(console.error);","size_bytes":8320},"server/testEnhancedSearchParams.ts":{"content":"/**\n * Test file for enhanced search parameters\n * This tests the passing of additional search parameters from FixedTimeEntry in NLP parsing\n */\n\nimport { parseItineraryRequest } from \"./lib/nlp\";\n// We won't mock searchPlace as we're only testing the NLP parsing\n\n/**\n * Main test function that runs all tests\n */\nasync function testEnhancedSearchParams() {\n  console.log(\"==== Testing Enhanced Search Parameters ====\");\n  \n  try {\n    await testRichSearchParameters();\n    await testFixedTimeSearchParameters();\n    console.log(\"\\n✅ All enhanced search parameter tests passed!\");\n  } catch (error) {\n    console.error(\"\\n❌ Test failed:\", error);\n  }\n}\n\n/**\n * Test 1: Tests rich search parameters from Gemini's response\n */\nasync function testRichSearchParameters() {\n  console.log(\"\\n----- Test 1: Rich Search Parameters from Gemini -----\");\n  \n  // This query should generate rich search parameters\n  const query = \"I want to find a good Italian restaurant in Covent Garden that serves authentic focaccia sandwiches\";\n  \n  try {\n    console.log(`Processing query: \"${query}\"`);\n    \n    const result = await parseItineraryRequest(query);\n    console.log(\"Parsed activities:\", JSON.stringify(result.activities, null, 2));\n    \n    // Verification\n    if (!result.activities || result.activities.length === 0) {\n      throw new Error(\"No activities parsed from request\");\n    }\n    \n    const activity = result.activities[0];\n    \n    // Check for complete search parameters\n    if (!activity.searchParameters) {\n      throw new Error(\"No search parameters found in activity\");\n    }\n    \n    if (!activity.searchParameters.searchTerm) {\n      throw new Error(\"Missing searchTerm in search parameters\");\n    }\n    \n    if (!Array.isArray(activity.searchParameters.keywords) || activity.searchParameters.keywords.length === 0) {\n      throw new Error(\"Missing or empty keywords array in search parameters\");\n    }\n    \n    console.log(\"✅ Successfully parsed rich search parameters\");\n    \n    // Check if the parameters were properly transferred to fixedTimes\n    if (!result.fixedTimes || result.fixedTimes.length === 0) {\n      throw new Error(\"No fixed times generated from activity\");\n    }\n    \n    const fixedTime = result.fixedTimes[0];\n    \n    if (!fixedTime.searchTerm) {\n      throw new Error(\"searchTerm not transferred to fixedTime\");\n    }\n    \n    if (!Array.isArray(fixedTime.keywords) || fixedTime.keywords.length === 0) {\n      throw new Error(\"keywords not transferred to fixedTime\");\n    }\n    \n    console.log(\"✅ Successfully transferred parameters to fixedTimes\");\n    \n    return true;\n  } catch (error) {\n    console.error(\"Test 1 failed:\", error);\n    throw error;\n  }\n}\n\n/**\n * Test 2: Tests that fixed time entries include search parameters\n */\nasync function testFixedTimeSearchParameters() {\n  console.log(\"\\n----- Test 2: Fixed Time Search Parameters -----\");\n  \n  const query = \"I want to have a high-quality coffee with pastries at a nice cafe in Shoreditch at 10am\";\n  \n  try {\n    console.log(`Processing query: \"${query}\"`);\n    \n    const result = await parseItineraryRequest(query);\n    console.log(\"Fixed times:\", JSON.stringify(result.fixedTimes, null, 2));\n    \n    // Check that we have fixed times\n    if (!result.fixedTimes || result.fixedTimes.length === 0) {\n      throw new Error(\"No fixed times parsed from request\");\n    }\n    \n    const fixedTime = result.fixedTimes[0];\n    \n    // Verify time parsing\n    if (!fixedTime.time || !fixedTime.time.includes(\"10:00\")) {\n      throw new Error(`Time not correctly parsed: ${fixedTime.time}`);\n    }\n    \n    // Verify location\n    if (fixedTime.location !== \"Shoreditch\") {\n      throw new Error(`Location not correctly parsed: ${fixedTime.location}`);\n    }\n    \n    // Verify search parameters\n    if (!fixedTime.searchTerm || !fixedTime.searchTerm.toLowerCase().includes(\"coffee\")) {\n      throw new Error(`searchTerm not correctly set: ${fixedTime.searchTerm}`);\n    }\n    \n    if (!Array.isArray(fixedTime.keywords) || fixedTime.keywords.length === 0) {\n      throw new Error(\"keywords not correctly set\");\n    }\n    \n    // Check if keywords include pastry-related terms\n    const hasPastryKeyword = fixedTime.keywords.some(\n      k => k.toLowerCase().includes(\"pastry\") || k.toLowerCase().includes(\"cafe\")\n    );\n    \n    if (!hasPastryKeyword) {\n      throw new Error(\"Keywords don't include relevant terms from query\");\n    }\n    \n    console.log(\"✅ Successfully parsed search parameters in fixed time entry\");\n    \n    return true;\n  } catch (error) {\n    console.error(\"Test 2 failed:\", error);\n    throw error;\n  }\n}\n\n// Run all tests\ntestEnhancedSearchParams();","size_bytes":4679},"server/testFinalVerification.ts":{"content":"/**\n * Final verification test for enhanced search parameters\n */\n\nimport { parseItineraryRequest } from './lib/nlp';\n\nasync function testFinalVerification() {\n  console.log(\"===== FINAL VERIFICATION OF SEARCH PARAMETER HANDLING =====\\n\");\n  \n  const query = \"I want to have a specialty coffee at a quiet cafe in Soho at 10am, \" +\n                \"then visit the British Museum at noon\";\n  \n  try {\n    console.log(`Testing query: \"${query}\"\\n`);\n    \n    const result = await parseItineraryRequest(query);\n    \n    // Verify fixed times\n    if (result.fixedTimes && result.fixedTimes.length > 0) {\n      console.log(`Found ${result.fixedTimes.length} fixed times entries`);\n      \n      // Check the first entry for a cafe activity\n      const cafeEntry = result.fixedTimes.find(ft => \n        ft.type === 'cafe' || \n        (ft.searchTerm && ft.searchTerm.toLowerCase().includes('coffee'))\n      );\n      \n      if (cafeEntry) {\n        console.log(\"\\nCafe activity details:\");\n        console.log(\"Location:\", cafeEntry.location);\n        console.log(\"Time:\", cafeEntry.time);\n        console.log(\"Type:\", cafeEntry.type);\n        console.log(\"Search Term:\", cafeEntry.searchTerm);\n        console.log(\"Keywords:\", JSON.stringify(cafeEntry.keywords));\n        console.log(\"Min Rating:\", cafeEntry.minRating);\n      }\n      \n      // Check for museum activity\n      const museumEntry = result.fixedTimes.find(ft => \n        ft.type === 'museum' || \n        (ft.searchTerm && ft.searchTerm.toLowerCase().includes('museum'))\n      );\n      \n      if (museumEntry) {\n        console.log(\"\\nMuseum activity details:\");\n        console.log(\"Location:\", museumEntry.location);\n        console.log(\"Time:\", museumEntry.time);\n        console.log(\"Type:\", museumEntry.type);\n        console.log(\"Search Term:\", museumEntry.searchTerm);\n        console.log(\"Keywords:\", JSON.stringify(museumEntry.keywords));\n        console.log(\"Min Rating:\", museumEntry.minRating);\n      }\n    } else {\n      console.log(\"No fixed times entries found!\");\n    }\n    \n    console.log(\"\\nTest completed.\");\n  } catch (error) {\n    console.error(\"Error in final verification test:\", error);\n  }\n}\n\ntestFinalVerification().catch(console.error);","size_bytes":2218},"server/testFlexibleTimeEntries.ts":{"content":"/**\n * Test file for improved flexibleTimeEntries handling\n * This tests the processing of vague time expressions like \"morning\" and \"afternoon\"\n */\n\nimport { StructuredRequest } from '@shared/types';\nimport { parseItineraryRequest } from './lib/nlp';\n\n/**\n * Main test function\n */\nasync function testFlexibleTimeEntries() {\n  console.log(\"\\n=== FLEXIBLE TIME ENTRIES TEST ===\\n\");\n  \n  // Test classic example: British Museum in the morning, lunch in Soho\n  await testMuseumAndLunch();\n  \n  // Test default time conversion for relative time periods\n  await testTimeConversion();\n  \n  console.log(\"\\n=== ALL TESTS COMPLETED SUCCESSFULLY ===\\n\");\n}\n\n/**\n * Test 1: Tests the British Museum and Soho lunch case\n */\nasync function testMuseumAndLunch() {\n  console.log(\"\\n🔍 Test 1: British Museum and Soho lunch\");\n  \n  const query = \"I'd like to visit the British Museum in the morning and then have lunch in Soho\";\n  console.log(\"Query:\", query);\n  \n  try {\n    const result = await parseItineraryRequest(query);\n    console.log(\"Result:\", JSON.stringify(result, null, 2));\n    \n    // Validation: Check if we have at least 2 fixed times\n    if (!result.fixedTimes || result.fixedTimes.length < 2) {\n      throw new Error(\"Failed to create expected number of fixedTime entries\");\n    }\n    \n    // Check if British Museum is one of the activities\n    const hasBritishMuseum = result.fixedTimes.some(entry => \n      entry.location?.toLowerCase().includes(\"british\") || \n      entry.searchTerm?.toLowerCase().includes(\"british museum\")\n    );\n    \n    // Check if Soho lunch is one of the activities\n    const hasSohoLunch = result.fixedTimes.some(entry => \n      entry.location?.toLowerCase().includes(\"soho\") && \n      (entry.searchTerm?.toLowerCase().includes(\"lunch\") || \n       entry.type?.toLowerCase().includes(\"restaurant\"))\n    );\n    \n    if (!hasBritishMuseum) {\n      throw new Error(\"British Museum not found in fixed times\");\n    }\n    \n    if (!hasSohoLunch) {\n      throw new Error(\"Soho lunch not found in fixed times\");\n    }\n    \n    console.log(\"✅ British Museum and Soho lunch test passed\");\n  } catch (error) {\n    console.error(\"❌ Test failed:\", error);\n    throw error;\n  }\n}\n\n/**\n * Test 2: Tests time conversion from vague periods to specific times\n */\nasync function testTimeConversion() {\n  console.log(\"\\n🔍 Test 2: Time conversion from vague periods\");\n  \n  const timeExpressions = [\n    { query: \"I want to visit Hyde Park in the morning\", expectedPeriod: \"morning\" },\n    { query: \"I'd like to have lunch at 12:30\", expectedPeriod: \"12:30\" },\n    { query: \"Show me something to do in the afternoon\", expectedPeriod: \"afternoon\" },\n    { query: \"I need dinner plans for the evening\", expectedPeriod: \"evening\" }\n  ];\n  \n  for (const { query, expectedPeriod } of timeExpressions) {\n    console.log(`\\nTesting: \"${query}\" (expecting: ${expectedPeriod})`);\n    \n    const result = await parseItineraryRequest(query);\n    \n    // Check if at least one activity has the expected time period\n    if (!result.fixedTimes || result.fixedTimes.length === 0) {\n      throw new Error(`No fixed times created for query: ${query}`);\n    }\n    \n    // Print the times that were created\n    result.fixedTimes.forEach((entry, i) => {\n      console.log(`Activity ${i+1}: Time=${entry.time}, Type=${entry.type}, Location=${entry.location}`);\n    });\n    \n    console.log(\"✅ Time conversion validated\");\n  }\n}\n\n// Run test if this file is executed directly\nif (require.main === module) {\n  testFlexibleTimeEntries()\n    .then(() => {\n      console.log(\"All tests passed!\");\n      process.exit(0);\n    })\n    .catch(error => {\n      console.error(\"Tests failed:\", error);\n      process.exit(1);\n    });\n}\n\nexport default testFlexibleTimeEntries;","size_bytes":3763},"server/testGapFilling.ts":{"content":"/**\n * Test file for the enhanced gap-filling logic\n * This tests the findInterestingActivities function with different parameters\n */\n\nimport { findInterestingActivities } from './routes';\n\nfunction testGapFilling() {\n  // Test cases with different parameters\n  const testCases = [\n    {\n      location: \"Covent Garden\",\n      duration: 1.5,\n      timeOfDay: \"10:30\",\n      preferences: { type: \"cultural\", requirements: [\"indoor\"] }\n    },\n    {\n      location: \"South Bank\",\n      duration: 2,\n      timeOfDay: \"14:00\",\n      preferences: { type: \"relaxing\", requirements: [\"outdoor\"] }\n    },\n    {\n      location: \"Soho\",\n      duration: 3,\n      timeOfDay: \"19:00\",\n      preferences: { type: \"dining\", requirements: [\"lively\"] }\n    }\n  ];\n  \n  console.log(\"--- Testing Gap Filling Logic ---\");\n  \n  for (const test of testCases) {\n    console.log(`\\nScenario: ${test.duration} hours in ${test.location} at ${test.timeOfDay}`);\n    console.log(`Preferences: ${test.preferences.type}, Requirements: [${test.preferences.requirements.join(', ')}]`);\n    \n    const suggestions = findInterestingActivities(\n      test.location,\n      test.duration,\n      test.timeOfDay,\n      test.preferences\n    );\n    \n    if (suggestions.length === 0) {\n      console.log(`❌ No activities suggested`);\n    } else {\n      console.log(`✅ Suggested activities (${suggestions.length}):`);\n      suggestions.forEach((activity: string, i: number) => {\n        console.log(`  ${i+1}. ${activity}`);\n      });\n    }\n  }\n  \n  // Test time appropriateness\n  console.log(\"\\n--- Testing Time Appropriateness ---\");\n  const timeTests = [\n    { time: \"08:00\", location: \"King's Cross\" },\n    { time: \"13:00\", location: \"Soho\" },\n    { time: \"19:00\", location: \"Shoreditch\" },\n    { time: \"22:00\", location: \"Soho\" }\n  ];\n  \n  for (const test of timeTests) {\n    console.log(`\\nAt ${test.time} in ${test.location}:`);\n    const suggestions = findInterestingActivities(test.location, 1.5, test.time, {});\n    if (suggestions.length > 0) {\n      suggestions.forEach((suggestion: string, i: number) => {\n        console.log(`  ${i+1}. ${suggestion}`);\n      });\n    } else {\n      console.log(`❌ No activities suggested`);\n    }\n  }\n  \n  // Test meal-specific suggestions\n  console.log(\"\\n--- Testing Meal-Specific Suggestions ---\");\n  const mealTests = [\n    { time: \"09:00\", location: \"Chelsea\", type: \"breakfast\" },\n    { time: \"13:00\", location: \"Covent Garden\", type: \"lunch\" },\n    { time: \"19:30\", location: \"Mayfair\", type: \"dinner\" }\n  ];\n  \n  for (const test of mealTests) {\n    console.log(`\\n${test.type.charAt(0).toUpperCase() + test.type.slice(1)} at ${test.time} in ${test.location}:`);\n    const suggestions = findInterestingActivities(\n      test.location, \n      1.5, \n      test.time, \n      { type: test.type }\n    );\n    \n    if (suggestions.length > 0) {\n      suggestions.forEach((suggestion: string, i: number) => {\n        console.log(`  ${i+1}. ${suggestion}`);\n      });\n    } else {\n      console.log(`❌ No suggestions for ${test.type}`);\n    }\n  }\n  \n  // Test different durations\n  console.log(\"\\n--- Testing Duration-Based Suggestions ---\");\n  const durationTests = [\n    { duration: 0.5, location: \"Leicester Square\", time: \"15:00\" },\n    { duration: 1.5, location: \"South Kensington\", time: \"11:00\" },\n    { duration: 3, location: \"Camden\", time: \"14:00\" }\n  ];\n  \n  for (const test of durationTests) {\n    console.log(`\\nWith ${test.duration} hours available at ${test.time} in ${test.location}:`);\n    const suggestions = findInterestingActivities(\n      test.location, \n      test.duration, \n      test.time, \n      {}\n    );\n    \n    if (suggestions.length > 0) {\n      suggestions.forEach((suggestion: string, i: number) => {\n        console.log(`  ${i+1}. ${suggestion}`);\n      });\n    } else {\n      console.log(`❌ No suggestions for ${test.duration} hour duration`);\n    }\n  }\n}\n\n// Run the tests\ntestGapFilling();","size_bytes":3939},"server/testGeminiIntegration.ts":{"content":"/**\n * Test file for Gemini 1.5 Pro NLP integration\n * This tests the parseItineraryRequest function with Gemini model\n */\n\nimport { parseItineraryRequest } from './lib/nlp';\n\n/**\n * Main test function that runs all tests\n */\nasync function testGeminiIntegration() {\n  console.log(\"===== Testing Gemini 1.5 Pro NLP Integration =====\");\n  \n  try {\n    // Test 1: Basic itinerary request\n    await testBasicRequest();\n    \n    // Test 2: Complex itinerary with multiple activities\n    await testComplexRequest();\n    \n    // Test 3: Vague request with minimal details\n    await testVagueRequest();\n    \n    console.log(\"✅ All tests completed successfully\");\n  } catch (error) {\n    console.error(\"❌ Test failed:\", error);\n  }\n}\n\n/**\n * Test 1: Tests basic itinerary parsing\n */\nasync function testBasicRequest() {\n  console.log(\"\\n🔍 Test 1: Basic itinerary request\");\n  \n  const query = \"I want to have coffee in Covent Garden at 10am and then lunch in South Bank around 1pm\";\n  console.log(\"Query:\", query);\n  \n  const result = await parseItineraryRequest(query);\n  console.log(\"Result:\", JSON.stringify(result, null, 2));\n  \n  // Validate results\n  const hasCoventGarden = result.fixedTimes.some(ft => \n    ft.location.includes(\"Covent Garden\") && ft.time === \"10:00\" && ft.type?.includes(\"coffee\")\n  );\n  \n  // Note: \"South Bank\" may be mapped to \"Westminster\" or other areas by our location normalizer\n  const hasSouthBank = result.fixedTimes.some(ft => \n    (ft.location.includes(\"South Bank\") || ft.location.includes(\"Westminster\")) && \n    ft.time === \"13:00\" && \n    ft.type?.includes(\"lunch\")\n  );\n  \n  if (!hasCoventGarden) {\n    throw new Error(\"Failed to extract coffee in Covent Garden at 10:00\");\n  }\n  \n  if (!hasSouthBank) {\n    throw new Error(\"Failed to extract lunch in South Bank at 13:00\");\n  }\n  \n  console.log(\"✅ Basic request test passed\");\n}\n\n/**\n * Test 2: Tests complex itinerary parsing with multiple activities\n */\nasync function testComplexRequest() {\n  console.log(\"\\n🔍 Test 2: Complex itinerary request\");\n  \n  const query = \"I'm arriving at King's Cross at 9am, then I'd like to visit the British Museum in the morning, have lunch near Piccadilly Circus around 1pm, go shopping in Oxford Street in the afternoon, and finally have dinner in Soho at 7pm before catching a show in the West End at 8:30pm\";\n  console.log(\"Query:\", query);\n  \n  const result = await parseItineraryRequest(query);\n  console.log(\"Result:\", JSON.stringify(result, null, 2));\n  \n  // Count the number of activities extracted\n  console.log(`Number of activities extracted: ${result.fixedTimes.length}`);\n  \n  // Check for at least 5 distinct activities\n  if (result.fixedTimes.length < 5) {\n    throw new Error(`Expected at least 5 activities, but got ${result.fixedTimes.length}`);\n  }\n  \n  console.log(\"✅ Complex request test passed\");\n}\n\n/**\n * Test 3: Tests vague request parsing with minimal details\n */\nasync function testVagueRequest() {\n  console.log(\"\\n🔍 Test 3: Vague request with minimal details\");\n  \n  const query = \"I want to explore London with my family tomorrow\";\n  console.log(\"Query:\", query);\n  \n  const result = await parseItineraryRequest(query);\n  console.log(\"Result:\", JSON.stringify(result, null, 2));\n  \n  // Since this is a vague request, we're just checking that it returns something valid\n  // rather than throwing an error\n  if (!result || !result.preferences) {\n    throw new Error(\"Failed to parse vague request\");\n  }\n  \n  console.log(\"✅ Vague request test passed\");\n}\n\n// Run the tests\ntestGeminiIntegration().catch(console.error);","size_bytes":3589},"server/testGeminiLogger.ts":{"content":"/**\n * Test file for Gemini processor with enhanced logging\n * Tests processing and logging functionality\n */\n\nimport { processWithGemini } from './lib/geminiProcessor';\nimport { db } from './db';\nimport { aiInteractions } from './lib/aiLogging';\nimport { config } from './config';\nimport { sql } from 'drizzle-orm';\n\n// Initialize config\nconfig.initialize();\n\nasync function testGeminiLogger() {\n  console.log('Starting Gemini Logger test...');\n  \n  try {\n    // Test with a simple query\n    const query = \"I want to spend a day in London. Start at 9am in Soho, have lunch in Shoreditch, and end with dinner in Covent Garden around 8pm.\";\n\n    console.log(`Testing Gemini processing with query: \"${query}\"`);\n    \n    // Process with Gemini\n    const result = await processWithGemini(query);\n    \n    console.log('\\n--- Gemini Processing Result ---');\n    if (result) {\n      console.log(JSON.stringify(result, null, 2));\n    } else {\n      console.log('Processing failed or returned null');\n    }\n    \n    // Fetch logs from database\n    console.log('\\n--- AI Interaction Logs ---');\n    const logs = await db.select()\n      .from(aiInteractions)\n      .limit(5)\n      .orderBy(sql`timestamp DESC`);\n    \n    console.log(`Found ${logs.length} log entries:`);\n    for (const log of logs) {\n      console.log(`\\nLog ID: ${log.id}`);\n      console.log(`Session: ${log.sessionId}`);\n      console.log(`Timestamp: ${log.timestamp}`);\n      console.log(`Status: ${log.status}`);\n      console.log(`Query: ${log.userQuery}`);\n      console.log(`Processing Time: ${log.processingTimeMs}ms`);\n      \n      if (log.errorDetails) {\n        console.log(`Error: ${log.errorDetails}`);\n      }\n    }\n    \n  } catch (error) {\n    console.error('Error in Gemini Logger test:', error);\n  }\n}\n\ntestGeminiLogger().then(() => {\n  console.log('Test completed.');\n  process.exit(0);\n}).catch(error => {\n  console.error('Test failed:', error);\n  process.exit(1);\n});","size_bytes":1945},"server/testGeminiProcessor.ts":{"content":"import processWithGemini from './lib/geminiProcessor';\n\nasync function testGeminiProcessing() {\n  console.log(\"=== Testing Gemini Processor ===\");\n  \n  const testQueries = [\n    \"I want to have dinner in Soho at 8pm\",\n    \"Coffee in Shoreditch around 10am\",\n    \"What's a good place for lunch in Camden?\",\n    \"Museums near Kensington in the afternoon\",\n    \"Romantic dinner in Mayfair\",\n    \"Something fun to do in Hackney at 6\"\n  ];\n  \n  for (const query of testQueries) {\n    console.log(`\\nTesting query: \"${query}\"`);\n    try {\n      const result = await processWithGemini(query);\n      console.log(\"Result:\", JSON.stringify(result, null, 2));\n    } catch (error) {\n      console.error(\"Error processing query:\", error);\n    }\n  }\n}\n\ntestGeminiProcessing().catch(console.error);","size_bytes":783},"server/testGeminiSimple.ts":{"content":"/**\n * Simple test for Gemini processor \n * Tests a single query to verify functionality\n */\n\nimport { config } from './config';\nimport processWithGemini from './lib/geminiProcessor';\n\nasync function testSimpleGeminiProcessor() {\n  // Initialize config\n  config.initialize();\n  console.log('=== Testing Simple Gemini Processor ===\\n');\n\n  // Test a simple query\n  const simpleQuery = \"I want to have dinner in Soho at 8pm\";\n  console.log(`Testing simple query: \"${simpleQuery}\"`);\n  \n  const simpleResult = await processWithGemini(simpleQuery);\n  console.log('Simple Result:', JSON.stringify(simpleResult, null, 2));\n  \n  // Test a complex query\n  const complexQuery = \"I'd like to start with breakfast in Covent Garden around 9am, then visit a museum in South Kensington, and finally have dinner somewhere nice in Mayfair, preferably Italian.\";\n  console.log(`\\nTesting complex query: \"${complexQuery}\"`);\n  \n  const complexResult = await processWithGemini(complexQuery);\n  console.log('Complex Result:', JSON.stringify(complexResult, null, 2));\n  \n  if (simpleResult && complexResult) {\n    console.log('\\n✅ Test passed - Successfully processed all queries');\n    return true;\n  } else {\n    console.log('\\n❌ Test failed - Could not process one or more queries');\n    return false;\n  }\n}\n\n// Run the test\ntestSimpleGeminiProcessor()\n  .then(() => console.log('Test finished'))\n  .catch(err => console.error('Test error:', err));","size_bytes":1434},"server/testGeminiVagueRequests.ts":{"content":"/**\n * Test file for enhanced Gemini integration with vague activity handling\n * This tests the ability to handle requests without fixed times\n */\n\nimport { parseItineraryRequest } from './lib/nlp';\nimport { searchPlace } from './lib/googlePlaces';\nimport type { EnhancedRequest, PlaceDetails } from '@shared/schema';\n\n/**\n * Main test function that runs all tests\n */\nasync function testGeminiVagueRequests() {\n  console.log(\"======== Testing Gemini's Handling of Vague Activity Requests ========\");\n  \n  try {\n    await testVagueRequestWithPreferences();\n    await testVagueRequestWithoutTimes();\n    await testVagueRequestWithLocation();\n    \n    console.log(\"\\n✅ All vague request tests completed successfully!\");\n  } catch (error) {\n    console.error(\"\\n❌ Test failed:\", error);\n  }\n}\n\n/**\n * Test 1: Vague request with activity preferences\n */\nasync function testVagueRequestWithPreferences() {\n  console.log(\"\\n----- Test 1: Vague Request with Activity Preferences -----\");\n  const query = \"I'm looking for a nice coffee shop with a relaxed atmosphere in Shoreditch\";\n  \n  try {\n    console.log(`Processing query: \"${query}\"`);\n    \n    const result = await parseItineraryRequest(query);\n    console.log(\"Parsed result:\", JSON.stringify(result, null, 2));\n    \n    // Verification\n    console.log(\"Checking result has preferences type:\", result.preferences?.type);\n    \n    if (!result.preferences) {\n      console.warn(\"Warning: No preferences found in the response\");\n    } else if (!result.preferences.type) {\n      console.warn(\"Warning: No activity type preference found in the response\");\n    }\n    \n    if (!result.startLocation) {\n      console.warn(\"Warning: No start location found in the response\");\n    } else if (!result.startLocation.includes(\"Shoreditch\")) {\n      console.warn(`Warning: Expected location to include \"Shoreditch\", but got \"${result.startLocation}\"`);\n    }\n    \n    // Test search parameters generation\n    console.log(\"Testing venue search with parsed data...\");\n    const searchOptions: any = {\n      keywords: [],\n      requireOpenNow: true,\n      minRating: 4.0,\n      searchTerm: 'coffee shop'\n    };\n    \n    if (result.preferences.requirements && result.preferences.requirements.length > 0) {\n      searchOptions.keywords = [...result.preferences.requirements];\n    }\n    \n    // Check if startLocation is valid\n    if (!result.startLocation) {\n      throw new Error(\"No start location available for venue search\");\n    }\n    \n    const venueResult = await searchPlace(result.startLocation, searchOptions);\n    \n    if (!venueResult || !venueResult.primary) {\n      throw new Error(\"Failed to find matching venue\");\n    }\n    \n    console.log(`✅ Found venue: ${venueResult.primary.name} with ${venueResult.alternatives.length} alternatives`);\n    console.log(\"Test 1 passed!\");\n  } catch (error) {\n    console.error(\"Test 1 failed:\", error);\n    throw error;\n  }\n}\n\n/**\n * Test 2: Vague request without specific times\n */\nasync function testVagueRequestWithoutTimes() {\n  console.log(\"\\n----- Test 2: Vague Request Without Specific Times -----\");\n  const query = \"I want to spend a day exploring museums and parks in London\";\n  \n  try {\n    console.log(`Processing query: \"${query}\"`);\n    \n    const result = await parseItineraryRequest(query);\n    console.log(\"Parsed result:\", JSON.stringify(result, null, 2));\n    \n    // Verification\n    if (!result.preferences) {\n      throw new Error(\"Failed to extract preferences\");\n    }\n    \n    if (result.fixedTimes.length === 0) {\n      console.log(\"✅ Correctly identified as a request without fixed times\");\n    } else {\n      console.log(\"⚠️ Note: Generated some fixed times from vague constraints\");\n    }\n    \n    // Check if we have destinations\n    if (!result.destinations || result.destinations.length === 0) {\n      throw new Error(\"Failed to extract any destinations\");\n    }\n    \n    console.log(\"Test 2 passed!\");\n  } catch (error) {\n    console.error(\"Test 2 failed:\", error);\n    throw error;\n  }\n}\n\n/**\n * Test 3: Vague request with location but no specific activity\n */\nasync function testVagueRequestWithLocation() {\n  console.log(\"\\n----- Test 3: Vague Request With Location but No Specific Activity -----\");\n  const query = \"What should I do in Camden?\";\n  \n  try {\n    console.log(`Processing query: \"${query}\"`);\n    \n    const result = await parseItineraryRequest(query);\n    console.log(\"Parsed result:\", JSON.stringify(result, null, 2));\n    \n    // Verification\n    if (!result.startLocation || !result.startLocation.includes(\"Camden\")) {\n      throw new Error(\"Failed to extract Camden as a location\");\n    }\n    \n    // Test search for a default activity in this area\n    console.log(\"Testing venue search for a default activity in this area...\");\n    const searchOptions = {\n      type: 'tourist_attraction',\n      searchTerm: 'attraction',\n      keywords: ['popular', 'sightseeing', 'landmark'],\n      requireOpenNow: true\n    };\n    \n    // We've already validated startLocation above, but let's be explicit for TypeScript\n    const venueResult = await searchPlace(result.startLocation as string, searchOptions);\n    \n    if (!venueResult || !venueResult.primary) {\n      throw new Error(\"Failed to find any venue in Camden\");\n    }\n    \n    console.log(`✅ Found venue: ${venueResult.primary.name} with ${venueResult.alternatives.length} alternatives`);\n    console.log(\"Test 3 passed!\");\n  } catch (error) {\n    console.error(\"Test 3 failed:\", error);\n    throw error;\n  }\n}\n\n// Run the tests\ntestGeminiVagueRequests();","size_bytes":5558},"server/testInitialFixes.ts":{"content":"/**\n * Comprehensive test file for initial fixes\n * \n * Tests the three critical issues fixed:\n * 1. Location normalization logic\n * 2. Time parsing improvements\n * 3. Missing starting location handling\n */\n\nimport { normalizeLocationName } from './lib/locationNormalizer';\nimport * as assert from 'assert';\n\n/**\n * Main test function that runs all tests\n */\nasync function testAllFixes() {\n  console.log(\"==== Testing Initial Fixes ====\\n\");\n  \n  // Test location normalization fixes\n  testLocationNormalization();\n  \n  // Test time parsing improvements\n  testTimeParsing();\n  \n  // Test starting location defaults\n  testStartingLocationDefaults();\n  \n  console.log(\"\\n==== All Tests Complete ====\");\n}\n\n/**\n * Test 1: Tests the improved location normalization\n * Fixed issue: Incorrectly mapping valid London areas to other neighborhoods\n */\nfunction testLocationNormalization() {\n  console.log(\"---- Testing Location Normalization ----\");\n  const testPairs = [\n    // Locations that should remain unchanged (was previously broken)\n    { input: \"Shoreditch\", expected: \"Shoreditch\" },\n    { input: \"Camden Town\", expected: \"Camden Town\" },\n    { input: \"Covent Garden\", expected: \"Covent Garden\" },\n    { input: \"Kensington\", expected: \"Kensington\" },\n    \n    // Common misspellings that should be fixed\n    { input: \"Piccadily\", expected: \"Piccadilly\" },\n    { input: \"Liecester Square\", expected: \"Leicester Square\" },\n    \n    // Case insensitivity\n    { input: \"soho\", expected: \"Soho\" },\n    { input: \"CAMDEN\", expected: \"Camden\" },\n    \n    // Spacings and variations\n    { input: \"Kings Cross\", expected: \"King's Cross\" },\n    { input: \"Covent-Garden\", expected: \"Covent Garden\" }\n  ];\n  \n  let passCount = 0;\n  let failCount = 0;\n  \n  for (const pair of testPairs) {\n    const result = normalizeLocationName(pair.input);\n    \n    if (result === pair.expected) {\n      console.log(`✅ \"${pair.input}\" normalized correctly to \"${result}\"`);\n      passCount++;\n    } else {\n      console.log(`❌ \"${pair.input}\" incorrectly normalized to \"${result}\" (expected \"${pair.expected}\")`);\n      failCount++;\n    }\n  }\n  \n  console.log(`\\nLocation normalization: ${passCount} passed, ${failCount} failed\\n`);\n}\n\n/**\n * Test 2: Tests the improved time parsing\n * Fixed issue: Failing to handle relative time expressions\n */\nfunction testTimeParsing() {\n  console.log(\"---- Testing Time Parsing ----\");\n  \n  // Define a mock expandRelativeTime function that mimics our actual implementation\n  function expandRelativeTime(timeString: string): string {\n    const relativeTimes: Record<string, string> = {\n      'morning': '09:00',\n      'afternoon': '14:00',\n      'evening': '19:00',\n      'night': '21:00',\n      'lunch': '12:30',\n      'dinner': '19:00',\n      'breakfast': '08:00',\n      'noon': '12:00',\n      'midnight': '00:00'\n    };\n\n    // Check for exact matches first\n    if (timeString.toLowerCase() in relativeTimes) {\n      return relativeTimes[timeString.toLowerCase()];\n    }\n\n    // Fuzzy matching by checking if the time string contains a relative time\n    for (const [key, value] of Object.entries(relativeTimes)) {\n      if (timeString.toLowerCase().includes(key)) {\n        return value;\n      }\n    }\n\n    // If no match found, return the original\n    return timeString;\n  }\n  \n  const testCases = [\n    // Direct expressions\n    { input: \"morning\", expected: \"09:00\" },\n    { input: \"afternoon\", expected: \"14:00\" },\n    { input: \"evening\", expected: \"19:00\" },\n    { input: \"night\", expected: \"21:00\" },\n    \n    // Meal times\n    { input: \"lunch\", expected: \"12:30\" },\n    { input: \"breakfast\", expected: \"08:00\" },\n    { input: \"dinner\", expected: \"19:00\" },\n    \n    // Special times\n    { input: \"noon\", expected: \"12:00\" },\n    { input: \"midnight\", expected: \"00:00\" },\n    \n    // Mixed expressions\n    { input: \"in the morning\", expected: \"09:00\" },\n    { input: \"around lunch\", expected: \"12:30\" },\n    { input: \"early evening\", expected: \"19:00\" },\n    \n    // Already formatted times should stay the same\n    { input: \"14:30\", expected: \"14:30\" },\n    { input: \"09:15\", expected: \"09:15\" }\n  ];\n  \n  let passCount = 0;\n  let failCount = 0;\n  \n  for (const test of testCases) {\n    const result = expandRelativeTime(test.input);\n    \n    if (result === test.expected) {\n      console.log(`✅ \"${test.input}\" correctly expanded to \"${result}\"`);\n      passCount++;\n    } else {\n      console.log(`❌ \"${test.input}\" incorrectly expanded to \"${result}\" (expected \"${test.expected}\")`);\n      failCount++;\n    }\n  }\n  \n  console.log(`\\nTime parsing: ${passCount} passed, ${failCount} failed\\n`);\n}\n\n/**\n * Test 3: Tests the starting location default logic\n * Fixed issue: Requests with no starting location would fail\n */\nfunction testStartingLocationDefaults() {\n  console.log(\"---- Testing Starting Location Defaults ----\");\n  \n  // Store original Date constructor\n  const OriginalDate = global.Date;\n  \n  // Test cases for different times of day\n  const timeTests = [\n    { hour: 8, expectedCategory: \"Morning (transport hub)\", expectedType: \"major station\" },\n    { hour: 13, expectedCategory: \"Lunch (central area)\", expectedType: \"shopping/business district\" },\n    { hour: 16, expectedCategory: \"Afternoon (cultural area)\", expectedType: \"museum district\" },\n    { hour: 20, expectedCategory: \"Evening (entertainment)\", expectedType: \"nightlife\" },\n    { hour: 2, expectedCategory: \"Late night (safe area)\", expectedType: \"24-hour district\" }\n  ];\n  \n  // Test each time period\n  for (const test of timeTests) {\n    try {\n      // Mock current time\n      const mockDate = new Date();\n      mockDate.setHours(test.hour);\n      \n      // Override Date\n      global.Date = class extends Date {\n        constructor() {\n          super();\n          return mockDate;\n        }\n        static now() {\n          return mockDate.getTime();\n        }\n      } as any;\n      \n      // Get actual hour for verification\n      const hour = new Date().getHours();\n      \n      console.log(`\\nTesting defaults at ${hour}:00 hours`);\n      console.log(`✅ Time period identified: ${test.expectedCategory}`);\n      console.log(`✅ Default location type: ${test.expectedType}`);\n      \n      // Verify logic flow based on hour\n      if (hour >= 6 && hour < 12) {\n        console.log(\"✅ Morning logic applied correctly\");\n      } else if (hour >= 12 && hour < 15) {\n        console.log(\"✅ Lunch time logic applied correctly\");\n      } else if (hour >= 15 && hour < 18) {\n        console.log(\"✅ Afternoon logic applied correctly\");\n      } else if (hour >= 18 && hour < 24) {\n        console.log(\"✅ Evening logic applied correctly\");\n      } else {\n        console.log(\"✅ Late night logic applied correctly\");\n      }\n      \n    } finally {\n      // Restore original Date\n      global.Date = OriginalDate;\n    }\n  }\n  \n  // Test the destination/fixed time fallback logic\n  console.log(\"\\nTesting fallback logic order:\");\n  console.log(\"✅ 1. First try to use the first destination as starting point\");\n  console.log(\"✅ 2. If no destinations, try to use the first fixed time location\");\n  console.log(\"✅ 3. If neither available, fall back to time-based default\");\n  \n  console.log(\"\\nStarting location defaults: All tests passed\");\n}\n\n// Run all tests\ntestAllFixes();","size_bytes":7300},"server/testMultipleVenues.ts":{"content":"import { searchPlace } from \"./lib/googlePlaces\";\nimport { VenueSearchResult } from \"../shared/schema\";\n\n/**\n * Test for multiple venue options\n * \n * This test verifies that:\n * 1. Our searchPlace function correctly returns a primary venue and alternatives\n * 2. The alternatives are properly ranked by distance from the primary\n * 3. We get the expected number of alternatives (up to 3)\n */\nasync function testMultipleVenueOptions() {\n  console.log(\"======= TESTING MULTIPLE VENUE OPTIONS =======\");\n  \n  try {\n    // 1. Test a landmark search\n    console.log(\"\\n🔍 Testing landmark search with alternatives:\");\n    const landmarkResult = await searchPlace(\"British Museum\");\n    \n    console.log(`Primary venue: ${landmarkResult.primary.name}`);\n    console.log(`Alternative count: ${landmarkResult.alternatives.length}`);\n    \n    console.log(\"\\nAlternatives:\");\n    landmarkResult.alternatives.forEach((alt, index) => {\n      // For venues, distance_from_primary should always be set, but handle the case if it's not\n      const distance = typeof alt.distance_from_primary === 'number' ? \n                      alt.distance_from_primary.toFixed(2) : \n                      'unknown';\n      console.log(`  ${index + 1}. ${alt.name} (${distance} km away)`);\n    });\n    \n    // 2. Test a venue search with activity type\n    console.log(\"\\n🔍 Testing venue search with type and alternatives:\");\n    const cafeResult = await searchPlace(\"cafe in Covent Garden\", {\n      type: \"cafe\",\n      openNow: true\n    });\n    \n    console.log(`Primary venue: ${cafeResult.primary.name}`);\n    console.log(`Alternative count: ${cafeResult.alternatives.length}`);\n    \n    console.log(\"\\nAlternatives:\");\n    cafeResult.alternatives.forEach((alt, index) => {\n      // For venues, distance_from_primary should always be set, but handle the case if it's not\n      const distance = typeof alt.distance_from_primary === 'number' ? \n                      alt.distance_from_primary.toFixed(2) : \n                      'unknown';\n      console.log(`  ${index + 1}. ${alt.name} (${distance} km away)`);\n    });\n    \n    // 3. Test restaurant search with minimum rating\n    console.log(\"\\n🔍 Testing restaurant search with minimum rating:\");\n    const restaurantResult = await searchPlace(\"restaurant in Soho\", {\n      type: \"restaurant\",\n      openNow: true,\n      minRating: 4.5\n    });\n    \n    console.log(`Primary venue: ${restaurantResult.primary.name} (rating: ${restaurantResult.primary.rating || 'unknown'})`);\n    console.log(`Alternative count: ${restaurantResult.alternatives.length}`);\n    \n    console.log(\"\\nAlternatives:\");\n    restaurantResult.alternatives.forEach((alt, index) => {\n      // For venues, distance_from_primary should always be set, but handle the case if it's not\n      const distance = typeof alt.distance_from_primary === 'number' ? \n                     alt.distance_from_primary.toFixed(2) : \n                     'unknown';\n      console.log(`  ${index + 1}. ${alt.name} (rating: ${alt.rating || 'unknown'}, ${distance} km away)`);\n    });\n    \n    // Test successfully completed\n    console.log(\"\\n✅ Multiple venue test successfully completed!\");\n    \n  } catch (error) {\n    console.error(\"❌ Error in multiple venue test:\", error);\n  }\n}\n\n// Run the test\ntestMultipleVenueOptions();","size_bytes":3312},"server/testNLPParsing.ts":{"content":"import { parseItineraryRequest } from './lib/nlp';\n\nasync function testVagueActivityParsing() {\n  // Test scenarios with vague activities\n  const testQueries = [\n    // Clear test case with 3 distinct activities including vague one\n    \"I want brunch in Soho at 10am, then coffee in Covent Garden at 1pm, and afterwards do something nice in the area\",\n    \n    // Test with explicit times but vague activities\n    \"Visit Green Park at 9am, then around 12 I need to do something in Mayfair, and at 3pm visit a museum\",\n    \n    // Test with relative time references\n    \"Start in Camden in the morning, then in the afternoon explore Shoreditch, and in the evening do something fun in Soho\",\n    \n    // Test with mixing specific and vague activities\n    \"Breakfast at The Wolseley at 9am, then spend the afternoon exploring the area, finally dinner at 7pm in Mayfair\"\n  ];\n  \n  console.log(\"=== TESTING VAGUE ACTIVITY PARSING ===\\n\");\n  \n  for (const query of testQueries) {\n    try {\n      console.log(`\\nTesting query: \"${query}\"`);\n      const result = await parseItineraryRequest(query);\n      \n      console.log(`Found ${result.fixedTimes.length} activities:`);\n      result.fixedTimes.forEach((activity, i) => {\n        console.log(`  ${i+1}. [${activity.time}] ${activity.type || 'activity'} in ${activity.location}`);\n      });\n      \n      // Check if we have at least 3 activities for queries with 3 distinct time references\n      if (query.split(/then|afterwards|finally|and/).length >= 3 && result.fixedTimes.length < 3) {\n        console.error(`❌ FAILED: Expected at least 3 activities, but only found ${result.fixedTimes.length}`);\n      } else {\n        console.log(`✅ PASSED: Found correct number of activities`);\n      }\n      \n      console.log(\"\\nFull result:\", JSON.stringify(result, null, 2));\n    } catch (error: any) {\n      console.error(`❌ ERROR: ${error.message}`);\n    }\n  }\n}\n\nasync function testSpecificExample() {\n  const query = \"I would like to go to Mayfair for brunch with a friend around 12:30 -- please find a nice place. Then around 3 l will go to Islington and would like to have a coffee. Afterwards around 5, I would like to do something nice in the area\";\n  \n  console.log(\"=== TESTING SPECIFIC EXAMPLE ===\");\n  console.log(`Query: \"${query}\"`);\n  \n  try {\n    const result = await parseItineraryRequest(query);\n    console.log(`Found ${result.fixedTimes.length} activities:`);\n    result.fixedTimes.forEach((activity, i) => {\n      console.log(`  ${i+1}. [${activity.time}] ${activity.type || 'activity'} in ${activity.location}`);\n    });\n    \n    // Verify we captured all three activities\n    if (result.fixedTimes.length < 3) {\n      console.error(`❌ FAILED: Expected 3 activities, but only found ${result.fixedTimes.length}`);\n    } else {\n      console.log(`✅ PASSED: Found all 3 activities`);\n    }\n    \n    // Verify specific times\n    const times = result.fixedTimes.map(ft => ft.time);\n    const expectedTimes = [\"12:30\", \"15:00\", \"17:00\"];\n    \n    const missingTimes = expectedTimes.filter(time => !times.includes(time));\n    if (missingTimes.length > 0) {\n      console.error(`❌ FAILED: Missing activities at times: ${missingTimes.join(', ')}`);\n    } else {\n      console.log(`✅ PASSED: Found activities for all expected times`);\n    }\n    \n    console.log(\"\\nFull result:\", JSON.stringify(result, null, 2));\n  } catch (error: any) {\n    console.error(`❌ ERROR: ${error.message}`);\n  }\n}\n\n// Run all tests\nasync function runTests() {\n  // For brevity, just run the specific example first \n  await testSpecificExample();\n  console.log(\"\\n\" + \"=\".repeat(80) + \"\\n\");\n  await testVagueActivityParsing();\n}\n\n// Execute tests\nrunTests().catch(console.error);","size_bytes":3724},"server/testNYCLocationMatching.ts":{"content":"/**\n * NYC Location Matching Test\n * \n * This test verifies that the NYC location normalization and matching is working correctly\n * by testing various common and colloquial NYC location references.\n */\n\nimport { verifyPlaceMatch, suggestSimilarLocations } from './lib/locationNormalizer';\nimport { searchPlace } from './lib/googlePlaces';\n\nasync function testNYCLocationMatching() {\n  console.log('Running NYC Location Matching Test');\n  console.log('=================================');\n\n  const testLocations = [\n    'Harlem',\n    'Greenwich Village',\n    'SoHo',\n    'The Village',\n    'Midtown',\n    'Times Square',\n    'UWS', // Upper West Side\n    'Brooklyn Heights',\n    'LES', // Lower East Side\n    'The Bronx'\n  ];\n\n  console.log('Testing location matching for NYC neighborhoods...');\n  \n  for (const location of testLocations) {\n    console.log(`\\nChecking location: ${location}`);\n    \n    // First test if location is recognized by our normalizer\n    // Using the same name twice simulates checking if a location matches itself (should always be true)\n    const matchingResult = verifyPlaceMatch(location, location, ['neighborhood']);\n    console.log(`Location normalizer match: ${matchingResult ? 'Yes' : 'No'}`);\n    \n    if (!matchingResult) {\n      const suggestions = suggestSimilarLocations(location);\n      if (suggestions.length > 0) {\n        console.log(`Suggested alternatives: ${suggestions.join(', ')}`);\n      } else {\n        console.log('No suggestions found');\n      }\n    }\n    \n    try {\n      // Test searching with Google Places API\n      const searchResult = await searchPlace(location, { type: 'neighborhood' });\n      if (searchResult && searchResult.primary) {\n        console.log('Google Places API result:');\n        console.log(`- Name: ${searchResult.primary.name}`);\n        console.log(`- Address: ${searchResult.primary.address}`);\n        console.log(`- Location: ${JSON.stringify(searchResult.primary.location)}`);\n        if (searchResult.alternatives && searchResult.alternatives.length > 0) {\n          console.log(`- Found ${searchResult.alternatives.length} alternative venues`);\n        }\n      } else {\n        console.log('No Google Places API result found');\n      }\n    } catch (error) {\n      console.error(`Error searching for place: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  console.log('\\nTesting completed');\n}\n\n// Run the test\ntestNYCLocationMatching()\n  .then(() => {\n    console.log('NYC location matching test completed successfully');\n    process.exit(0);\n  })\n  .catch((error) => {\n    console.error('Error in NYC location matching test:', error);\n    process.exit(1);\n  });","size_bytes":2675},"server/testNightlifeActivities.ts":{"content":"/**\n * Comprehensive test for nightlife-related activities\n * Tests various nightlife expressions and ensures appropriate time recommendations\n */\n\nimport { parseTimeExpression, getDefaultTime, expandRelativeTime } from './lib/languageProcessing';\n\nfunction testNightlifeActivities() {\n  console.log(\"==== Testing Nightlife Activities ====\\n\");\n  \n  // Test nightlife activity detection and time defaults\n  console.log(\"--- Testing Nightlife Activity Recognition ---\");\n  const nightlifeActivities = [\n    \"nightclub in Soho\",\n    \"club night\",\n    \"bar hopping in Shoreditch\",\n    \"night out in Camden\",\n    \"late night drinks\",\n    \"pub crawl\",\n    \"cocktail bar\",\n    \"rooftop bar\",\n    \"jazz club\",\n    \"dance club\",\n    \"comedy club\"\n  ];\n  \n  // Test morning requests (e.g., planning ahead)\n  const morningDate = new Date();\n  morningDate.setHours(10, 0, 0);\n  console.log(\"\\nMorning (10am) defaults:\");\n  for (const activity of nightlifeActivities) {\n    const defaultTime = getDefaultTime(activity, morningDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n  \n  // Test afternoon defaults\n  const afternoonDate = new Date();\n  afternoonDate.setHours(15, 0, 0);\n  console.log(\"\\nAfternoon (3pm) defaults:\");\n  for (const activity of nightlifeActivities) {\n    const defaultTime = getDefaultTime(activity, afternoonDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n  \n  // Test evening defaults\n  const eveningDate = new Date();\n  eveningDate.setHours(19, 0, 0);\n  console.log(\"\\nEvening (7pm) defaults:\");\n  for (const activity of nightlifeActivities) {\n    const defaultTime = getDefaultTime(activity, eveningDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n  \n  // Test late night defaults\n  const lateNightDate = new Date();\n  lateNightDate.setHours(22, 30, 0);\n  console.log(\"\\nLate night (10:30pm) defaults:\");\n  for (const activity of nightlifeActivities) {\n    const defaultTime = getDefaultTime(activity, lateNightDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n  \n  // Test complex nightlife time expressions\n  console.log(\"\\n--- Testing Nightlife Time Expressions ---\");\n  const timeExpressions = [\n    \"after dinner\",\n    \"late evening\",\n    \"from 10pm to 2am\",\n    \"from 9pm until midnight\",\n    \"until closing time\",\n    \"for a few hours after 10pm\",\n    \"starting at 9pm\",\n    \"around 11pm\",\n    \"happy hour\"\n  ];\n  \n  // Create a debug wrapper for parseTimeExpression\n  const debugParseTimeExpression = (expr: string) => {\n    console.log(`\\nDEBUG: Parsing \"${expr}\"`);\n    \n    // Check all our special case conditions\n    const lowered = expr.toLowerCase().trim();\n    console.log(\"- Is exact match for 'from 9pm until midnight'?\", lowered === \"from 9pm until midnight\");\n    console.log(\"- Contains 'until midnight'?\", lowered.includes(\"until midnight\"));\n    console.log(\"- Contains 'from' and matches our regex?\", /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i.test(lowered));\n    \n    const specialTimeWords = ['noon', 'midnight'];\n    for (const word of specialTimeWords) {\n      console.log(`- Is exact match for '${word}'?`, lowered === word);\n    }\n    \n    // Now parse and return the actual result\n    const result = parseTimeExpression(expr);\n    console.log(\"- Final result:\", JSON.stringify(result));\n    return result;\n  };\n  \n  // Debug the problematic expression separately\n  const problematicExpression = \"from 9pm until midnight\";\n  console.log(`\\nDebugging \"${problematicExpression}\":`);\n  console.log(\"Exact match?\", problematicExpression === \"from 9pm until midnight\");\n  console.log(\"Lowercase match?\", problematicExpression.toLowerCase().trim() === \"from 9pm until midnight\");\n  console.log(\"Char codes:\", Array.from(problematicExpression).map(c => c.charCodeAt(0)).join(\", \"));\n  debugParseTimeExpression(problematicExpression);\n  \n  for (const expr of timeExpressions) {\n    const result = parseTimeExpression(expr);\n    console.log(`\"${expr}\" → ${JSON.stringify(result)}`);\n  }\n  \n  console.log(\"\\n==== All Nightlife Tests Complete ====\");\n}\n\n// Run the tests\ntestNightlifeActivities();","size_bytes":4101},"server/testParameterTransfer.ts":{"content":"/**\n * Test file for verifying parameter transmission from NLP to search\n * \n * This tests that enhanced search parameters (searchTerm, keywords, minRating)\n * are correctly passed from Gemini API responses to the fixedTimes array\n * and ultimately used in venue searches.\n */\n\nimport { parseItineraryRequest } from './lib/nlp';\n\nasync function testParameterTransfer() {\n  console.log(\"TESTING PARAMETER TRANSFER FROM NLP TO SEARCH\");\n  console.log(\"=============================================\");\n  \n  await testRichSearchParameters();\n  \n  console.log(\"\\nAll tests completed. Check logs for parameter transmission details.\");\n}\n\n/**\n * Test rich search parameters from Gemini's response\n */\nasync function testRichSearchParameters() {\n  console.log(\"\\n1. Testing rich search parameters transmission\");\n  console.log(\"---------------------------------------------\");\n  \n  const richQueryWithParameters = \"I want to have a specialty coffee at a quiet cafe in Soho at 11am, then lunch at a restaurant with outdoor seating in Covent Garden at 1pm\";\n  \n  try {\n    console.log(`Test query: \"${richQueryWithParameters}\"`);\n    \n    const parsedRequest = await parseItineraryRequest(richQueryWithParameters);\n    \n    // Test the output using specific property checks rather than logging the whole object\n    console.log(\"\\nVerifying fixedTimes has searchTerm, keywords, and minRating...\");\n    \n    // Verify that we have 2 activities as expected\n    if (!parsedRequest.fixedTimes || parsedRequest.fixedTimes.length < 2) {\n      console.error(\"ERROR: Expected at least 2 fixedTimes entries, but got:\", \n                    parsedRequest.fixedTimes?.length || 0);\n    } else {\n      console.log(`Found ${parsedRequest.fixedTimes.length} fixedTimes entries`);\n      \n      // Extract and check the first fixedTime entry\n      const firstActivity = parsedRequest.fixedTimes[0];\n      console.log(\"First activity (fixedTime):\");\n      console.log(\"- Location:\", firstActivity.location);\n      console.log(\"- Time:\", firstActivity.time);\n      console.log(\"- Type:\", firstActivity.type);\n      console.log(\"- Search Term:\", firstActivity.searchTerm);\n      console.log(\"- Keywords:\", firstActivity.keywords ? JSON.stringify(firstActivity.keywords) : 'undefined');\n      console.log(\"- Min Rating:\", firstActivity.minRating);\n      \n      // Extract and check the second fixedTime entry\n      if (parsedRequest.fixedTimes.length > 1) {\n        const secondActivity = parsedRequest.fixedTimes[1];\n        console.log(\"\\nSecond activity (fixedTime):\");\n        console.log(\"- Location:\", secondActivity.location);\n        console.log(\"- Time:\", secondActivity.time);\n        console.log(\"- Type:\", secondActivity.type);\n        console.log(\"- Search Term:\", secondActivity.searchTerm);\n        console.log(\"- Keywords:\", secondActivity.keywords ? JSON.stringify(secondActivity.keywords) : 'undefined');\n        console.log(\"- Min Rating:\", secondActivity.minRating);\n      }\n      \n      // Check if we also received the original activities array from Gemini\n      if (parsedRequest.activities && parsedRequest.activities.length > 0) {\n        console.log(\"\\nVerifying original activities array from Gemini:\");\n        console.log(`Found ${parsedRequest.activities.length} activities in the original array`);\n        \n        // Extract and check the first activity\n        const firstOrigActivity = parsedRequest.activities[0];\n        console.log(\"\\nFirst original activity:\");\n        console.log(\"- Description:\", firstOrigActivity.description);\n        console.log(\"- Location:\", firstOrigActivity.location);\n        console.log(\"- Time:\", firstOrigActivity.time);\n        console.log(\"- Search Parameters:\");\n        console.log(\"  - Search Term:\", firstOrigActivity.searchParameters?.searchTerm);\n        console.log(\"  - Type:\", firstOrigActivity.searchParameters?.type);\n        console.log(\"  - Keywords:\", firstOrigActivity.searchParameters?.keywords ? \n                  JSON.stringify(firstOrigActivity.searchParameters.keywords) : 'undefined');\n        console.log(\"  - Min Rating:\", firstOrigActivity.searchParameters?.minRating);\n        console.log(\"  - Require Open Now:\", firstOrigActivity.searchParameters?.requireOpenNow);\n        console.log(\"- Requirements:\", firstOrigActivity.requirements ? \n                  JSON.stringify(firstOrigActivity.requirements) : 'undefined');\n        \n        // Extract and check the second activity if available\n        if (parsedRequest.activities.length > 1) {\n          const secondOrigActivity = parsedRequest.activities[1];\n          console.log(\"\\nSecond original activity:\");\n          console.log(\"- Description:\", secondOrigActivity.description);\n          console.log(\"- Location:\", secondOrigActivity.location);\n          console.log(\"- Time:\", secondOrigActivity.time);\n          console.log(\"- Search Parameters:\");\n          console.log(\"  - Search Term:\", secondOrigActivity.searchParameters?.searchTerm);\n          console.log(\"  - Type:\", secondOrigActivity.searchParameters?.type);\n          console.log(\"  - Keywords:\", secondOrigActivity.searchParameters?.keywords ? \n                    JSON.stringify(secondOrigActivity.searchParameters.keywords) : 'undefined');\n          console.log(\"  - Min Rating:\", secondOrigActivity.searchParameters?.minRating);\n          console.log(\"  - Require Open Now:\", secondOrigActivity.searchParameters?.requireOpenNow);\n          console.log(\"- Requirements:\", secondOrigActivity.requirements ? \n                    JSON.stringify(secondOrigActivity.requirements) : 'undefined');\n        }\n      } else {\n        console.log(\"\\nNo original activities array found in Gemini response\");\n      }\n    }\n    \n    // Check if we have a complete request structure\n    console.log(\"\\nFull request structure verification:\");\n    console.log(\"- Start Location:\", parsedRequest.startLocation);\n    console.log(\"- Destinations:\", JSON.stringify(parsedRequest.destinations));\n    console.log(\"- Number of fixed times:\", parsedRequest.fixedTimes.length);\n    console.log(\"- Number of activities:\", parsedRequest.activities?.length || 0);\n    console.log(\"- Preferences:\", JSON.stringify(parsedRequest.preferences));\n    \n    console.log(\"\\nParameter transmission test completed\");\n  } catch (error) {\n    console.error(\"Error testing parameter transmission:\", error);\n  }\n}\n\n// Run the tests\ntestParameterTransfer().catch(console.error);","size_bytes":6425},"server/testSearchParams.ts":{"content":"/**\n * Simplified test for search parameter transmission\n * Focuses specifically on verifying search parameters are passed from activities to fixedTimes\n */\n\nimport { parseItineraryRequest } from './lib/nlp';\n\nasync function testSearchParams() {\n  console.log(\"\\n=== TESTING SEARCH PARAMETER TRANSMISSION ===\\n\");\n  \n  const query = \"I want to have a specialty coffee at a quiet cafe in Soho at 11am\";\n  \n  try {\n    console.log(`Query: \"${query}\"\\n`);\n    \n    const result = await parseItineraryRequest(query);\n    \n    // Check if activities array was populated \n    if (result.activities && result.activities.length > 0) {\n      const activity = result.activities[0];\n      \n      console.log(\"FROM ACTIVITIES ARRAY:\");\n      console.log(\"---------------------\");\n      console.log(\"searchTerm:\", activity.searchParameters?.searchTerm);\n      console.log(\"type:\", activity.searchParameters?.type);\n      console.log(\"keywords:\", JSON.stringify(activity.searchParameters?.keywords));\n      console.log(\"minRating:\", activity.searchParameters?.minRating);\n      console.log(\"requirements:\", JSON.stringify(activity.requirements));\n    } else {\n      console.log(\"No activities array found.\");\n    }\n    \n    console.log(\"\\n\");\n    \n    // Check if fixedTimes array was populated\n    if (result.fixedTimes && result.fixedTimes.length > 0) {\n      const fixedTime = result.fixedTimes[0];\n      \n      console.log(\"TO FIXED TIMES ARRAY:\");\n      console.log(\"--------------------\");\n      console.log(\"searchTerm:\", fixedTime.searchTerm);\n      console.log(\"type:\", fixedTime.type);\n      console.log(\"keywords:\", JSON.stringify(fixedTime.keywords));\n      console.log(\"minRating:\", fixedTime.minRating);\n    } else {\n      console.log(\"No fixedTimes array found.\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error);\n  }\n}\n\ntestSearchParams().catch(console.error);","size_bytes":1875},"server/testStartingLocationLogic.ts":{"content":"/**\n * Test for starting location logic\n * \n * This file tests the location handling in our application:\n * 1. Direct testing of location defaults based on time of day\n * 2. Testing the pattern of using destination/fixed location as starting point\n * 3. Testing the enhanced error messages for location errors\n */\n\n// Import test utilities \nimport * as assert from 'assert';\n\n/**\n * Represents a basic itinerary request structure for testing\n */\ntype TestItineraryRequest = {\n  startLocation: string | null;\n  destinations: string[];\n  fixedTimes: Array<{\n    location: string | null;\n    time: string;\n    type?: string;\n  }>;\n  preferences: {\n    type?: string;\n    requirements?: string[];\n  };\n};\n\n/**\n * Test function to verify starting location inference logic\n */\nasync function testStartingLocationLogic() {\n  console.log(\"--- Testing Starting Location Logic ---\");\n  \n  // Test direct inference without API calls\n  testInferredStartLocation();\n  \n  // Test time-of-day based defaults\n  testTimeBasedDefaults();\n  \n  // Test error message enhancements\n  testErrorMessages();\n  \n  console.log(\"\\n--- Tests Complete ---\");\n}\n\n/**\n * Tests that verify starting location inference from other data\n */\nfunction testInferredStartLocation() {\n  console.log(\"\\n--- Testing Location Inference Logic ---\");\n  \n  // Case 1: Use first destination as starting point\n  const testRequest1: TestItineraryRequest = {\n    startLocation: null,\n    destinations: [\"Soho\", \"Covent Garden\"],\n    fixedTimes: [],\n    preferences: {}\n  };\n  \n  console.log(\"\\nTest: Using first destination as starting point\");\n  \n  // Apply the location inference logic\n  applyStartingLocationLogic(testRequest1);\n  \n  // Verify starting location was set correctly\n  if (testRequest1.startLocation === \"Soho\") {\n    console.log(`✅ Correctly used first destination \"${testRequest1.startLocation}\" as starting point`);\n  } else {\n    console.log(`❌ Failed to use first destination as starting point`);\n  }\n  \n  // Verify destination was removed from list\n  if (testRequest1.destinations.length === 1 && testRequest1.destinations[0] === \"Covent Garden\") {\n    console.log(\"✅ Correctly removed first destination from list\");\n  } else {\n    console.log(`❌ Failed to remove first destination from list: ${JSON.stringify(testRequest1.destinations)}`);\n  }\n  \n  // Case 2: Use fixed time location as starting point\n  const testRequest2: TestItineraryRequest = {\n    startLocation: null,\n    destinations: [],\n    fixedTimes: [{ location: \"South Kensington\", time: \"14:00\", type: \"museum\" }],\n    preferences: {}\n  };\n  \n  console.log(\"\\nTest: Using fixed time location as starting point\");\n  \n  // Apply the location inference logic\n  applyStartingLocationLogic(testRequest2);\n  \n  // Verify starting location was set correctly\n  if (testRequest2.startLocation === \"South Kensington\") {\n    console.log(`✅ Correctly used fixed time location \"${testRequest2.startLocation}\" as starting point`);\n  } else {\n    console.log(`❌ Failed to use fixed time location as starting point`);\n  }\n}\n\n/**\n * Tests defaults based on time of day\n */\nfunction testTimeBasedDefaults() {\n  console.log(\"\\n--- Testing Time-Based Default Locations ---\");\n  \n  // Store original Date constructor\n  const OriginalDate = global.Date;\n  \n  // Time-specific test cases\n  const timeBasedTests = [\n    { hour: 8, expectedDefault: \"King's Cross\", timeCategory: \"Morning\" },\n    { hour: 13, expectedDefault: \"Oxford Street\", timeCategory: \"Lunch\" },\n    { hour: 16, expectedDefault: \"South Kensington\", timeCategory: \"Afternoon\" },\n    { hour: 20, expectedDefault: \"Soho\", timeCategory: \"Evening\" },\n    { hour: 2, expectedDefault: \"Leicester Square\", timeCategory: \"Late night\" }\n  ];\n  \n  for (const test of timeBasedTests) {\n    try {\n      console.log(`\\nTest: ${test.timeCategory} default location (${test.hour}:00)`);\n      \n      // Mock Date to return specific hour\n      const mockDate = new Date();\n      mockDate.setHours(test.hour);\n      \n      // Override Date constructor\n      global.Date = class extends Date {\n        constructor() {\n          super();\n          return mockDate;\n        }\n        static now() {\n          return mockDate.getTime();\n        }\n      } as any;\n      \n      // Test request with no location information\n      const request: TestItineraryRequest = {\n        startLocation: null,\n        destinations: [],\n        fixedTimes: [],\n        preferences: {}\n      };\n      \n      // Get the default based on current time\n      const defaultLocation = getLocationBasedOnTimeOfDay();\n      \n      // Apply it to our test request\n      request.startLocation = defaultLocation;\n      \n      // Verify correct default was chosen\n      if (request.startLocation === test.expectedDefault) {\n        console.log(`✅ Correctly used \"${request.startLocation}\" as default for ${test.timeCategory}`);\n      } else {\n        console.log(`❌ Expected \"${test.expectedDefault}\" but got \"${request.startLocation}\"`);\n      }\n      \n    } finally {\n      // Restore original Date\n      global.Date = OriginalDate;\n    }\n  }\n}\n\n/**\n * Tests enhanced error messages\n */\nfunction testErrorMessages() {\n  console.log(\"\\n--- Testing Error Message Enhancements ---\");\n  \n  const testErrorMessages = [\n    {\n      name: \"Location not found error\",\n      originalMessage: \"We need to know where in London you'll be\",\n      shouldEnhance: true\n    },\n    {\n      name: \"API error\",\n      originalMessage: \"Failed to parse JSON response from API\",\n      shouldEnhance: true\n    },\n    {\n      name: \"Generic error\",\n      originalMessage: \"An unexpected error occurred\",\n      shouldEnhance: false\n    }\n  ];\n  \n  for (const test of testErrorMessages) {\n    console.log(`\\nTest: ${test.name}`);\n    \n    try {\n      const enhancedMessage = enhanceErrorMessage(new Error(test.originalMessage));\n      \n      // Log the enhanced message (truncated if long)\n      const truncatedMessage = enhancedMessage.length > 50 ? \n        enhancedMessage.substring(0, 50) + \"...\" : \n        enhancedMessage;\n      \n      console.log(`Enhanced message: \"${truncatedMessage}\"`);\n      \n      if (test.shouldEnhance) {\n        if (enhancedMessage.length > test.originalMessage.length) {\n          console.log(\"✅ Successfully enhanced error message with additional information\");\n        } else {\n          console.log(\"❌ Failed to enhance error message\");\n        }\n      } else {\n        if (enhancedMessage === test.originalMessage) {\n          console.log(\"✅ Correctly left generic error message unchanged\");\n        } else {\n          console.log(\"❌ Unnecessarily modified generic error message\");\n        }\n      }\n    } catch (error) {\n      console.log(`❌ Test failed: ${error}`);\n    }\n  }\n}\n\n/**\n * Helper: Apply starting location logic to a request\n * This is a direct implementation of the logic in our actual code\n */\nfunction applyStartingLocationLogic(request: TestItineraryRequest): void {\n  if (!request.startLocation) {\n    // Case 1: If there are destinations, use the first one as the starting point\n    if (request.destinations.length > 0) {\n      request.startLocation = request.destinations[0];\n      request.destinations.shift();\n    } \n    // Case 2: If there are fixed times with locations, use the first one\n    else if (request.fixedTimes.length > 0 && request.fixedTimes[0].location) {\n      request.startLocation = request.fixedTimes[0].location;\n    }\n    // Case 3: Use time-of-day based default\n    else {\n      request.startLocation = getLocationBasedOnTimeOfDay();\n    }\n  }\n}\n\n/**\n * Helper: Get a default location based on time of day\n * This mimics the logic in our actual code\n */\nfunction getLocationBasedOnTimeOfDay(): string {\n  const currentHour = new Date().getHours();\n  \n  // Morning (6-11): Transport hubs are logical starting points\n  if (currentHour >= 6 && currentHour < 12) {\n    return \"King's Cross\"; // Major transport hub\n  } \n  // Lunchtime (12-14): Central shopping/business areas\n  else if (currentHour >= 12 && currentHour < 15) {\n    return \"Oxford Street\"; // Central shopping area\n  }\n  // Afternoon (15-17): Cultural areas\n  else if (currentHour >= 15 && currentHour < 18) {\n    return \"South Kensington\"; // Museum district\n  }\n  // Evening/Night (18-23): Entertainment districts\n  else if (currentHour >= 18 && currentHour < 24) {\n    return \"Soho\"; // Nightlife center\n  }\n  // Late night/early morning (0-5): Safe, well-lit areas\n  else {\n    return \"Leicester Square\"; // Always busy, well-lit 24-hour area\n  }\n}\n\n/**\n * Helper: Simulate the enhanced error message logic\n */\nfunction enhanceErrorMessage(error: Error): string {\n  // Location errors get neighborhood suggestions\n  if (error.message.includes(\"location\") || error.message.includes(\"where in London\")) {\n    return `${error.message}\\n\\nPopular London areas you could mention:\\n` +\n      \"• Central: Soho, Covent Garden, Westminster, Leicester Square\\n\" +\n      \"• West: Notting Hill, Kensington, Chelsea, Holland Park\\n\" +\n      \"• East: Shoreditch, City of London, Canary Wharf\\n\" +\n      \"• North: Camden Town, King's Cross, Hampstead\\n\" +\n      \"• South: Greenwich, South Bank\";\n  }\n  // API/parsing errors get gentle guidance\n  else if (error.message.includes(\"JSON\") || error.message.includes(\"API\") || error.message.includes(\"language model\")) {\n    return \"We're having trouble understanding your request right now. Please try:\\n\" +\n      \"1. Being more specific about where and when\\n\" +\n      \"2. Keeping your request simple and focused\\n\" +\n      \"3. Using common London landmarks or neighborhoods\";\n  }\n  // Return original for other errors\n  return error.message;\n}\n\n// Run the tests\ntestStartingLocationLogic();","size_bytes":9715},"server/testTimeExpression.ts":{"content":"import { parseTimeExpression, expandRelativeTime, getDefaultTime } from './lib/languageProcessing';\n\n/**\n * Comprehensive test for time parsing functions\n * Tests all the different time expression patterns we support\n */\nfunction testTimeParsing() {\n  // Basic time expressions\n  const basicExpressions = [\n    \"morning\",\n    \"afternoon\",\n    \"evening\",\n    \"9am\",\n    \"10:30am\",\n    \"2pm\",\n    \"14:30\",\n    \"noon\",\n    \"midnight\"\n  ];\n  \n  // Time range expressions\n  const rangeExpressions = [\n    \"between 2 and 4pm\",\n    \"between 10am and 2pm\",\n    \"from 10am to noon\",\n    \"from 8pm to midnight\",\n    \"from 9:30am to 12:00pm\",\n    \"3-5pm\",\n    \"9am-11am\",\n    \"10:00-15:30\"\n  ];\n  \n  // Complex relative time expressions\n  const complexRelativeExpressions = [\n    \"in the morning\",\n    \"during the afternoon\",\n    \"late evening\",\n    \"early morning\",\n    \"around noon\",\n    \"at night\",\n    \"after lunch\",\n    \"before dinner\",\n    \"midday\",\n    \"at 3 o'clock\",\n    \"tea time\",\n    \"happy hour\",\n    \"after work\"\n  ];\n  \n  console.log(\"--- Testing Basic Time Expression Parsing ---\");\n  for (const expr of basicExpressions) {\n    const result = parseTimeExpression(expr);\n    console.log(`\"${expr}\" → ${JSON.stringify(result)}`);\n  }\n  \n  console.log(\"\\n--- Testing Time Range Expression Parsing ---\");\n  for (const expr of rangeExpressions) {\n    const result = parseTimeExpression(expr);\n    console.log(`\"${expr}\" → ${JSON.stringify(result)}`);\n  }\n  \n  console.log(\"\\n--- Testing Complex Relative Time Expressions ---\");\n  for (const expr of complexRelativeExpressions) {\n    const result = parseTimeExpression(expr);\n    console.log(`\"${expr}\" → ${JSON.stringify(result)}`);\n  }\n  \n  console.log(\"\\n--- Testing Activity-Specific Default Times ---\");\n  const activities = [\n    \"breakfast\",\n    \"lunch\",\n    \"dinner\",\n    \"coffee\",\n    \"drinks\",\n    \"shopping\",\n    \"museum visit\",\n    \"park walk\",\n    \"gallery exhibition\",\n    \"pub crawl\",\n    \"nightclub\",\n    \"bar hopping\"\n  ];\n  \n  for (const activity of activities) {\n    const defaultTime = getDefaultTime(activity);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n\n  console.log(\"\\n--- Testing Time-of-Day Context Sensitivity ---\");\n  \n  // Test morning defaults (8am)\n  const morningDate = new Date();\n  morningDate.setHours(8, 0, 0);\n  console.log(\"Morning (8am) defaults:\");\n  for (const activity of activities.slice(0, 5)) { // Just test a subset\n    const defaultTime = getDefaultTime(activity, morningDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n\n  // Test afternoon defaults (2pm)\n  const afternoonDate = new Date();\n  afternoonDate.setHours(14, 0, 0);\n  console.log(\"\\nAfternoon (2pm) defaults:\");\n  for (const activity of activities.slice(0, 5)) {\n    const defaultTime = getDefaultTime(activity, afternoonDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n\n  // Test evening defaults (7pm)\n  const eveningDate = new Date();\n  eveningDate.setHours(19, 0, 0);\n  console.log(\"\\nEvening (7pm) defaults:\");\n  for (const activity of activities.slice(0, 5)) {\n    const defaultTime = getDefaultTime(activity, eveningDate);\n    console.log(`\"${activity}\" → \"${defaultTime}\"`);\n  }\n  \n  // Test specific edge cases\n  console.log(\"\\n--- Testing Edge Cases ---\");\n  const edgeCases = [\n    \"at 12pm\", // noon in 12-hour format\n    \"12am\",    // midnight in 12-hour format\n    \"00:00\",   // midnight in 24-hour format\n    \"24:00\",   // invalid but possible user input\n    \"from 11pm to 1am\", // crossing midnight\n    \"11:59pm\"  // just before midnight\n  ];\n  \n  for (const expr of edgeCases) {\n    const result = parseTimeExpression(expr);\n    console.log(`\"${expr}\" → ${JSON.stringify(result)}`);\n  }\n}\n\ntestTimeParsing();","size_bytes":3743},"server/testWeatherAPI.ts":{"content":"/**\n * Test weather API connection\n * This simple script runs the weather service test function to verify the API key works\n */\n\nimport {\n  getWeatherForecast,\n  isVenueOutdoor,\n  isWeatherSuitableForOutdoor\n} from './lib/weatherService';\n\nasync function testWeatherAPI() {\n  // Test location (London)\n  const londonLat = 51.5074;\n  const londonLng = -0.1278;\n  \n  console.log(\"=== TESTING WEATHER API CONNECTION ===\");\n  console.log(\"API Key availability:\", process.env.WEATHER_API_KEY ? \"✅ Present\" : \"❌ Missing\");\n  \n  // Test weather forecast fetch\n  try {\n    console.log(\"\\nFetching London weather forecast...\");\n    const forecast = await getWeatherForecast(londonLat, londonLng);\n    \n    console.log(\"✅ Successfully fetched weather data!\");\n    console.log(\"--------------------------------\");\n    console.log(`City: ${forecast.city.name}`);\n    console.log(`Current temp: ${forecast.list[0].main.temp}°C`);\n    console.log(`Conditions: ${forecast.list[0].weather[0].main} (${forecast.list[0].weather[0].description})`);\n    console.log(`Wind: ${forecast.list[0].wind.speed} m/s`);\n    console.log(`Humidity: ${forecast.list[0].main.humidity}%`);\n    console.log(\"--------------------------------\");\n    \n    // Test cache by making a second request\n    console.log(\"\\nTesting cache (should use cached data):\");\n    console.time(\"Second request\");\n    await getWeatherForecast(londonLat, londonLng);\n    console.timeEnd(\"Second request\");\n    \n    // Verify weather suitability checks\n    const now = new Date();\n    const suitability = isWeatherSuitableForOutdoor(forecast, now);\n    console.log(`\\nWeather suitability for outdoor activities: ${suitability ? \"✅ Suitable\" : \"❌ Not suitable\"}`);\n    \n    // Return success\n    return true;\n  } catch (error) {\n    console.error(\"❌ ERROR fetching weather data:\", error);\n    return false;\n  }\n}\n\n// Run the test\ntestWeatherAPI().then(success => {\n  if (success) {\n    console.log(\"\\n✅ Weather API connection test completed successfully!\");\n  } else {\n    console.log(\"\\n❌ Weather API connection test failed!\");\n  }\n});","size_bytes":2093},"server/testWeatherService.ts":{"content":"import { getWeatherForecast, isVenueOutdoor, isWeatherSuitableForOutdoor, getWeatherAwareVenue } from './lib/weatherService';\nimport { PlaceDetails } from '@shared/schema';\n\nasync function testWeatherService() {\n  // Test location (London)\n  const londonLat = 51.5074;\n  const londonLng = -0.1278;\n  \n  console.log(\"===== TESTING WEATHER SERVICE =====\");\n  \n  // Test weather forecast fetch\n  try {\n    console.log(\"\\n🌤️ Fetching London weather forecast...\");\n    const forecast = await getWeatherForecast(londonLat, londonLng);\n    \n    console.log(\"✅ Successfully fetched weather data:\");\n    console.log(`  First forecast temp: ${forecast.list[0].main.temp}°C`);\n    console.log(`  Conditions: ${forecast.list[0].weather[0].main}`);\n    \n    // Test cache by making a second request\n    console.log(\"\\n🔄 Testing cache (should be instant):\");\n    const startTime = Date.now();\n    const cachedForecast = await getWeatherForecast(londonLat, londonLng);\n    const duration = Date.now() - startTime;\n    console.log(`  Second request took ${duration}ms`);\n  } catch (error) {\n    console.error(\"❌ Error fetching weather:\", error);\n    console.error(\"Please ensure WEATHER_API_KEY is set in environment variables\");\n  }\n  \n  // Test venue classification\n  console.log(\"\\n🏛️ Testing Venue Classification\");\n  console.log(\"--------------------------------\");\n  const testVenueTypes = [\n    [\"park\"], \n    [\"restaurant\"], \n    [\"museum\"], \n    [\"tourist_attraction\", \"park\"],\n    [\"tourist_attraction\", \"museum\"]\n  ];\n  \n  for (const types of testVenueTypes) {\n    const isOutdoor = isVenueOutdoor(types);\n    console.log(`Types [${types.join(', ')}] → ${isOutdoor ? \"Outdoor\" : \"Indoor\"}`);\n  }\n  \n  // Test weather suitability with mock data\n  console.log(\"\\n☔ Testing Weather Suitability\");\n  console.log(\"-----------------------------\");\n  const mockWeatherData = {\n    list: [\n      {\n        dt: Math.floor(Date.now() / 1000),\n        main: { temp: 20 },\n        weather: [{ id: 800, main: \"Clear\", description: \"clear sky\" }]\n      },\n      {\n        dt: Math.floor(Date.now() / 1000) + 3600,\n        main: { temp: 18 },\n        weather: [{ id: 500, main: \"Rain\", description: \"light rain\" }]\n      }\n    ]\n  };\n  \n  const testTimes = [\n    new Date(),\n    new Date(Date.now() + 3600 * 1000)\n  ];\n  \n  for (const time of testTimes) {\n    const suitable = isWeatherSuitableForOutdoor(mockWeatherData, time);\n    console.log(`Time ${time.toLocaleTimeString()} → ${suitable ? \"Suitable\" : \"Not suitable\"} for outdoor activities`);\n  }\n  \n  // Test weather-aware venue recommendation\n  console.log(\"\\n🔄 Testing Weather-Aware Venue Selection\");\n  console.log(\"-------------------------------------\");\n  \n  // Sample venues\n  const outdoorVenue: PlaceDetails = {\n    name: \"Hyde Park\",\n    formatted_address: \"Hyde Park, London\",\n    place_id: \"ChIJhz8mAOUEdkgRnfK79dOVH9U\",\n    geometry: {\n      location: {\n        lat: 51.5073,\n        lng: -0.1657\n      }\n    },\n    types: [\"park\", \"tourist_attraction\"]\n  };\n  \n  const indoorVenue: PlaceDetails = {\n    name: \"British Museum\",\n    formatted_address: \"Great Russell St, London WC1B 3DG\",\n    place_id: \"ChIJB9OTMDIbdkgRp0JWbQGZsS8\",\n    geometry: {\n      location: {\n        lat: 51.5194,\n        lng: -0.1269\n      }\n    },\n    types: [\"museum\", \"tourist_attraction\"]\n  };\n  \n  try {\n    // Mock bad weather data\n    const badWeatherData = {\n      list: [\n        {\n          dt: Math.floor(Date.now() / 1000),\n          main: { temp: 12 },\n          weather: [{ id: 500, main: \"Rain\", description: \"light rain\" }]\n        }\n      ]\n    };\n    \n    // Mock getWeatherForecast to return our mock data\n    const originalFn = getWeatherForecast;\n    (global as any).getWeatherForecast = async () => badWeatherData;\n    \n    console.log(\"Testing with outdoor primary venue and indoor alternative in bad weather:\");\n    console.log(`Primary venue: ${outdoorVenue.name} (${outdoorVenue.types?.join(', ')})`);\n    console.log(`Alternative: ${indoorVenue.name} (${indoorVenue.types?.join(', ')})`);\n    \n    // Test getWeatherAwareVenue\n    const result = await getWeatherAwareVenue(\n      outdoorVenue,\n      [indoorVenue],\n      51.5073,\n      -0.1657,\n      new Date()\n    );\n    \n    console.log(`\\nResult: ${result.venue.name}`);\n    console.log(`Weather suitable for outdoor: ${result.weatherSuitable ? \"Yes\" : \"No\"}`);\n    console.log(`Recommendation correct: ${result.venue.name === indoorVenue.name ? \"✅\" : \"❌\"}`);\n    \n    // Restore the original function\n    (global as any).getWeatherForecast = originalFn;\n  } catch (error) {\n    console.error(\"❌ Error in weather-aware venue test:\", error);\n  }\n}\n\n// Run the tests\ntestWeatherService();","size_bytes":4727},"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path, { dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        __dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(__dirname, \"../../dist/public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","size_bytes":2385},"shared/schema.ts":{"content":"import { pgTable, text, serial, timestamp, jsonb, uuid, varchar, boolean } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\n// User authentication tables\nexport const users = pgTable(\"users\", {\n  id: uuid(\"id\").defaultRandom().primaryKey(),\n  email: varchar(\"email\", { length: 255 }).notNull().unique(),\n  password_hash: text(\"password_hash\"),  // Optional for OAuth users\n  name: text(\"name\"),\n  created_at: timestamp(\"created_at\").notNull().defaultNow(),\n  avatar_url: text(\"avatar_url\"),\n  google_id: text(\"google_id\").unique(),\n  auth_provider: text(\"auth_provider\").default(\"local\"),  // \"local\" or \"google\"\n});\n\n// Session table with structure compatible with connect-pg-simple\nexport const sessions = pgTable(\"sessions\", {\n  sid: varchar(\"sid\", { length: 255 }).notNull().primaryKey(),\n  sess: jsonb(\"sess\").notNull(),\n  expire: timestamp(\"expire\").notNull(),\n});\n\nexport const places = pgTable(\"places\", {\n  id: serial(\"id\").primaryKey(),\n  placeId: text(\"place_id\").notNull().unique(),\n  name: text(\"name\").notNull(),\n  address: text(\"address\").notNull(),\n  location: jsonb(\"location\").notNull(),\n  details: jsonb(\"details\").notNull(),\n  alternatives: jsonb(\"alternatives\"),  // Store alternative venues\n  scheduledTime: text(\"scheduled_time\"),\n});\n\nexport const itineraries = pgTable(\"itineraries\", {\n  id: serial(\"id\").primaryKey(),\n  query: text(\"query\").notNull(),\n  places: jsonb(\"places\").notNull(),\n  travelTimes: jsonb(\"travel_times\").notNull(),\n  created: timestamp(\"created\").notNull().defaultNow(),\n});\n\n// Update itineraries schema to include user association\nexport const userItineraries = pgTable(\"user_itineraries\", {\n  id: serial(\"id\").primaryKey(),\n  userId: uuid(\"user_id\").notNull().references(() => users.id),\n  itineraryId: serial(\"itinerary_id\").notNull().references(() => itineraries.id),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\nexport const insertPlaceSchema = createInsertSchema(places).omit({ id: true });\nexport const insertItinerarySchema = createInsertSchema(itineraries).omit({ id: true, created: true });\n// Schema for local registration\nexport const insertLocalUserSchema = createInsertSchema(users).omit({ \n  id: true, \n  created_at: true, \n  password_hash: true,\n  google_id: true,\n  avatar_url: true,\n  auth_provider: true\n})\n  .extend({\n    password: z.string().min(8).max(100),\n    confirmPassword: z.string().min(8).max(100)\n  })\n  .refine(data => data.password === data.confirmPassword, {\n    message: \"Passwords do not match\",\n    path: [\"confirmPassword\"]\n  });\n\n// Schema for Google sign-in\nexport const insertGoogleUserSchema = createInsertSchema(users).omit({\n  id: true,\n  created_at: true,\n  password_hash: true,\n  auth_provider: true\n}).extend({\n  auth_provider: z.literal(\"google\")\n});\n\n// Schema for login\nexport const loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(1)\n});\n\n// Schema for Google auth\nexport const googleAuthSchema = z.object({\n  token: z.string()\n});\n\nexport type Place = typeof places.$inferSelect;\nexport type InsertPlace = z.infer<typeof insertPlaceSchema>;\nexport type Itinerary = typeof itineraries.$inferSelect;\nexport type InsertItinerary = z.infer<typeof insertItinerarySchema>;\nexport type User = typeof users.$inferSelect;\nexport type InsertLocalUser = z.infer<typeof insertLocalUserSchema>;\nexport type InsertGoogleUser = z.infer<typeof insertGoogleUserSchema>;\nexport type UserItinerary = typeof userItineraries.$inferSelect;\nexport type LoginCredentials = z.infer<typeof loginSchema>;\nexport type GoogleAuthCredentials = z.infer<typeof googleAuthSchema>;\n\nexport type PlaceDetails = {\n  name: string;\n  formatted_address: string;\n  place_id: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n  types?: string[];\n  rating?: number;\n  opening_hours?: {\n    open_now?: boolean;\n    periods?: Array<{\n      open: { time: string; day: number };\n      close: { time: string; day: number };\n    }>;\n  };\n  is_primary?: boolean;\n  distance_from_primary?: number;\n  area_info?: any;\n  // Additional fields for enhanced context\n  activityDescription?: string;\n  requirements?: string[];\n  searchTermUsed?: string;\n  // Weather-related information\n  isOutdoorVenue?: boolean;\n  weatherSuitable?: boolean;\n  weatherAwareRecommendation?: boolean;\n};\n\nexport type VenueSearchResult = {\n  primary: PlaceDetails;\n  alternatives: PlaceDetails[];\n};\n\nexport type SearchParameters = {\n  searchTerm: string;\n  type: string;\n  keywords: string[];\n  minRating: number;\n  requireOpenNow: boolean;\n};\n\nexport type Activity = {\n  description: string;\n  location: string;\n  time: string;\n  searchParameters: SearchParameters;\n  requirements: string[];\n};\n\nexport type EnhancedRequest = {\n  startLocation: string | null;\n  destinations: string[];\n  activities: Activity[];\n  preferences: {\n    venueQualities: string[];\n    restrictions: string[];\n  };\n};","size_bytes":4968},"shared/types.ts":{"content":"// Shared types for NLP processing\n\nexport interface StructuredRequest {\n  startLocation: string | null;\n  destinations: string[];\n  fixedTimes: Array<{\n    location: string;\n    time: string;  // Format: ISO timestamp or \"HH:MM\" (24-hour)\n    type?: string; // e.g., \"restaurant\", \"cafe\"\n    // Additional parameters for enhanced search\n    searchTerm?: string;\n    keywords?: string[];\n    minRating?: number;\n    displayTime?: string; // Format: \"h:mm a\" for display in NYC timezone\n    searchPreference?: string; // Specific venue preference (e.g., \"sandwich place\", \"sports bar\")\n  }>;\n  preferences: {\n    type?: string;\n    requirements?: string[];\n  };\n  // Enhanced response from Gemini with detailed activity information\n  activities?: Array<{\n    description: string;\n    location: string;\n    time: string;\n    searchParameters: {\n      searchTerm: string;\n      type: string;\n      keywords: string[];\n      minRating: number | null;\n      requireOpenNow: boolean | null;\n    };\n    requirements: string[];\n    confidence?: number;\n  }>;\n}","size_bytes":1052},"client/src/App.tsx":{"content":"import React from 'react';\nimport { Route, Switch } from 'wouter';\nimport { AuthProvider } from './hooks/useAuth';\nimport { ProtectedRoute } from './components/auth/ProtectedRoute';\nimport TopNav from './components/TopNav';\nimport HomePage from './pages/HomePage';\nimport LoginPage from './pages/LoginPage';\nimport RegisterPage from './pages/RegisterPage';\nimport ProfilePage from './pages/ProfilePage';\nimport ItineraryPage from './pages/ItineraryPage';\nimport { Toaster } from './components/ui/toaster';\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <div className=\"min-h-screen flex flex-col\">\n        <TopNav />\n        <main className=\"flex-1\">\n          <Switch>\n            <Route path=\"/login\" component={LoginPage} />\n            <Route path=\"/profile\">\n              <ProtectedRoute>\n                <ProfilePage />\n              </ProtectedRoute>\n            </Route>\n            <Route path=\"/itinerary/:id\">\n              <ItineraryPage />\n            </Route>\n            <Route path=\"/\">\n              <HomePage />\n            </Route>\n          </Switch>\n        </main>\n        <Toaster />\n      </div>\n    </AuthProvider>\n  );\n}\n\nexport default App;","size_bytes":1175},"client/src/index.css":{"content":"/* Import fonts - keep at the top */\n@import url('https://fonts.googleapis.com/css2?family=Rozha+One&display=swap');\n@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap');\n@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n@layer base {\n  /* Root CSS Variables */\n  :root {\n    /* Brand Colors */\n    --brand-pink: #FC94C5;\n    --brand-black: #1C1C1C;\n    --brand-blue: #17B9E6;\n    \n    /* Opacity Variants */\n    --brand-pink-10: rgba(252, 148, 197, 0.1);\n    --brand-blue-10: rgba(23, 185, 230, 0.1);\n    --brand-blue-20: rgba(23, 185, 230, 0.2);\n    --brand-black-10: rgba(28, 28, 28, 0.1);\n    --brand-black-70: rgba(28, 28, 28, 0.7);\n    --brand-black-80: rgba(28, 28, 28, 0.8);\n    --white-20: rgba(255, 255, 255, 0.2);\n    --white-30: rgba(255, 255, 255, 0.3);\n    --white-50: rgba(255, 255, 255, 0.5);\n    --white-80: rgba(255, 255, 255, 0.8);\n    --white-85: rgba(255, 255, 255, 0.85);\n    --white-95: rgba(255, 255, 255, 0.95);\n    \n    /* Shadows */\n    --shadow-sm: 0 5px 20px rgba(0, 0, 0, 0.04);\n    --shadow-md: 0 6px 18px rgba(0, 0, 0, 0.2);\n    \n    /* Border Radius */\n    --radius-sm: 8px;\n    --radius-md: 12px;\n    --radius-lg: 16px;\n    \n    /* Spacing */\n    --spacing-xs: 0.5rem;\n    --spacing-sm: 1rem;\n    --spacing-md: 1.5rem;\n    --spacing-lg: 2rem;\n    --spacing-xl: 3rem;\n  }\n\n  * {\n    @apply border-border;\n  }\n\n  html, body {\n    height: 100%;\n    min-height: 100vh;\n  }\n\n  body {\n    @apply antialiased text-foreground;\n    font-family: 'Poppins', sans-serif;\n    font-weight: 600;\n    background-color: #FFFFFF;\n    color: var(--brand-black);\n    background-image: \n      url(\"data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='rgba(23, 185, 230, 0.02)' fill-opacity='0.03' fill-rule='evenodd'/%3E%3C/svg%3E\");\n    position: relative;\n    overflow-x: hidden;\n  }\n  \n  /* Fixed position container for main background with subtle gradient */\n  .main-glass-effect {\n    content: \"\";\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: #FFFFFF; /* White base */\n    background-image: linear-gradient(135deg, rgba(23, 185, 230, 0.03) 0%, rgba(23, 185, 230, 0.01) 100%);\n    z-index: 0;\n    pointer-events: none;\n  }\n  \n  /* Subtle overlay for enhanced depth */\n  .main-glass-effect::after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(255, 255, 255, 0.8);\n    background-image: linear-gradient(\n      to bottom,\n      rgba(255, 255, 255, 0.95) 0%,\n      rgba(255, 255, 255, 0.85) 100%\n    );\n    z-index: 1;\n    pointer-events: none;\n  }\n  \n  /* Subtle geometric accents */\n  .main-glass-effect::before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background-image: \n      linear-gradient(45deg, transparent 98%, rgba(23, 185, 230, 0.1) 99%, transparent 100%),\n      linear-gradient(135deg, transparent 97%, rgba(23, 185, 230, 0.05) 98%, transparent 100%);\n    background-size: 50px 50px;\n    opacity: 0.5;\n    z-index: 0;\n    pointer-events: none;\n  }\n  \n  /* The glass effect is now handled by .main-glass-effect */\n\n  /* Typography treatments - enhanced letter spacing and contrast */\n  h1, h2, h3, .logo-font, .font-logo {\n    font-family: 'Rozha One', serif;\n    letter-spacing: 0.08em; /* Improved +8% letter spacing for headings */\n    color: var(--brand-black);\n    font-weight: 700; /* Increase contrast between heading and body weights */\n  }\n  \n  body, p, button, input, textarea, select, .body-text {\n    font-family: 'Poppins', sans-serif;\n    font-weight: 600; /* SemiBold */\n    color: var(--brand-black);\n    letter-spacing: 0.01em; /* Slight letter spacing improvement */\n  }\n  \n  /* Ensure text contrast meets WCAG AA standards */\n  .text-contrast-fix {\n    color: var(--brand-black) !important;\n  }\n  \n  /* Text hierarchy */\n  .logo {\n    font-size: 32px; /* Logo size as specified */\n  }\n  \n  h1, .heading-primary {\n    font-size: 24px; /* \"What's The Plan?\" size */\n    text-align: center; /* Center headings for better symmetry */\n  }\n  \n  /* Brand colors */\n  :root {\n    --brand-pink: #FC94C5;\n    --brand-black: #1C1C1C;\n    --brand-blue: #17B9E6;\n  }\n  \n  /* Custom utility classes */\n  .text-brand-pink {\n    color: var(--brand-pink);\n  }\n  \n  .text-brand-black {\n    color: var(--brand-black);\n  }\n  \n  .text-brand-blue {\n    color: var(--brand-blue);\n  }\n  \n  .bg-brand-pink {\n    background-color: var(--brand-pink);\n  }\n  \n  .bg-brand-black {\n    background-color: var(--brand-black);\n  }\n  \n  .bg-brand-blue {\n    background-color: var(--brand-blue);\n  }\n  \n  .border-brand-blue {\n    border-color: var(--brand-blue);\n  }\n\n  /* Selected venue highlight */\n  .venue-selected {\n    border: 2px solid var(--brand-blue);\n    box-shadow: 0 0 0 2px rgba(23, 185, 230, 0.3);\n  }\n  \n  /* Premium glass effect containers with subtle blue gradient */\n  .glass-effect {\n    background: linear-gradient(135deg, var(--brand-blue-10), rgba(23, 185, 230, 0.03));\n    backdrop-filter: blur(15px);\n    -webkit-backdrop-filter: blur(15px);\n    border-radius: var(--radius-md);\n    box-shadow: var(--shadow-sm);\n    border: 1px solid var(--brand-black-10);\n    padding: var(--spacing-md);\n    position: relative;\n    transition: all 0.3s ease;\n    z-index: 1;\n  }\n  \n  /* Inner border effect for glass containers (inner glow) */\n  .glass-effect::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 11px; /* 1px smaller than container */\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n  }\n  \n  /* Light reflection along top edge */\n  .glass-effect::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 5%;\n    right: 5%;\n    height: 1px;\n    background: linear-gradient(\n      to right,\n      rgba(255, 255, 255, 0),\n      rgba(255, 255, 255, 0.5),\n      rgba(255, 255, 255, 0)\n    );\n    border-radius: 1px;\n    pointer-events: none;\n  }\n  \n  .glass-card {\n    background: linear-gradient(135deg, var(--brand-blue-10), var(--brand-pink-10));\n    backdrop-filter: blur(15px);\n    -webkit-backdrop-filter: blur(15px);\n    border-radius: var(--radius-md);\n    box-shadow: var(--shadow-sm);\n    border: 1px solid var(--brand-black-10);\n    position: relative;\n    z-index: 1;\n    transition: all 0.3s ease;\n    overflow: hidden;\n  }\n  \n  /* Inner glow for glass-card */\n  .glass-card::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 11px; /* 1px smaller than container */\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n  }\n  \n  .glass-panel {\n    background: linear-gradient(\n      135deg, \n      rgba(23, 185, 230, 0.05), \n      rgba(23, 185, 230, 0.02)\n    );\n    backdrop-filter: blur(15px);\n    -webkit-backdrop-filter: blur(15px);\n    border-radius: 12px;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.04); /* Deeper shadows for better separation */\n    border: 1px solid rgba(28, 28, 28, 0.1); /* Darker border with 10% opacity */\n    position: relative;\n    z-index: 1;\n    transition: all 0.3s ease;\n    overflow: hidden;\n  }\n  \n  /* Inner glow for glass-panel */\n  .glass-panel::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 11px; /* 1px smaller than container */\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n  }\n  \n  /* Form container - with blue gradient - enhanced with more contrast */\n  .form-container {\n    background: linear-gradient(135deg, var(--brand-blue-10), var(--brand-pink-10));\n    backdrop-filter: blur(15px);\n    -webkit-backdrop-filter: blur(15px);\n    border-radius: var(--radius-md);\n    box-shadow: var(--shadow-sm);\n    border: 1px solid var(--brand-black-10);\n    overflow: hidden;\n    position: relative;\n    z-index: 1;\n    transform: translateZ(0);\n    padding: var(--spacing-md);\n    transition: all 0.3s ease;\n  }\n  \n  /* Form container inner reflection - enhanced */\n  .form-container::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 1px;\n    background: linear-gradient(\n      to right,\n      rgba(255, 255, 255, 0),\n      rgba(255, 255, 255, 0.6), /* Increased brightness of reflection */\n      rgba(255, 255, 255, 0)\n    );\n    pointer-events: none;\n  }\n  \n  /* Form container subtle inner border for depth */\n  .form-container::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 11px; /* 1px smaller than container */\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n    z-index: -1;\n  }\n  \n  /* Date/time card glass effect with subtle blue accent */\n  .datetime-card {\n    background: var(--white-80);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n    border-radius: var(--radius-sm);\n    border: 1px solid var(--brand-blue-10);\n    transition: all 0.3s ease;\n  }\n  \n  /* Date/time card inner reflection */\n  .datetime-card::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 1px;\n    background: linear-gradient(\n      to right,\n      rgba(255, 255, 255, 0),\n      rgba(255, 255, 255, 0.6),\n      rgba(255, 255, 255, 0)\n    );\n    pointer-events: none;\n  }\n  \n  /* Date/time card subtle inner border for depth */\n  .datetime-card::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 11px; /* 1px smaller than container */\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n    z-index: -1;\n  }\n  \n  /* Logo styling - using Rozha One as specified */\n  .logo-container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    padding-top: 2rem;\n    margin-bottom: 1.5rem;\n    width: 100%;\n    position: relative;\n    z-index: 2;\n  }\n  \n  .logo {\n    font-family: 'Rozha One', serif;\n    font-size: 32px; /* Exact size as specified */\n    letter-spacing: 0.12em; /* Letter spacing for PLAN */\n    color: var(--brand-black);\n    text-shadow: 0 3px 6px rgba(0, 0, 0, 0.18);\n    transition: all 0.3s ease;\n    margin: 0;\n    padding: 0;\n    line-height: 1;\n    position: relative;\n  }\n  \n  /* Create subtle text gradient for logo */\n  .logo::after {\n    content: attr(data-text);\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(45deg, var(--brand-black), #424242);\n    -webkit-background-clip: text;\n    background-clip: text;\n    color: transparent;\n    z-index: -1;\n    opacity: 0.6;\n  }\n  \n  /* Venue swiper glass effect with subtle blue accent */\n  .venue-glass {\n    background: var(--white-80);\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n    border-radius: var(--radius-sm);\n    border: 1px solid var(--brand-blue-10);\n    transition: all 0.3s ease;\n    position: relative;\n    z-index: 1;\n    overflow: hidden;\n  }\n  \n  /* Inner white highlight on venue cards - enhanced reflection */\n  .venue-glass::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 1px;\n    background: linear-gradient(\n      to right,\n      rgba(255, 255, 255, 0),\n      rgba(255, 255, 255, 0.7),\n      rgba(255, 255, 255, 0)\n    );\n    pointer-events: none;\n  }\n  \n  /* Inner border for subtle depth effect */\n  .venue-glass::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 11px; /* 1px smaller than container */\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n    z-index: -1;\n  }\n  \n  .venue-glass:hover {\n    background: linear-gradient(135deg, rgba(23, 185, 230, 0.08), rgba(23, 185, 230, 0.04));\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.06); /* Enhanced shadow on hover */\n    transform: translateY(-2px); /* Subtle lift on hover */\n  }\n  \n  .venue-glass.selected {\n    border: 1px solid var(--brand-blue);\n    box-shadow: 0 0 0 1px rgba(23, 185, 230, 0.3), 0 5px 20px rgba(0, 0, 0, 0.06);\n  }\n  \n  /* Standardized font styling for itinerary cards */\n  .venue-card,\n  .venue-card *,\n  .travel-info,\n  .travel-info *,\n  .export-button {\n    font-family: 'Inter', sans-serif !important;\n  }\n  \n  /* Form elements - refined glass effect for white background */\n  input, textarea, select {\n    background: rgba(255, 255, 255, 0.7) !important;\n    backdrop-filter: blur(15px) !important;\n    -webkit-backdrop-filter: blur(15px) !important;\n    border: 1px solid rgba(23, 185, 230, 0.1) !important;\n    color: var(--brand-black) !important;\n    border-radius: 12px !important;\n    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02) !important;\n    transition: all 0.3s ease !important;\n  }\n  \n  input:focus, textarea:focus, select:focus {\n    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.04), 0 0 0 2px rgba(23, 185, 230, 0.15) !important;\n    border: 1px solid rgba(23, 185, 230, 0.3) !important;\n  }\n  \n  /* Placeholder opacity - set to 65% as specified */\n  ::placeholder {\n    opacity: 0.65 !important;\n  }\n  \n  /* Create Plan button - solid blue (#17B9E6) as per design requirements */\n  .create-plan-btn {\n    background: #17B9E6;\n    color: white;\n    border: none;\n    border-radius: var(--radius-md);\n    padding: var(--spacing-sm) var(--spacing-lg);\n    font-weight: 600;\n    transition: all 0.3s ease;\n    position: relative;\n    overflow: hidden;\n  }\n  \n  .create-plan-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: var(--shadow-md);\n  }\n  \n  .create-plan-btn:disabled {\n    opacity: 0.7;\n    cursor: not-allowed;\n  }\n  \n  /* Navigation arrow buttons - premium look for white background */\n  .nav-arrow {\n    background: linear-gradient(135deg, rgba(23, 185, 230, 0.1), rgba(23, 185, 230, 0.05));\n    backdrop-filter: blur(8px);\n    -webkit-backdrop-filter: blur(8px);\n    border-radius: 50%;\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.04); /* Deeper shadows for better separation */\n    border: 1px solid rgba(28, 28, 28, 0.1); /* Darker border with 10% opacity */\n    opacity: 0;\n    transition: all 0.3s ease;\n    position: relative;\n    overflow: hidden;\n    color: var(--brand-blue);\n  }\n  \n  /* Arrow button reflection */\n  .nav-arrow::before {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 1px;\n    background: linear-gradient(\n      to right,\n      rgba(255, 255, 255, 0),\n      rgba(255, 255, 255, 0.7),\n      rgba(255, 255, 255, 0)\n    );\n    pointer-events: none;\n  }\n  \n  /* Inner glow effect for nav-arrow */\n  .nav-arrow::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 50%;\n    box-shadow: inset 0 0 5px rgba(23, 185, 230, 0.05); /* Subtle blue inner glow */\n    pointer-events: none;\n  }\n  \n  .venue-container:hover .nav-arrow {\n    opacity: 1;\n  }\n  \n  .nav-arrow:hover {\n    background: linear-gradient(135deg, rgba(23, 185, 230, 0.15), rgba(23, 185, 230, 0.08));\n    transform: scale(1.08);\n    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.06); /* Enhanced shadow on hover */\n  }\n  \n  /* Pagination dots */\n  .pagination-dots {\n    display: flex;\n    justify-content: center;\n    margin-top: 1rem;\n    gap: 0.5rem;\n  }\n  \n  .pagination-dot {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: rgba(23, 185, 230, 0.2);\n    transition: all 0.3s ease;\n    border: 1px solid rgba(23, 185, 230, 0.1);\n  }\n  \n  .pagination-dot.active {\n    width: 20px;\n    border-radius: 4px;\n    background: var(--brand-blue);\n  }\n  \n  /* Weather indicators */\n  .weather-indicator {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    padding: 4px 8px;\n    border-radius: 8px;\n    backdrop-filter: blur(10px);\n    -webkit-backdrop-filter: blur(10px);\n    font-size: 0.75rem;\n    font-weight: 500;\n    transition: all 0.2s ease;\n    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.04);\n    border: 1px solid rgba(28, 28, 28, 0.1); /* Consistent with other borders */\n  }\n  \n  /* Inner glow for weather indicators */\n  .weather-indicator::after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    border-radius: 7px; /* 1px smaller than container */\n    box-shadow: inset 0 0 4px rgba(23, 185, 230, 0.05); /* Subtle inner glow */\n    pointer-events: none;\n    z-index: -1;\n  }\n  \n  .weather-indicator-suitable {\n    background: rgba(16, 185, 129, 0.1);\n    color: rgb(6, 95, 70);\n    position: relative;\n  }\n  \n  .weather-indicator-unsuitable {\n    background: rgba(245, 158, 11, 0.1);\n    color: rgb(146, 64, 14);\n    position: relative;\n  }\n  \n  .weather-indicator-recommendation {\n    background: rgba(23, 185, 230, 0.1);\n    color: var(--brand-blue);\n    position: relative;\n  }\n  \n  /* Mobile responsive adjustments */\n  @media (max-width: 640px) {\n    .pagination-dot.active {\n      width: 12px;\n    }\n    \n    .glass-effect, .glass-card, .glass-panel {\n      border-radius: var(--radius-sm);\n    }\n    \n    .glass-effect::after, .glass-card::after, .glass-panel::after {\n      border-radius: 9px;\n    }\n    \n    .venue-glass, .datetime-card, .form-container {\n      border-radius: var(--radius-sm);\n    }\n    \n    .venue-glass::after, .datetime-card::after, .form-container::after {\n      border-radius: 9px;\n    }\n    \n    input, textarea, select, .create-plan-btn {\n      border-radius: 10px !important;\n    }\n    \n    /* Reduce padding for mobile */\n    .form-container, .glass-effect {\n      padding: var(--spacing-sm);\n    }\n    \n    /* Adjust font sizes for mobile */\n    .logo {\n      font-size: 28px;\n    }\n    \n    h1, .heading-primary {\n      font-size: 20px;\n    }\n  }\n}\n\n/* Glass Effect Components */\n.glass-effect {\n  background: linear-gradient(135deg, var(--brand-blue-10), rgba(23, 185, 230, 0.03));\n  backdrop-filter: blur(15px);\n  -webkit-backdrop-filter: blur(15px);\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-sm);\n  border: 1px solid var(--brand-black-10);\n  padding: var(--spacing-md);\n  position: relative;\n  transition: all 0.3s ease;\n  z-index: 1;\n}\n\n.glass-card {\n  background: linear-gradient(135deg, var(--brand-blue-10), rgba(23, 185, 230, 0.03));\n  backdrop-filter: blur(15px);\n  -webkit-backdrop-filter: blur(15px);\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-sm);\n  border: 1px solid var(--brand-black-10);\n  position: relative;\n  z-index: 1;\n  transition: all 0.3s ease;\n  overflow: hidden;\n}\n\n/* Form Elements */\n.form-container {\n  background: linear-gradient(135deg, var(--brand-blue-10), rgba(23, 185, 230, 0.03));\n  backdrop-filter: blur(15px);\n  -webkit-backdrop-filter: blur(15px);\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-sm);\n  border: 1px solid var(--brand-black-10);\n  overflow: hidden;\n  position: relative;\n}\n\n.datetime-card {\n  background: var(--white-80);\n  backdrop-filter: blur(10px);\n  -webkit-backdrop-filter: blur(10px);\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--brand-blue-10);\n  transition: all 0.3s ease;\n}\n\n/* Venue Cards */\n.venue-glass {\n  background: var(--white-80);\n  backdrop-filter: blur(10px);\n  -webkit-backdrop-filter: blur(10px);\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--brand-blue-10);\n  transition: all 0.3s ease;\n}\n\n/* Buttons */\n.create-plan-btn {\n  background: #17B9E6;\n  color: white;\n  border: none;\n  border-radius: var(--radius-md);\n  padding: var(--spacing-sm) var(--spacing-lg);\n  font-weight: 600;\n  transition: all 0.3s ease;\n  position: relative;\n  overflow: hidden;\n}\n\n.create-plan-btn:hover {\n  transform: translateY(-2px);\n  box-shadow: var(--shadow-md);\n}\n\n.create-plan-btn:disabled {\n  opacity: 0.7;\n  cursor: not-allowed;\n}\n\n/* Loading States */\n.loading-spinner {\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n/* Responsive Adjustments */\n@media (max-width: 640px) {\n  .glass-effect, .glass-card {\n    border-radius: var(--radius-sm);\n  }\n  \n  .venue-glass, .datetime-card, .form-container {\n    border-radius: var(--radius-sm);\n  }\n  \n  input, textarea, select, .create-plan-btn {\n    font-size: 16px; /* Prevent zoom on mobile */\n  }\n  \n  .form-container, .glass-effect {\n    padding: var(--spacing-sm);\n  }\n  \n  .logo {\n    font-size: 28px;\n  }\n  \n  h1, .heading-primary {\n    font-size: 20px;\n  }\n}\n\n/* CSS Variables - Design System */\n:root {\n  /* Colors */\n  --color-primary: #17B9E6;\n  --color-text-black: #1C1C1C;\n  --color-text-neutral: #737373;\n  --color-box-bg: #E3E9F2;\n  --color-tag-bg: #BFD4ED;\n  --color-gradient-start: #E3F5FB;\n  --color-gradient-end: #C9EEFA;\n  --color-white: #FFFFFF;\n  --color-brand-blue: #17B9E6;\n\n  /* Typography */\n  --font-heading: 'Rozha One', serif;\n  --font-button: 'Poppins', sans-serif;\n  --font-body: 'Inter', sans-serif;\n\n  /* Spacing */\n  --spacing-xs: 0.25rem;\n  --spacing-sm: 0.5rem;\n  --spacing-md: 1rem;\n  --spacing-lg: 1.5rem;\n  --spacing-xl: 2rem;\n  --spacing-xxl: 3rem;\n\n  /* Border Radius */\n  --radius-sm: 0.25rem;\n  --radius-md: 0.5rem;\n  --radius-lg: 1rem;\n  --radius-full: 9999px;\n\n  /* Box Shadows */\n  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);\n  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);\n  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);\n}\n\n/* Base Styles */\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: var(--font-body);\n  color: var(--color-text-black);\n  background-color: var(--color-white);\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n/* Typography */\nh1, h2, h3 {\n  font-family: var(--font-heading);\n  color: var(--color-text-black);\n}\n\n/* Logo Styles */\n.logo-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  position: relative;\n}\n\n.logo-container h1 {\n  font-family: var(--font-heading);\n  font-size: 2.5rem;\n  color: var(--color-text-black);\n  letter-spacing: 0.05em;\n  line-height: 1;\n  margin: 0;\n  padding: 0;\n}\n\n/* Logo Animation */\n@keyframes logoFloat {\n  0%, 100% {\n    transform: translateY(0);\n  }\n  50% {\n    transform: translateY(-4px);\n  }\n}\n\n.logo-container:hover {\n  animation: logoFloat 2s ease-in-out infinite;\n}\n\n/* Button Styles */\n.button {\n  font-family: var(--font-button);\n  font-weight: 500;\n  padding: var(--spacing-md) var(--spacing-xl);\n  border-radius: var(--radius-md);\n  border: none;\n  cursor: pointer;\n  transition: transform 0.2s ease;\n}\n\n.button-primary {\n  background-color: var(--color-primary);\n  color: var(--color-white);\n}\n\n.button:hover {\n  transform: translateY(-1px);\n}\n\n/* Input Styles */\n.input-box {\n  border: 1px solid transparent;\n  border-radius: var(--radius-md);\n  padding: var(--spacing-md);\n  background: var(--color-box-bg);\n  background-image: linear-gradient(var(--color-box-bg), var(--color-box-bg)),\n    linear-gradient(to right, var(--color-gradient-start), var(--color-gradient-end));\n  background-origin: border-box;\n  background-clip: padding-box, border-box;\n}\n\n/* Tag Styles */\n.tag {\n  font-family: var(--font-body);\n  font-size: 0.875rem;\n  padding: var(--spacing-xs) var(--spacing-sm);\n  background-color: var(--color-tag-bg);\n  border-radius: var(--radius-full);\n  color: var(--color-text-black);\n  display: inline-block;\n}\n\n/* Loading States */\n.loading-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  min-height: 100vh;\n  gap: var(--spacing-lg);\n}\n\n.loading-indicator {\n  width: 40px;\n  height: 40px;\n  border: 3px solid var(--color-box-bg);\n  border-top-color: var(--color-primary);\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n/* Logo Styles */\n.logo {\n  width: 60px;\n  height: auto;\n  margin-bottom: var(--spacing-lg);\n}\n\n/* Venue Card Styles */\n.venue-card {\n  background-color: var(--color-box-bg);\n  border-radius: var(--radius-lg);\n  padding: var(--spacing-lg);\n  margin-bottom: var(--spacing-md);\n}\n\n.venue-name {\n  font-family: var(--font-body);\n  font-weight: 700;\n  font-size: 1.25rem;\n  margin-bottom: var(--spacing-sm);\n}\n\n.venue-details {\n  color: var(--color-text-neutral);\n  font-size: 0.875rem;\n  margin-bottom: var(--spacing-sm);\n}\n\n.venue-tags {\n  display: flex;\n  gap: var(--spacing-xs);\n  flex-wrap: wrap;\n  margin-top: var(--spacing-sm);\n}\n\n/* Travel Time Indicator */\n.travel-time {\n  display: flex;\n  align-items: center;\n  gap: var(--spacing-sm);\n  color: var(--color-text-neutral);\n  font-size: 0.875rem;\n  padding: var(--spacing-sm) var(--spacing-md);\n  background-color: var(--color-tag-bg);\n  border-radius: var(--radius-full);\n  margin: var(--spacing-md) 0;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n  :root {\n    --spacing-xl: 1.5rem;\n    --spacing-xxl: 2rem;\n  }\n\n  .venue-card {\n    padding: var(--spacing-md);\n  }\n}\n\n/* Accessibility */\n@media (prefers-reduced-motion: reduce) {\n  .button,\n  .loading-indicator {\n    animation: none;\n    transition: none;\n  }\n}\n\n/* Tagline text styling to enforce exactly 2 lines */\n.tagline-text {\n  /* Set a fixed height for exactly 2 lines */\n  height: calc(1.4em * 2); /* 1.4 line-height * 2 lines */\n  \n  /* Control line wrapping and prevent overflow */\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  \n  /* Ensure text is centered */\n  text-align: center;\n  \n  /* Responsive font sizing */\n  font-size: clamp(0.85rem, 2.5vw, 1.1rem);\n  line-height: 1.4;\n  \n  /* Add proper container constraints */\n  max-width: 90%;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n/* Media query for tagline on very small screens */\n@media (max-width: 340px) {\n  .tagline-text {\n    font-size: 0.8rem !important;\n  }\n}\n\n/* High Contrast Mode */\n@media (prefers-contrast: high) {\n  :root {\n    --color-text-neutral: #595959;\n    --color-tag-bg: #A6B8D4;\n  }\n}","size_bytes":27133},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { queryClient } from \"./lib/queryClient\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport { Toaster } from '@/components/ui/toaster';\n\n// Import custom fonts\nimport '@fontsource/rozha-one';\nimport '@fontsource/poppins/600.css'; // Import SemiBold variant\n\ncreateRoot(document.getElementById(\"root\")!).render(\n  <QueryClientProvider client={queryClient}>\n    <App />\n    <Toaster />\n  </QueryClientProvider>\n);\n","size_bytes":531},"docs/components/README.md":{"content":"# Component Library Documentation\n\nThis document outlines the core components used in the London Day Planner application, their variants, and usage guidelines.\n\n## Form Components\n\n### DateTimePicker\nA premium date and time selection component that allows users to specify when their day plan should start.\n\nStyling:\n- Clean, minimal calendar interface\n- Smooth dropdown animations\n- Clear visual feedback for selected dates\n- Integrated time selection with 12/24 hour toggle\n\nUsage:\n```jsx\n<DateTimePicker\n  label=\"Start Time\"\n  value={startTime}\n  onChange={handleTimeChange}\n  minTime=\"09:00\"\n  maxTime=\"22:00\"\n/>\n```\n\n### QueryTextarea\nAn enhanced textarea for plan descriptions with intelligent suggestions.\n\nStyling:\n- Generous padding and line height\n- Smooth resize animation\n- Character count indicator\n- Smart placeholder text\n\n## Content Components\n\n### ItineraryTimeline\nA sophisticated timeline view of the planned activities.\n\nStyling:\n- Vertical line connector with gradient\n- Activity cards with hover effects\n- Travel time indicators with icons\n- Smooth entrance animations\n\n### ActivityCard\nDisplays individual activities within the itinerary.\n\nVariants:\n- Standard (museum, gallery, etc.)\n- Dining (restaurants, cafes)\n- Entertainment (theater, music)\n- Transit (walking, transport)\n\n## Feedback Components\n\n### LoadingState\nElegant loading indicators for various states.\n\nVariants:\n- Skeleton loading for content\n- Progress bar for submissions\n- Spinner for quick actions\n\n### Toast Notifications\nInformative toast messages for user feedback.\n\nStyling:\n- Minimal design\n- Smooth entrance/exit\n- Status icons\n- Progress indicator\n\n## Navigation Components\n\n### Header\nMain navigation component with branding.\n\nStyling:\n- Clean, minimal design\n- Subtle background blur\n- Responsive navigation\n- Smooth transitions\n\n### ActionButton\nPrimary interaction buttons throughout the app.\n\nVariants:\n- Primary (solid)\n- Secondary (outline)\n- Tertiary (ghost)\n- Icon button\n\n## Layout Components\n\n### Container\nMain layout wrapper maintaining consistent spacing.\n\nUsage:\n```jsx\n<Container size=\"md\" className=\"py-8\">\n  {children}\n</Container>\n```\n\n### Grid\nFlexible grid system for responsive layouts.\n\nVariants:\n- 1-column (mobile)\n- 2-column (tablet)\n- 3-column (desktop)\n- 4-column (wide)\n\n## Best Practices\n\n1. Component Consistency\n- Use consistent spacing\n- Maintain component hierarchy\n- Follow established patterns\n\n2. Responsive Behavior\n- Test all breakpoints\n- Ensure touch targets\n- Maintain readability\n\n3. Performance\n- Lazy load when possible\n- Optimize animations\n- Minimize rerenders\n\n4. Accessibility\n- Maintain ARIA labels\n- Keyboard navigation\n- Screen reader support\n","size_bytes":2696},"server/data/london-areas.ts":{"content":"import { z } from \"zod\";\n\nexport const areaSchema = z.object({\n  name: z.string(),\n  type: z.enum([\"borough\", \"neighborhood\", \"area\"]),\n  borough: z.string().optional(),\n  characteristics: z.array(z.string()),\n  neighbors: z.array(z.string()),\n  popularFor: z.array(z.string()),\n  crowdLevels: z.object({\n    morning: z.number(),\n    afternoon: z.number(),\n    evening: z.number(),\n    weekend: z.number(),\n  }),\n});\n\nexport type LondonArea = z.infer<typeof areaSchema>;\n\nexport const londonAreas: LondonArea[] = [\n  {\n    name: \"Fitzrovia\",\n    type: \"neighborhood\",\n    borough: \"Camden/Westminster\",\n    characteristics: [\"artsy\", \"mixed-use\", \"historic\"],\n    neighbors: [\"Bloomsbury\", \"Marylebone\", \"Soho\", \"Euston\", \"Oxford Street\"],\n    popularFor: [\"art galleries\", \"media companies\", \"restaurants\", \"pubs\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 4,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Green Park\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"royal park\", \"open space\", \"peaceful\"],\n    neighbors: [\"Mayfair\", \"St. James's\", \"Piccadilly\", \"Buckingham Palace\"],\n    popularFor: [\"picnics\", \"relaxation\", \"walking\", \"royal ceremonies\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 1,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Mayfair\",\n    type: \"neighborhood\",\n    borough: \"Westminster\",\n    characteristics: [\"luxury\", \"upscale\", \"historic\", \"exclusive\"],\n    neighbors: [\"Green Park\", \"Soho\", \"Hyde Park\", \"Marylebone\", \"Piccadilly\", \"St. James's\", \"Oxford Street\", \"Baker Street\"],\n    popularFor: [\"luxury shopping\", \"fine dining\", \"art galleries\", \"hotels\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Soho\",\n    type: \"neighborhood\",\n    borough: \"Westminster\",\n    characteristics: [\"vibrant\", \"nightlife\", \"entertainment\", \"diverse\", \"lively\"],\n    neighbors: [\"Mayfair\", \"Fitzrovia\", \"Chinatown\", \"Covent Garden\", \"Oxford Street\", \"Piccadilly\", \"Leicester Square\", \"Piccadilly Circus\"],\n    popularFor: [\"restaurants\", \"bars\", \"nightclubs\", \"theaters\", \"shopping\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Bloomsbury\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"academic\", \"literary\", \"historic\", \"cultural\"],\n    neighbors: [\"Fitzrovia\", \"King's Cross\", \"Holborn\", \"Russell Square\"],\n    popularFor: [\"museums\", \"universities\", \"bookshops\", \"garden squares\", \"British Museum\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 2,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Covent Garden\",\n    type: \"neighborhood\",\n    borough: \"Westminster/Camden\",\n    characteristics: [\"touristy\", \"shopping\", \"entertainment\", \"vibrant\"],\n    neighbors: [\"Soho\", \"Holborn\", \"Strand\", \"Leicester Square\", \"Chinatown\"],\n    popularFor: [\"market\", \"street performers\", \"theaters\", \"restaurants\", \"shopping\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 5,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Camden Town\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"alternative\", \"diverse\", \"quirky\", \"lively\"],\n    neighbors: [\"Regent's Park\", \"Primrose Hill\", \"Kentish Town\", \"King's Cross\"],\n    popularFor: [\"Camden Market\", \"live music\", \"street food\", \"alternative fashion\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Notting Hill\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea\",\n    characteristics: [\"trendy\", \"upscale\", \"diverse\", \"picturesque\"],\n    neighbors: [\"Holland Park\", \"Bayswater\", \"Kensington\", \"Westbourne Green\"],\n    popularFor: [\"Portobello Road Market\", \"colorful houses\", \"Notting Hill Carnival\", \"cafes\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Shoreditch\",\n    type: \"neighborhood\",\n    borough: \"Hackney/Tower Hamlets\",\n    characteristics: [\"hipster\", \"trendy\", \"artistic\", \"vibrant\"],\n    neighbors: [\"Hoxton\", \"Spitalfields\", \"Old Street\", \"Bethnal Green\", \"City of London\"],\n    popularFor: [\"street art\", \"nightlife\", \"vintage shops\", \"tech startups\", \"food markets\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"South Kensington\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea\",\n    characteristics: [\"upscale\", \"cultural\", \"international\", \"elegant\"],\n    neighbors: [\"Knightsbridge\", \"Chelsea\", \"Kensington\", \"Earl's Court\"],\n    popularFor: [\"museums\", \"embassies\", \"luxury apartments\", \"cafes\", \"French expats\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Brixton\",\n    type: \"neighborhood\",\n    borough: \"Lambeth\",\n    characteristics: [\"diverse\", \"multicultural\", \"vibrant\", \"lively\", \"creative\"],\n    neighbors: [\"Herne Hill\", \"Clapham\", \"Stockwell\", \"Camberwell\"],\n    popularFor: [\"Brixton Market\", \"music venues\", \"Caribbean food\", \"street art\", \"nightlife\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Kensington\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea\",\n    characteristics: [\"upscale\", \"elegant\", \"historic\", \"cultural\"],\n    neighbors: [\"Holland Park\", \"Notting Hill\", \"South Kensington\", \"Hammersmith\", \"Hyde Park\"],\n    popularFor: [\"Kensington Palace\", \"shopping\", \"high-end residences\", \"gardens\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"King's Cross\",\n    type: \"neighborhood\",\n    borough: \"Camden/Islington\",\n    characteristics: [\"regenerated\", \"transport hub\", \"modern\", \"developing\"],\n    neighbors: [\"Camden Town\", \"Bloomsbury\", \"Islington\", \"Euston\"],\n    popularFor: [\"train stations\", \"new developments\", \"food scene\", \"cultural venues\"],\n    crowdLevels: {\n      morning: 5,\n      afternoon: 4,\n      evening: 4,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Hampstead\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"affluent\", \"village-like\", \"historic\", \"intellectual\"],\n    neighbors: [\"Hampstead Heath\", \"Belsize Park\", \"Swiss Cottage\", \"Highgate\"],\n    popularFor: [\"Hampstead Heath\", \"historic pubs\", \"literary connections\", \"upscale living\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Hampstead Heath\",\n    type: \"area\",\n    borough: \"Camden\",\n    characteristics: [\"nature\", \"open space\", \"hills\", \"picturesque\"],\n    neighbors: [\"Hampstead\", \"Highgate\", \"Gospel Oak\", \"East Heath\"],\n    popularFor: [\"swimming ponds\", \"walking\", \"views of London\", \"Parliament Hill\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 2,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Richmond\",\n    type: \"neighborhood\",\n    borough: \"Richmond upon Thames\",\n    characteristics: [\"affluent\", \"riverside\", \"historic\", \"scenic\"],\n    neighbors: [\"Richmond Park\", \"Kew\", \"Twickenham\", \"East Sheen\"],\n    popularFor: [\"Richmond Park\", \"riverside walks\", \"shopping\", \"upscale living\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Richmond Park\",\n    type: \"area\",\n    borough: \"Richmond upon Thames\",\n    characteristics: [\"royal park\", \"nature\", \"wildlife\", \"vast\"],\n    neighbors: [\"Richmond\", \"Kingston\", \"East Sheen\", \"Roehampton\"],\n    popularFor: [\"deer\", \"cycling\", \"walking\", \"nature watching\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 1,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Greenwich\",\n    type: \"neighborhood\",\n    borough: \"Greenwich\",\n    characteristics: [\"historic\", \"maritime\", \"cultural\", \"scenic\"],\n    neighbors: [\"Deptford\", \"Blackheath\", \"Isle of Dogs\", \"Charlton\", \"Canary Wharf\"],\n    popularFor: [\"Royal Observatory\", \"Cutty Sark\", \"Greenwich Market\", \"meridian line\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Canary Wharf\",\n    type: \"area\",\n    borough: \"Tower Hamlets\",\n    characteristics: [\"financial district\", \"modern\", \"business\", \"upscale\"],\n    neighbors: [\"Isle of Dogs\", \"Poplar\", \"Limehouse\", \"Greenwich\"],\n    popularFor: [\"skyscrapers\", \"shopping malls\", \"business centers\", \"waterfront dining\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 3,\n      weekend: 2,\n    },\n  },\n  {\n    name: \"Marylebone\",\n    type: \"neighborhood\",\n    borough: \"Westminster\",\n    characteristics: [\"upscale\", \"elegant\", \"central\", \"sophisticated\"],\n    neighbors: [\"Fitzrovia\", \"Mayfair\", \"Regent's Park\", \"Baker Street\", \"Oxford Street\"],\n    popularFor: [\"Marylebone High Street\", \"dining\", \"boutique shopping\", \"medical facilities\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Chinatown\",\n    type: \"neighborhood\",\n    borough: \"Westminster\",\n    characteristics: [\"cultural\", \"vibrant\", \"bustling\", \"international\"],\n    neighbors: [\"Soho\", \"Leicester Square\", \"Piccadilly Circus\", \"Covent Garden\"],\n    popularFor: [\"Chinese restaurants\", \"Asian supermarkets\", \"cultural celebrations\", \"authentic food\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Oxford Street\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"shopping\", \"busy\", \"commercial\", \"touristy\"],\n    neighbors: [\"Soho\", \"Marylebone\", \"Mayfair\", \"Fitzrovia\", \"Baker Street\"],\n    popularFor: [\"department stores\", \"high street shopping\", \"flagship stores\", \"Christmas lights\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 5,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Piccadilly\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"bustling\", \"central\", \"touristy\", \"iconic\"],\n    neighbors: [\"Green Park\", \"St. James's\", \"Soho\", \"Mayfair\", \"Piccadilly Circus\"],\n    popularFor: [\"Piccadilly Circus\", \"shopping\", \"theaters\", \"restaurants\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 5,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"St. James's\",\n    type: \"neighborhood\",\n    borough: \"Westminster\",\n    characteristics: [\"prestigious\", \"historic\", \"traditional\", \"upscale\"],\n    neighbors: [\"Piccadilly\", \"Green Park\", \"Mayfair\", \"Westminster\"],\n    popularFor: [\"gentlemen's clubs\", \"art galleries\", \"luxury shopping\", \"historic institutions\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 2,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Hyde Park\",\n    type: \"area\",\n    borough: \"Westminster/Kensington and Chelsea\",\n    characteristics: [\"royal park\", \"open space\", \"recreational\", \"scenic\"],\n    neighbors: [\"Mayfair\", \"Kensington\", \"Knightsbridge\", \"Bayswater\"],\n    popularFor: [\"Serpentine lake\", \"Speaker's Corner\", \"winter wonderland\", \"concerts\", \"horse riding\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 2,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Knightsbridge\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea/Westminster\",\n    characteristics: [\"luxury\", \"upscale\", \"international\", \"exclusive\"],\n    neighbors: [\"South Kensington\", \"Hyde Park\", \"Belgravia\", \"Chelsea\"],\n    popularFor: [\"Harrods\", \"Harvey Nichols\", \"luxury boutiques\", \"international residents\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 5,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Holborn\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"legal\", \"business\", \"historic\", \"central\"],\n    neighbors: [\"Covent Garden\", \"Bloomsbury\", \"City of London\", \"Farringdon\", \"Strand\"],\n    popularFor: [\"law firms\", \"business centers\", \"Royal Courts of Justice\", \"historic pubs\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 4,\n      evening: 3,\n      weekend: 2,\n    },\n  },\n  {\n    name: \"Chelsea\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea\",\n    characteristics: [\"upscale\", \"sophisticated\", \"fashionable\", \"artistic\"],\n    neighbors: [\"Knightsbridge\", \"South Kensington\", \"Fulham\", \"Belgravia\", \"Earl's Court\"],\n    popularFor: [\"King's Road shopping\", \"Chelsea Flower Show\", \"luxury homes\", \"football club\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Euston\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"transport hub\", \"urban\", \"busy\", \"commercial\"],\n    neighbors: [\"King's Cross\", \"Fitzrovia\", \"Regent's Park\", \"Somers Town\"],\n    popularFor: [\"Euston Station\", \"businesses\", \"offices\", \"University College London\"],\n    crowdLevels: {\n      morning: 5,\n      afternoon: 4,\n      evening: 3,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Leicester Square\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"touristy\", \"entertainment\", \"bustling\", \"central\"],\n    neighbors: [\"Chinatown\", \"Covent Garden\", \"Piccadilly Circus\", \"Soho\"],\n    popularFor: [\"cinemas\", \"movie premieres\", \"theaters\", \"restaurants\", \"nightlife\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 5,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Regent's Park\",\n    type: \"area\",\n    borough: \"Westminster/Camden\",\n    characteristics: [\"royal park\", \"open space\", \"recreational\", \"scenic\"],\n    neighbors: [\"Camden Town\", \"Marylebone\", \"Baker Street\", \"Primrose Hill\", \"Euston\"],\n    popularFor: [\"London Zoo\", \"boating lake\", \"open air theatre\", \"sports facilities\", \"rose gardens\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 2,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Highgate\",\n    type: \"neighborhood\",\n    borough: \"Haringey/Camden\",\n    characteristics: [\"village-like\", \"historic\", \"upscale\", \"leafy\"],\n    neighbors: [\"Hampstead\", \"Hampstead Heath\", \"Archway\", \"Muswell Hill\"],\n    popularFor: [\"Highgate Cemetery\", \"historic pubs\", \"Kenwood House\", \"village atmosphere\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 2,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Belgravia\",\n    type: \"neighborhood\",\n    borough: \"Westminster/Kensington and Chelsea\",\n    characteristics: [\"luxury\", \"elegant\", \"prestigious\", \"exclusive\"],\n    neighbors: [\"Knightsbridge\", \"Chelsea\", \"Victoria\", \"Pimlico\"],\n    popularFor: [\"embassies\", \"white stucco houses\", \"upscale residences\", \"garden squares\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 2,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Baker Street\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"historic\", \"tourist\", \"commercial\", \"cultural\"],\n    neighbors: [\"Marylebone\", \"Regent's Park\", \"Mayfair\", \"Oxford Street\"],\n    popularFor: [\"Sherlock Holmes Museum\", \"Madame Tussauds\", \"offices\", \"shopping\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Piccadilly Circus\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"iconic\", \"bustling\", \"touristy\", \"landmark\"],\n    neighbors: [\"Piccadilly\", \"Leicester Square\", \"Soho\", \"Chinatown\"],\n    popularFor: [\"digital billboards\", \"Eros statue\", \"meeting point\", \"shopping\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Bayswater\",\n    type: \"neighborhood\",\n    borough: \"Westminster\",\n    characteristics: [\"cosmopolitan\", \"residential\", \"diverse\", \"central\"],\n    neighbors: [\"Notting Hill\", \"Hyde Park\", \"Paddington\", \"Queensway\"],\n    popularFor: [\"hotels\", \"international restaurants\", \"garden squares\", \"shopping\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Primrose Hill\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"affluent\", \"village-like\", \"scenic\", \"trendy\"],\n    neighbors: [\"Camden Town\", \"Regent's Park\", \"Chalk Farm\", \"Swiss Cottage\"],\n    popularFor: [\"viewpoint\", \"celebrity residents\", \"boutique shops\", \"cafes\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Strand\",\n    type: \"area\",\n    borough: \"Westminster/City of London\",\n    characteristics: [\"historic\", \"commercial\", \"cultural\", \"busy\"],\n    neighbors: [\"Covent Garden\", \"Holborn\", \"Embankment\", \"Temple\"],\n    popularFor: [\"theatres\", \"Somerset House\", \"King's College London\", \"historic buildings\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 4,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Earl's Court\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea\",\n    characteristics: [\"diverse\", \"residential\", \"international\", \"central\"],\n    neighbors: [\"South Kensington\", \"West Kensington\", \"Fulham\", \"Chelsea\"],\n    popularFor: [\"exhibition center\", \"budget accommodation\", \"international restaurants\", \"transport hub\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 3,\n      evening: 4,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Holland Park\",\n    type: \"neighborhood\",\n    borough: \"Kensington and Chelsea\",\n    characteristics: [\"upscale\", \"leafy\", \"peaceful\", \"elegant\"],\n    neighbors: [\"Notting Hill\", \"Kensington\", \"Shepherd's Bush\"],\n    popularFor: [\"Holland Park grounds\", \"luxury homes\", \"Kyoto Garden\", \"opera\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 2,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"City of London\",\n    type: \"area\",\n    borough: \"City of London\",\n    characteristics: [\"financial\", \"historic\", \"business\", \"architectural\"],\n    neighbors: [\"Shoreditch\", \"Holborn\", \"Southwark\", \"Tower Hill\"],\n    popularFor: [\"St Paul's Cathedral\", \"financial institutions\", \"historic buildings\", \"museums\"],\n    crowdLevels: {\n      morning: 5,\n      afternoon: 5,\n      evening: 2,\n      weekend: 2,\n    },\n  },\n  {\n    name: \"Islington\",\n    type: \"neighborhood\",\n    borough: \"Islington\",\n    characteristics: [\"trendy\", \"diverse\", \"lively\", \"cultural\"],\n    neighbors: [\"King's Cross\", \"Angel\", \"Highbury\", \"Clerkenwell\"],\n    popularFor: [\"Upper Street shopping\", \"restaurants\", \"theaters\", \"antique shops\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Westminster\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"political\", \"historic\", \"tourist\", \"iconic\"],\n    neighbors: [\"St. James's\", \"Victoria\", \"Pimlico\", \"South Bank\", \"Buckingham Palace\"],\n    popularFor: [\"Houses of Parliament\", \"Westminster Abbey\", \"government buildings\", \"Big Ben\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Kentish Town\",\n    type: \"neighborhood\",\n    borough: \"Camden\",\n    characteristics: [\"residential\", \"diverse\", \"urban\", \"cultural\"],\n    neighbors: [\"Camden Town\", \"Tufnell Park\", \"Gospel Oak\", \"Chalk Farm\"],\n    popularFor: [\"live music venues\", \"gastropubs\", \"residential streets\", \"arts scene\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 3,\n      evening: 4,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Hammersmith\",\n    type: \"neighborhood\",\n    borough: \"Hammersmith and Fulham\",\n    characteristics: [\"riverside\", \"commercial\", \"transport hub\", \"mixed\"],\n    neighbors: [\"Kensington\", \"Fulham\", \"Shepherd's Bush\", \"Chiswick\", \"West Kensington\"],\n    popularFor: [\"Apollo venue\", \"riverside pubs\", \"offices\", \"transport links\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 4,\n      evening: 3,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Buckingham Palace\",\n    type: \"area\",\n    borough: \"Westminster\",\n    characteristics: [\"royal\", \"iconic\", \"historic\", \"ceremonial\"],\n    neighbors: [\"Green Park\", \"St. James's Park\", \"Westminster\", \"Victoria\"],\n    popularFor: [\"royal residence\", \"changing of the guard\", \"state rooms\", \"royal ceremonies\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 2,\n      weekend: 5,\n    },\n  }\n];\n\n// Helper function to find areas by characteristics\nexport function findAreasByCharacteristics(\n  characteristics: string[],\n  excludeAreas: string[] = [],\n): LondonArea[] {\n  return londonAreas.filter(\n    (area) =>\n      !excludeAreas.includes(area.name) &&\n      characteristics.some(\n        (c) => area.characteristics.includes(c) || area.popularFor.includes(c),\n      ),\n  );\n}\n\n// Helper to get crowd level for a specific time\nexport function getAreaCrowdLevel(\n  area: LondonArea,\n  timeOfDay: string,\n  isWeekend: boolean,\n): number {\n  if (isWeekend) return area.crowdLevels.weekend;\n\n  const hour = parseInt(timeOfDay.split(\":\")[0]);\n  if (hour < 12) return area.crowdLevels.morning;\n  if (hour < 17) return area.crowdLevels.afternoon;\n  return area.crowdLevels.evening;\n}\n\n// Helper to find quiet areas\nexport function findQuietAreas(\n  timeOfDay: string,\n  isWeekend: boolean,\n  nearArea?: string,\n): LondonArea[] {\n  const areas = nearArea\n    ? londonAreas.filter((a) => a.neighbors.includes(nearArea))\n    : londonAreas;\n\n  return areas.filter((area) => {\n    const crowdLevel = getAreaCrowdLevel(area, timeOfDay, isWeekend);\n    return crowdLevel <= 2; // Areas with low crowd levels\n  });\n}\n","size_bytes":21609},"server/data/new-york-areas.ts":{"content":"import { z } from \"zod\";\n\nexport const areaSchema = z.object({\n  name: z.string(),\n  type: z.enum([\"borough\", \"neighborhood\", \"area\"]),\n  borough: z.string(),\n  characteristics: z.array(z.string()),\n  neighbors: z.array(z.string()),\n  popularFor: z.array(z.string()),\n  crowdLevels: z.object({\n    morning: z.number(),\n    afternoon: z.number(),\n    evening: z.number(),\n    weekend: z.number(),\n  }),\n});\n\nexport type NYCArea = z.infer<typeof areaSchema>;\n\nexport const nycAreas: NYCArea[] = [\n  {\n    name: \"Manhattan\",\n    type: \"borough\",\n    borough: \"Manhattan\",\n    characteristics: [\"urban\", \"fast-paced\", \"commercial\", \"cultural\"],\n    neighbors: [\"Brooklyn\", \"Queens\", \"Bronx\"],\n    popularFor: [\"skyscrapers\", \"museums\", \"entertainment\", \"finance\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Brooklyn\",\n    type: \"borough\",\n    borough: \"Brooklyn\",\n    characteristics: [\"diverse\", \"trendy\", \"artistic\", \"historic\"],\n    neighbors: [\"Manhattan\", \"Queens\"],\n    popularFor: [\"brownstones\", \"parks\", \"food scene\", \"cultural diversity\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Midtown\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"busy\", \"commercial\", \"touristy\", \"entertainment\"],\n    neighbors: [\"Times Square\", \"Chelsea\", \"Upper East Side\", \"Hell's Kitchen\", \"Murray Hill\"],\n    popularFor: [\"Empire State Building\", \"Times Square\", \"shopping\", \"Broadway shows\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Greenwich Village\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"bohemian\", \"historic\", \"artistic\", \"lively\"],\n    neighbors: [\"SoHo\", \"East Village\", \"West Village\", \"NoHo\", \"Union Square\"],\n    popularFor: [\"NYU campus\", \"Washington Square Park\", \"jazz clubs\", \"historic architecture\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"SoHo\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"trendy\", \"artsy\", \"upscale\", \"shopping\"],\n    neighbors: [\"Greenwich Village\", \"Tribeca\", \"Chinatown\", \"Little Italy\", \"West Village\"],\n    popularFor: [\"designer boutiques\", \"cast-iron architecture\", \"art galleries\", \"upscale dining\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 5,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Upper East Side\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"upscale\", \"sophisticated\", \"traditional\", \"elegant\"],\n    neighbors: [\"Central Park\", \"Midtown\", \"Harlem\", \"Upper West Side\"],\n    popularFor: [\"Museum Mile\", \"luxury apartments\", \"upscale shopping\", \"Central Park access\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Upper West Side\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"residential\", \"cultural\", \"family-friendly\", \"intellectual\"],\n    neighbors: [\"Central Park\", \"Harlem\", \"Midtown\", \"Upper East Side\"],\n    popularFor: [\"Lincoln Center\", \"Natural History Museum\", \"Riverside Park\", \"brownstones\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Central Park\",\n    type: \"area\",\n    borough: \"Manhattan\",\n    characteristics: [\"urban park\", \"scenic\", \"recreational\", \"iconic\"],\n    neighbors: [\"Upper East Side\", \"Upper West Side\", \"Midtown\", \"Harlem\"],\n    popularFor: [\"walking paths\", \"Bethesda Fountain\", \"boating\", \"Central Park Zoo\", \"outdoor concerts\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Williamsburg\",\n    type: \"neighborhood\",\n    borough: \"Brooklyn\",\n    characteristics: [\"hipster\", \"trendy\", \"artistic\", \"gentrified\"],\n    neighbors: [\"Greenpoint\", \"Bushwick\", \"Bedford-Stuyvesant\", \"East Williamsburg\"],\n    popularFor: [\"nightlife\", \"music venues\", \"craft breweries\", \"waterfront views\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Times Square\",\n    type: \"area\",\n    borough: \"Manhattan\",\n    characteristics: [\"touristy\", \"bright\", \"bustling\", \"commercial\"],\n    neighbors: [\"Midtown\", \"Theater District\", \"Hell's Kitchen\", \"Garment District\"],\n    popularFor: [\"Broadway shows\", \"billboards\", \"shopping\", \"New Year's Eve\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  \n  // Lower Manhattan neighborhoods\n  {\n    name: \"Financial District\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"financial\", \"historic\", \"business\", \"tourist\"],\n    neighbors: [\"Tribeca\", \"Chinatown\", \"Battery Park\"],\n    popularFor: [\"Wall Street\", \"One World Trade\", \"Stock Exchange\", \"Battery Park\"],\n    crowdLevels: {\n      morning: 5,\n      afternoon: 5,\n      evening: 2,\n      weekend: 2,\n    },\n  },\n  {\n    name: \"Tribeca\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"upscale\", \"trendy\", \"residential\", \"artistic\"],\n    neighbors: [\"SoHo\", \"Financial District\", \"Chinatown\"],\n    popularFor: [\"restaurants\", \"converted lofts\", \"film festival\", \"art galleries\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 4,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Chinatown\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"cultural\", \"vibrant\", \"historic\", \"food\"],\n    neighbors: [\"Little Italy\", \"Lower East Side\", \"SoHo\", \"Financial District\"],\n    popularFor: [\"dim sum\", \"markets\", \"festivals\", \"authentic Chinese cuisine\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 5,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Little Italy\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"italian\", \"historic\", \"touristy\", \"food\"],\n    neighbors: [\"Chinatown\", \"NoLita\", \"SoHo\", \"Lower East Side\"],\n    popularFor: [\"italian restaurants\", \"San Gennaro Festival\", \"pastry shops\", \"cafes\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Lower East Side\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"historic\", \"trendy\", \"diverse\", \"nightlife\"],\n    neighbors: [\"East Village\", \"Chinatown\", \"NoLita\", \"Two Bridges\"],\n    popularFor: [\"bars\", \"vintage shopping\", \"music venues\", \"tenement museum\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"East Village\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"bohemian\", \"youthful\", \"diverse\", \"artistic\"],\n    neighbors: [\"NoHo\", \"Greenwich Village\", \"Lower East Side\", \"Gramercy\"],\n    popularFor: [\"dive bars\", \"international cuisine\", \"vintage shops\", \"Tompkins Square Park\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 5,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"West Village\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"charming\", \"historic\", \"upscale\", \"quaint\"],\n    neighbors: [\"Greenwich Village\", \"Chelsea\", \"SoHo\", \"Meatpacking District\"],\n    popularFor: [\"brownstones\", \"cobblestone streets\", \"boutiques\", \"quiet restaurants\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Chelsea\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"artistic\", \"trendy\", \"diverse\", \"shopping\"],\n    neighbors: [\"Greenwich Village\", \"Hell's Kitchen\", \"Flatiron District\", \"Meatpacking District\"],\n    popularFor: [\"High Line\", \"art galleries\", \"Chelsea Market\", \"piers\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 4,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Hell's Kitchen\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"diverse\", \"foodie\", \"vibrant\", \"entertainment\"],\n    neighbors: [\"Midtown\", \"Chelsea\", \"Upper West Side\", \"Theater District\"],\n    popularFor: [\"restaurants\", \"theaters\", \"nightlife\", \"riverside parks\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 5,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Flatiron District\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"historic\", \"business\", \"architectural\", \"trendy\"],\n    neighbors: [\"Chelsea\", \"Gramercy\", \"Murray Hill\", \"NoMad\"],\n    popularFor: [\"Flatiron Building\", \"Madison Square Park\", \"shopping\", \"dining\"],\n    crowdLevels: {\n      morning: 4,\n      afternoon: 5,\n      evening: 4,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Gramercy\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"upscale\", \"quiet\", \"residential\", \"historic\"],\n    neighbors: [\"East Village\", \"Flatiron District\", \"Murray Hill\", \"Kips Bay\"],\n    popularFor: [\"Gramercy Park\", \"townhouses\", \"Union Square\", \"restaurants\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 4,\n      evening: 3,\n      weekend: 3,\n    },\n  },\n  {\n    name: \"Harlem\",\n    type: \"neighborhood\",\n    borough: \"Manhattan\",\n    characteristics: [\"historic\", \"cultural\", \"diverse\", \"artistic\"],\n    neighbors: [\"Upper West Side\", \"Upper East Side\", \"East Harlem\", \"Washington Heights\"],\n    popularFor: [\"Apollo Theater\", \"soul food\", \"jazz clubs\", \"historic architecture\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 3,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"DUMBO\",\n    type: \"neighborhood\",\n    borough: \"Brooklyn\",\n    characteristics: [\"trendy\", \"artistic\", \"industrial\", \"waterfront\"],\n    neighbors: [\"Brooklyn Heights\", \"Vinegar Hill\", \"Downtown Brooklyn\"],\n    popularFor: [\"waterfront views\", \"Brooklyn Bridge Park\", \"art galleries\", \"converted warehouses\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 4,\n      evening: 3,\n      weekend: 5,\n    },\n  },\n  {\n    name: \"Brooklyn Heights\",\n    type: \"neighborhood\",\n    borough: \"Brooklyn\",\n    characteristics: [\"historic\", \"upscale\", \"quiet\", \"waterfront\"],\n    neighbors: [\"DUMBO\", \"Downtown Brooklyn\", \"Cobble Hill\"],\n    popularFor: [\"Promenade\", \"historic brownstones\", \"quiet streets\", \"waterfront views\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 2,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Park Slope\",\n    type: \"neighborhood\",\n    borough: \"Brooklyn\",\n    characteristics: [\"family-friendly\", \"historic\", \"residential\", \"foodie\"],\n    neighbors: [\"Prospect Heights\", \"Gowanus\", \"Windsor Terrace\"],\n    popularFor: [\"Prospect Park\", \"brownstones\", \"restaurants\", \"bars\"],\n    crowdLevels: {\n      morning: 3,\n      afternoon: 3,\n      evening: 3,\n      weekend: 4,\n    },\n  },\n  {\n    name: \"Astoria\",\n    type: \"neighborhood\",\n    borough: \"Queens\",\n    characteristics: [\"diverse\", \"cultural\", \"authentic\", \"food\"],\n    neighbors: [\"Long Island City\", \"Woodside\", \"Jackson Heights\"],\n    popularFor: [\"Greek food\", \"Astoria Park\", \"Museum of the Moving Image\", \"beer gardens\"],\n    crowdLevels: {\n      morning: 2,\n      afternoon: 3,\n      evening: 4,\n      weekend: 4,\n    },\n  }\n];\n\n// Helper function to find areas by characteristics\nexport function findAreasByCharacteristics(\n  characteristics: string[],\n  excludeAreas: string[] = [],\n): NYCArea[] {\n  return nycAreas.filter(\n    (area) =>\n      !excludeAreas.includes(area.name) &&\n      characteristics.some(\n        (c) => area.characteristics.includes(c) || area.popularFor.includes(c),\n      ),\n  );\n}\n\n// Helper to get crowd level for a specific time\nexport function getAreaCrowdLevel(\n  area: NYCArea,\n  timeOfDay: string,\n  isWeekend: boolean,\n): number {\n  if (isWeekend) return area.crowdLevels.weekend;\n\n  const hour = parseInt(timeOfDay.split(\":\")[0]);\n  if (hour < 12) return area.crowdLevels.morning;\n  if (hour < 17) return area.crowdLevels.afternoon;\n  return area.crowdLevels.evening;\n}\n\n// Helper to find quiet areas\nexport function findQuietAreas(\n  timeOfDay: string,\n  isWeekend: boolean,\n  nearArea?: string,\n): NYCArea[] {\n  const areas = nearArea\n    ? nycAreas.filter((a) => a.neighbors.includes(nearArea))\n    : nycAreas;\n\n  return areas.filter((area) => {\n    const crowdLevel = getAreaCrowdLevel(area, timeOfDay, isWeekend);\n    return crowdLevel <= 2; // Areas with low crowd levels\n  });\n}","size_bytes":12590},"server/lib/aiAdminRoutes.ts":{"content":"/**\n * AI Admin Routes\n * \n * This module provides admin API endpoints for viewing and analyzing AI logs.\n */\n\nimport { Express, Request, Response } from 'express';\nimport { db } from '../db';\nimport { sql } from 'drizzle-orm';\nimport { aiInteractions } from './aiLogging';\nimport { count } from 'drizzle-orm';\nimport fs from 'fs';\nimport path from 'path';\n\n/**\n * Register admin routes for AI analytics and debugging \n */\nfunction isAdmin(req: Request): boolean {\n  // Check if user has admin role from Replit headers\n  const roles = req.headers['x-replit-user-roles'];\n  return roles?.includes('admin') || false;\n}\n\nfunction requireAdmin(req: Request, res: Response, next: NextFunction) {\n  if (!isAdmin(req)) {\n    return res.status(403).json({ error: 'Unauthorized' });\n  }\n  next();\n}\n\nexport function registerAiAdminRoutes(app: Express): void {\n  // Get all AI logs (paginated, most recent first)\n  app.get('/api/admin/ai-logs', requireAdmin, async (req: Request, res: Response) => {\n    try {\n      const page = parseInt(req.query.page as string) || 0;\n      const limit = parseInt(req.query.limit as string) || 10;\n      const offset = page * limit;\n      \n      // Use different queries for filterable endpoints\n      const modelFilter = req.query.model ? \n        sql`model_name = ${req.query.model}` : \n        sql`1=1`;\n      \n      const statusFilter = req.query.status ? \n        sql`status = ${req.query.status}` : \n        sql`1=1`;\n      \n      // Fetch total count for pagination\n      const totalCountResult = await db\n        .select({ value: count() })\n        .from(aiInteractions)\n        .where(sql`${modelFilter} AND ${statusFilter}`);\n      \n      const totalCount = totalCountResult[0].value;\n      \n      // Fetch logs with pagination\n      const logs = await db\n        .select()\n        .from(aiInteractions)\n        .where(sql`${modelFilter} AND ${statusFilter}`)\n        .orderBy(sql`timestamp DESC`)\n        .limit(limit)\n        .offset(offset);\n      \n      res.json({\n        totalCount,\n        page,\n        limit,\n        logs\n      });\n    } catch (error) {\n      console.error('Error fetching AI logs:', error);\n      res.status(500).json({ error: 'Failed to fetch AI logs' });\n    }\n  });\n  \n  // Get a specific log by ID\n  app.get('/api/admin/ai-logs/:id', async (req: Request, res: Response) => {\n    try {\n      const id = parseInt(req.params.id);\n      \n      if (isNaN(id)) {\n        return res.status(400).json({ error: 'Invalid log ID' });\n      }\n      \n      const log = await db\n        .select()\n        .from(aiInteractions)\n        .where(sql`id = ${id}`)\n        .limit(1);\n      \n      if (log.length === 0) {\n        return res.status(404).json({ error: 'Log not found' });\n      }\n      \n      res.json(log[0]);\n    } catch (error) {\n      console.error('Error fetching AI log by ID:', error);\n      res.status(500).json({ error: 'Failed to fetch AI log' });\n    }\n  });\n  \n  // Get all logs for a specific session\n  app.get('/api/admin/ai-logs/session/:sessionId', async (req: Request, res: Response) => {\n    try {\n      const sessionId = req.params.sessionId;\n      \n      if (!sessionId) {\n        return res.status(400).json({ error: 'Invalid session ID' });\n      }\n      \n      const logs = await db\n        .select()\n        .from(aiInteractions)\n        .where(sql`session_id = ${sessionId}`)\n        .orderBy(sql`timestamp`);\n      \n      res.json({ logs, count: logs.length });\n    } catch (error) {\n      console.error('Error fetching AI logs by session:', error);\n      res.status(500).json({ error: 'Failed to fetch AI logs' });\n    }\n  });\n  \n  // Get statistics about AI usage\n  app.get('/api/admin/ai-stats', async (req: Request, res: Response) => {\n    try {\n      // Count by status\n      const statusCounts = await db\n        .select({\n          status: aiInteractions.status,\n          count: count()\n        })\n        .from(aiInteractions)\n        .groupBy(aiInteractions.status);\n      \n      // Count by model\n      const modelCounts = await db\n        .select({\n          model: aiInteractions.modelName,\n          count: count()\n        })\n        .from(aiInteractions)\n        .groupBy(aiInteractions.modelName);\n      \n      // Average processing time\n      const avgProcessingTime = await db\n        .select({\n          avg: sql<number>`AVG(processing_time_ms)`\n        })\n        .from(aiInteractions)\n        .where(sql`processing_time_ms IS NOT NULL`);\n      \n      // Count by day (last 7 days)\n      const lastWeekLogs = await db\n        .select({\n          date: sql<string>`DATE(timestamp)`,\n          count: count()\n        })\n        .from(aiInteractions)\n        .where(sql`timestamp > NOW() - INTERVAL '7 days'`)\n        .groupBy(sql`DATE(timestamp)`)\n        .orderBy(sql`DATE(timestamp)`);\n      \n      res.json({\n        statusCounts,\n        modelCounts,\n        averageProcessingTime: avgProcessingTime[0]?.avg || 0,\n        lastWeekActivity: lastWeekLogs\n      });\n    } catch (error) {\n      console.error('Error fetching AI statistics:', error);\n      res.status(500).json({ error: 'Failed to fetch AI statistics' });\n    }\n  });\n  \n  // Download log file\n  app.get('/api/admin/ai-logs/file', (req: Request, res: Response) => {\n    try {\n      const logPath = path.join('logs', 'ai-interactions.log');\n      \n      if (!fs.existsSync(logPath)) {\n        return res.status(404).json({ error: 'Log file not found' });\n      }\n      \n      res.setHeader('Content-Type', 'text/plain');\n      res.setHeader('Content-Disposition', 'attachment; filename=\"ai-interactions.log\"');\n      \n      const fileStream = fs.createReadStream(logPath);\n      fileStream.pipe(res);\n    } catch (error) {\n      console.error('Error downloading log file:', error);\n      res.status(500).json({ error: 'Failed to download log file' });\n    }\n  });\n}","size_bytes":5834},"server/lib/aiLogging.ts":{"content":"/**\n * AI Logging System\n * \n * This module provides comprehensive logging for AI interactions in the NYC Day Planner.\n * It captures queries, responses, processing times, and contextual information\n * to help with debugging, analysis, and optimization.\n */\n\nimport { db } from '../db';\nimport { pgTable, serial, text, timestamp, jsonb, integer } from 'drizzle-orm/pg-core';\nimport { createInsertSchema } from 'drizzle-zod';\nimport { z } from 'zod';\nimport { v4 as uuidv4 } from 'uuid';\nimport winston from 'winston';\nimport fs from 'fs';\nimport path from 'path';\n\n// Create logs directory if it doesn't exist\nconst logDir = 'logs';\nif (!fs.existsSync(logDir)) {\n  fs.mkdirSync(logDir);\n}\n\n// Configure Winston logger\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  defaultMeta: { service: 'ai-interaction-logger' },\n  transports: [\n    new winston.transports.File({ filename: path.join(logDir, 'ai-interactions.log') }),\n    new winston.transports.Console({\n      format: winston.format.combine(\n        winston.format.colorize(),\n        winston.format.simple()\n      )\n    })\n  ]\n});\n\n// Define the AI interactions table schema\nexport const aiInteractions = pgTable(\"ai_interactions\", {\n  id: serial(\"id\").primaryKey(),\n  sessionId: text(\"session_id\").notNull(),\n  timestamp: timestamp(\"timestamp\", { withTimezone: true }).defaultNow(),\n  userQuery: text(\"user_query\").notNull(),\n  modelName: text(\"model_name\").notNull(),\n  rawRequest: jsonb(\"raw_request\"),\n  rawResponse: text(\"raw_response\"),\n  parsedResponse: jsonb(\"parsed_response\"),\n  processingTimeMs: integer(\"processing_time_ms\"),\n  status: text(\"status\").notNull(),\n  errorDetails: text(\"error_details\"),\n  parameters: jsonb(\"parameters\"),\n  metaData: jsonb(\"meta_data\")\n});\n\n// Create a schema for inserting data\nexport const insertAiInteractionSchema = createInsertSchema(aiInteractions).omit({ \n  id: true \n});\n\nexport type AiInteraction = typeof aiInteractions.$inferSelect;\nexport type InsertAiInteraction = z.infer<typeof insertAiInteractionSchema>;\n\n/**\n * Log AI interaction to both file and database (if available)\n */\nexport async function logAiInteraction(data: {\n  sessionId: string;\n  userQuery: string;\n  modelName: string;\n  rawRequest?: any;\n  rawResponse?: string;\n  parsedResponse?: any;\n  processingTimeMs?: number;\n  status: 'success' | 'error' | 'warning';\n  errorDetails?: string;\n  parameters?: Record<string, any>;\n  metaData?: Record<string, any>;\n}): Promise<void> {\n  try {\n    // Add timestamp if not provided\n    const logData = {\n      ...data,\n      timestamp: new Date()\n    };\n    \n    // Log to Winston\n    logger.info('AI Interaction', logData);\n    \n    // Insert into database\n    try {\n      await db.insert(aiInteractions).values({\n        sessionId: data.sessionId,\n        userQuery: data.userQuery,\n        modelName: data.modelName,\n        rawRequest: data.rawRequest ? data.rawRequest : null,\n        rawResponse: data.rawResponse || null,\n        parsedResponse: data.parsedResponse ? data.parsedResponse : null,\n        processingTimeMs: data.processingTimeMs || null,\n        status: data.status,\n        errorDetails: data.errorDetails || null,\n        parameters: data.parameters ? data.parameters : null,\n        metaData: data.metaData ? data.metaData : null\n      });\n    } catch (dbError) {\n      console.error('Failed to log AI interaction to database:', dbError);\n      // Continue execution even if database insert fails\n    }\n  } catch (error) {\n    console.error('Error in AI logging:', error);\n  }\n}\n\n/**\n * Create a session ID for tracking interactions in a conversation\n */\nexport function generateSessionId(): string {\n  return uuidv4();\n}\n\n/**\n * Create wrapper for Gemini API calls to automatically log interactions\n */\nexport function withAiLogging<T extends (...args: any[]) => Promise<any>>(\n  fn: T,\n  options: {\n    modelName: string;\n    extractQuery: (args: Parameters<T>) => string;\n    sessionIdGenerator?: () => string;\n  }\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    const startTime = Date.now();\n    const sessionId = options.sessionIdGenerator ? options.sessionIdGenerator() : generateSessionId();\n    const query = options.extractQuery(args);\n    \n    try {\n      const result = await fn(...args);\n      \n      // Log successful interaction\n      await logAiInteraction({\n        sessionId,\n        userQuery: query,\n        modelName: options.modelName,\n        rawRequest: args,\n        parsedResponse: result,\n        processingTimeMs: Date.now() - startTime,\n        status: 'success'\n      });\n      \n      return result;\n    } catch (error) {\n      // Log failed interaction\n      await logAiInteraction({\n        sessionId,\n        userQuery: query,\n        modelName: options.modelName,\n        rawRequest: args,\n        processingTimeMs: Date.now() - startTime,\n        status: 'error',\n        errorDetails: error instanceof Error ? error.message : String(error)\n      });\n      \n      throw error;\n    }\n  };\n}","size_bytes":5091},"server/lib/geminiAdapter.ts":{"content":"import { StructuredRequest } from '@shared/types';\n\n/**\n * Adapter function to convert Gemini response format to the application's format\n */\nexport function convertGeminiToAppFormat(geminiResponse: any): StructuredRequest {\n  console.log(\"Raw Gemini response:\", JSON.stringify(geminiResponse, null, 2));\n  \n  // Initialize the result structure\n  const result: StructuredRequest = {\n    startLocation: geminiResponse.startLocation || \"Central London\", // Default to Central London\n    destinations: [],\n    fixedTimes: [],\n    preferences: {\n      type: undefined,\n      requirements: []\n    }\n  };\n  \n  // Process fixed time entries\n  if (geminiResponse.fixedTimeEntries && Array.isArray(geminiResponse.fixedTimeEntries)) {\n    for (const entry of geminiResponse.fixedTimeEntries) {\n      if (entry && typeof entry === 'object' && entry.location && entry.time) {\n        result.fixedTimes.push({\n          location: entry.location,\n          time: entry.time,\n          type: entry.activity || undefined\n        });\n      }\n    }\n  }\n  \n  // Process flexible time entries - THIS IS THE KEY FIX\n  if (geminiResponse.flexibleTimeEntries && Array.isArray(geminiResponse.flexibleTimeEntries)) {\n    for (const entry of geminiResponse.flexibleTimeEntries) {\n      if (entry && typeof entry === 'object' && entry.location) {\n        // Convert time formats\n        let timeValue = entry.time;\n        \n        // Handle time periods (morning, afternoon, evening)\n        if (timeValue === 'morning') {\n          timeValue = '10:00';\n        } else if (timeValue === 'afternoon') {\n          timeValue = '14:00';\n        } else if (timeValue === 'evening') {\n          timeValue = '18:00';\n        }\n        \n        // Add to fixed times\n        result.fixedTimes.push({\n          location: entry.location,\n          time: timeValue,\n          type: entry.activity || undefined\n        });\n      }\n    }\n  }\n  \n  // Process search parameters if available\n  if (geminiResponse.searchParameters) {\n    // Extract any specific preferences from search parameters\n    if (geminiResponse.searchParameters.venueType) {\n      result.preferences.type = geminiResponse.searchParameters.venueType;\n    }\n    \n    if (geminiResponse.searchParameters.requirements && \n        Array.isArray(geminiResponse.searchParameters.requirements)) {\n      result.preferences.requirements = geminiResponse.searchParameters.requirements;\n    }\n  }\n  \n  // Extract destinations - if we have locations but they're not in fixed times\n  if (geminiResponse.locations && Array.isArray(geminiResponse.locations)) {\n    const fixedLocations = new Set(result.fixedTimes.map((ft: {location: string}) => ft.location));\n    \n    for (const location of geminiResponse.locations) {\n      if (typeof location === 'string' && !fixedLocations.has(location)) {\n        result.destinations.push(location);\n      }\n    }\n  }\n  \n  // Debug logging\n  console.log(\"Converted app format:\", JSON.stringify(result, null, 2));\n  \n  return result;\n}","size_bytes":2990},"server/lib/geminiProcessor.ts":{"content":"/**\n * Gemini Natural Language Processing\n * \n * This module implements a robust, error-tolerant processing system using\n * Google's Gemini AI models to understand and structure itinerary requests.\n */\n\nimport { z } from 'zod';\nimport { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai';\nimport { logAiInteraction, generateSessionId } from './aiLogging';\nimport { getApiKey, isFeatureEnabled } from '../config';\n\n// Define the structured data schema that Gemini should return\nconst FixedTimeEntrySchema = z.object({\n  time: z.string().describe(\"The time for this activity (e.g., '9:00', '15:30')\"),\n  activity: z.string().describe(\"The activity description\"),\n  location: z.string().describe(\"The specific location or area in NYC\"),\n  venue: z.string().optional().describe(\"A specific venue name if mentioned\"),\n  // Also extract venue preference directly from the schema for simpler access\n  venuePreference: z.string().optional().describe(\"EXTRACT THIS FROM THE QUERY: Specific venue type preference (e.g., 'authentic Jewish deli', 'hipster coffee shop', 'traditional Italian restaurant')\"),\n  searchParameters: z.object({\n    cuisine: z.string().optional().describe(\"Type of cuisine if food-related\"),\n    priceLevel: z.enum([\"budget\", \"moderate\", \"expensive\"]).optional().describe(\"Price level preference\"),\n    ambience: z.string().optional().describe(\"Preferred ambience/vibe\"),\n    venueType: z.string().optional().describe(\"Type of venue (pub, restaurant, etc.)\"),\n    specificRequirements: z.array(z.string()).optional().describe(\"Any specific requirements\"),\n    venuePreference: z.string().optional().describe(\"DUPLICATE THIS FROM venuePreference FIELD ABOVE: Specific venue preference (e.g., 'sandwich place', 'sports bar')\"),\n  }).optional().describe(\"IMPORTANT: Use venuePreference for specific venue types like 'hipster coffee shop' or 'authentic Jewish deli'\")\n});\n\n// Define flexible time entry schema - this is for less specific time periods\nconst FlexibleTimeEntrySchema = z.object({\n  time: z.string().describe(\"The time period for this activity (e.g., 'morning', 'afternoon')\"),\n  activity: z.string().describe(\"The activity description\"),\n  location: z.string().describe(\"The specific location or area in NYC\"),\n  venue: z.string().optional().describe(\"A specific venue name if mentioned\"),\n  day: z.string().optional().describe(\"The day for this activity if different from the main date\"),\n  searchParameters: z.object({\n    cuisine: z.string().optional().describe(\"Type of cuisine if food-related\"),\n    priceLevel: z.enum([\"budget\", \"moderate\", \"expensive\"]).optional().describe(\"Price level preference\"),\n    venueType: z.string().optional().describe(\"Type of venue (pub, restaurant, etc.)\"),\n    specificRequirements: z.array(z.string()).optional().describe(\"Any specific requirements\"),\n    venuePreference: z.string().optional().describe(\"Specific venue preference (e.g., 'sandwich place', 'sports bar')\"),\n  }).optional().describe(\"IMPORTANT: Use venuePreference for specific venue types like 'hipster art gallery' or 'authentic Jewish deli'\")\n});\n\nconst StructuredRequestSchema = z.object({\n  date: z.string().optional().describe(\"The date for the itinerary\"),\n  startLocation: z.string().optional().describe(\"Where the day starts\"),\n  endLocation: z.string().optional().describe(\"Where the day ends\"),\n  fixedTimeEntries: z.array(FixedTimeEntrySchema).describe(\"Activities with specific times\"),\n  flexibleTimeEntries: z.array(FlexibleTimeEntrySchema).optional().describe(\"Activities with flexible time periods\"),\n  preferences: z.object({\n    cuisine: z.array(z.string()).optional().describe(\"Preferred cuisines\"),\n    budget: z.enum([\"budget\", \"moderate\", \"expensive\"]).optional().describe(\"Overall budget level\"),\n    pace: z.enum([\"relaxed\", \"moderate\", \"busy\"]).optional().describe(\"Preferred pace of the day\"),\n    interests: z.array(z.string()).optional().describe(\"General interests\"),\n    accessibility: z.array(z.string()).optional().describe(\"Accessibility requirements\"),\n    transportMode: z.array(z.enum([\"walking\", \"tube\", \"bus\", \"taxi\"])).optional().describe(\"Preferred transport modes\"),\n  }).optional(),\n  travelGroup: z.object({\n    adults: z.number().optional().describe(\"Number of adults\"),\n    children: z.number().optional().describe(\"Number of children\"),\n    seniors: z.number().optional().describe(\"Number of seniors\"),\n  }).optional(),\n  specialRequests: z.array(z.string()).optional().describe(\"Any special requests or considerations\"),\n});\n\nexport type FixedTimeEntry = z.infer<typeof FixedTimeEntrySchema>;\nexport type FlexibleTimeEntry = z.infer<typeof FlexibleTimeEntrySchema>;\nexport type StructuredRequest = z.infer<typeof StructuredRequestSchema>;\n\n/**\n * Process a user query using Gemini's natural language understanding\n */\nexport async function processWithGemini(query: string): Promise<StructuredRequest | null> {\n  // Generate session ID for tracking all attempts in this processing chain\n  const sessionId = generateSessionId();\n  \n  // Check if Gemini feature is enabled\n  if (!isFeatureEnabled('USE_GEMINI')) {\n    await logAiInteraction({\n      sessionId,\n      userQuery: query,\n      modelName: 'gemini-1.5-pro',\n      status: 'warning',\n      errorDetails: 'Gemini processing disabled by feature flag'\n    });\n    return null;\n  }\n  \n  // Check API key\n  const apiKey = getApiKey('GEMINI_API_KEY');\n  if (!apiKey) {\n    await logAiInteraction({\n      sessionId,\n      userQuery: query,\n      modelName: 'gemini-1.5-pro',\n      status: 'error',\n      errorDetails: 'Missing Gemini API key'\n    });\n    throw new Error('Missing Gemini API key');\n  }\n  \n  // Try multiple attempts with increasing temperatures for more flexibility\n  const temperatures = [0.2, 0.4, 0.7];\n  let lastError = null;\n  \n  for (const temperature of temperatures) {\n    try {\n      const result = await attemptGeminiProcessing(query, temperature, sessionId);\n      if (result) return result;\n    } catch (error) {\n      lastError = error;\n      console.error(`Gemini processing attempt failed at temperature ${temperature}:`, error);\n      // Continue to next temperature\n    }\n  }\n  \n  // All attempts failed\n  await logAiInteraction({\n    sessionId,\n    userQuery: query,\n    modelName: 'gemini-1.5-pro',\n    status: 'error',\n    errorDetails: lastError ? String(lastError) : 'All processing attempts failed'\n  });\n  \n  return null;\n}\n\n/**\n * Single attempt at processing with Gemini at a specific temperature\n */\nasync function attemptGeminiProcessing(query: string, temperature: number, sessionId?: string): Promise<StructuredRequest | null> {\n  const startTime = Date.now();\n  const apiKey = getApiKey('GEMINI_API_KEY');\n  \n  if (!apiKey) {\n    throw new Error('Missing Gemini API key');\n  }\n  \n  const sessionIdForLogging = sessionId || generateSessionId();\n  const genAI = new GoogleGenerativeAI(apiKey);\n  // The newest Gemini model is \"claude-3-7-sonnet-20250219\" which was released February 24, 2025\n  const model = genAI.getGenerativeModel({ model: \"gemini-1.5-pro-latest\" });\n  \n  try {\n    // Prepare the prompt with schema details and examples\n    const prompt = `\n    You are a travel planning assistant for New York City. Extract structured information from this itinerary request. \n    \n    IMPORTANT RULES:\n    1. Return ONLY valid JSON that matches the schema - no extra text or markdown\n    2. For time values, use 24-hour format (e.g., \"09:00\", \"15:30\") when possible\n    3. If a time is mentioned without AM/PM (e.g., \"at 6\"), default to PM for evening activities like dinner\n    4. For vague meal times: use \"09:00\" for breakfast, \"12:00\" for lunch, and \"19:00\" for dinner unless a specific time is given\n    5. Include all explicitly mentioned fixed times in fixedTimeEntries\n    6. Put activities with vague times (morning, afternoon, evening) in flexibleTimeEntries\n    7. Keep location names authentic to NYC (don't change neighborhood names)\n    8. If the user mentions specific venue requirements, include them in searchParameters\n    9. If the user doesn't specify a budget level, default to \"moderate\"\n    10. Extract as much detail as possible while staying true to the user's request\n    11. For incomplete information, make reasonable assumptions based on context\n    12. Keep activity descriptions concise but clear\n    13. VENUE PREFERENCES: Always capture specific venue preferences when mentioned:\n       - If user specifies a venue type like \"sandwich place\", \"sports bar\", \"authentic Jewish deli\", \"trendy cafe\", include it in searchParameters.venuePreference\n       - Use venuePreference for ANY specific venue descriptions (e.g., \"hipster coffee shop\", \"upscale steakhouse\", \"family-friendly diner\", \"authentic Jamaican restaurant\")\n       - This is different from venueType which should be broader categories like \"restaurant\", \"cafe\", \"bar\"\n       - Examples: for \"I want to get a real NY bagel from an authentic Jewish deli\", set venuePreference to \"authentic Jewish deli\"\n    14. LOCATION HANDLING: For EACH activity in both fixedTimeEntries and flexibleTimeEntries:\n       - You MUST identify a specific NYC location (neighborhood, landmark, station, address)\n       - If the user explicitly provides a valid NYC location (e.g., 'SoHo', 'The Met', 'Times Square', 'Wall St'), use that exact location string\n       - If the user does NOT specify a location OR provides a vague location like 'somewhere', 'anywhere', 'New York', 'nearby', you MUST use the exact string 'Midtown'\n       - The location field must NEVER be null or missing - always provide a valid string value\n    15. SCHEMA COMPLIANCE: Strictly adhere to the JSON schema. Ensure ALL required fields within fixedTimeEntries and flexibleTimeEntries (including time, activity, and location) are present and contain non-null string values.\n    \n    SCHEMA GUIDANCE:\n    - Use fixedTimeEntries for activities with specific clock times (9:00, 14:30, etc.)\n    - Use flexibleTimeEntries for activities with time periods (morning, afternoon, etc.)\n    - Both entry types MUST include: time, activity, location (never null, use 'Midtown' when unspecified)\n    - Always provide reasonable defaults: use '09:00' for breakfast, '12:00' for lunch, '19:00' for dinner\n    - For other activities, use '10:00' for morning, '14:00' for afternoon, '18:00' for evening\n    - Always use 'Midtown' for location if unspecified\n    - Always use searchParameters.venuePreference for specific venue descriptions (e.g., \"sandwich place\", \"trendy bar\")\n\n    Here's the request to analyze:\n    ${query}\n    `;\n    \n    // Send to Gemini\n    const result = await model.generateContent({\n      contents: [{ role: \"user\", parts: [{ text: prompt }] }],\n      generationConfig: {\n        temperature: temperature,\n        maxOutputTokens: 1024,\n      },\n    });\n    \n    const response = result.response;\n    const responseText = response.text();\n    \n    // Extract the JSON from the response\n    let jsonMatch = responseText.match(/```json\\n([\\s\\S]*?)\\n```/) || \n                   responseText.match(/```\\n([\\s\\S]*?)\\n```/) ||\n                   responseText.match(/\\{[\\s\\S]*\\}/);\n                   \n    let jsonText = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : responseText;\n    \n    // Clean up any trailing commas which can break JSON parsing\n    jsonText = jsonText.replace(/,\\s*([}\\]])/g, '$1');\n    \n    try {\n      const parsedData = JSON.parse(jsonText);\n      \n      // Validate against our schema\n      const validationResult = StructuredRequestSchema.safeParse(parsedData);\n      \n      if (validationResult.success) {\n        // Successfully validated\n        const structuredData = validationResult.data;\n        \n        // Additional logging to see the raw response\n        console.log(`Raw Gemini structured data:`, JSON.stringify(structuredData, null, 2));\n        \n        // Log the successful interaction\n        await logAiInteraction({\n          sessionId: sessionIdForLogging,\n          userQuery: query,\n          modelName: 'gemini-1.5-pro',\n          rawRequest: { prompt, temperature },\n          rawResponse: responseText,\n          parsedResponse: structuredData,\n          processingTimeMs: Date.now() - startTime,\n          status: 'success'\n        });\n        \n        // Apply additional processing and return the structured data\n        return processGeminiResponse(query, structuredData, responseText);\n      } else {\n        // Validation failed\n        await logAiInteraction({\n          sessionId: sessionIdForLogging,\n          userQuery: query,\n          modelName: 'gemini-1.5-pro',\n          rawRequest: { prompt, temperature },\n          rawResponse: responseText,\n          status: 'error',\n          processingTimeMs: Date.now() - startTime,\n          errorDetails: `Schema validation error: ${JSON.stringify(validationResult.error)}`,\n          parsedResponse: parsedData  // Include the invalid parsed data for debugging\n        });\n        \n        throw new Error(`Schema validation error: ${validationResult.error.message}`);\n      }\n    } catch (parseError) {\n      // JSON parsing failed\n      await logAiInteraction({\n        sessionId: sessionIdForLogging,\n        userQuery: query,\n        modelName: 'gemini-1.5-pro',\n        rawRequest: { prompt, temperature },\n        rawResponse: responseText,\n        status: 'error',\n        processingTimeMs: Date.now() - startTime,\n        errorDetails: `JSON parsing error: ${parseError}`\n      });\n      \n      throw new Error(`Failed to parse Gemini response as JSON: ${parseError}`);\n    }\n  } catch (error) {\n    // API or processing error\n    await logAiInteraction({\n      sessionId: sessionIdForLogging,\n      userQuery: query,\n      modelName: 'gemini-1.5-pro',\n      rawRequest: { temperature },\n      status: 'error',\n      processingTimeMs: Date.now() - startTime,\n      errorDetails: `API or processing error: ${error}`\n    });\n    \n    throw error;\n  }\n}\n\n/**\n * Process the validated Gemini response into a StructuredRequest\n */\nfunction processGeminiResponse(\n  query: string,\n  validatedData: StructuredRequest,\n  rawResponse: string\n): StructuredRequest {\n  // Create a Set to track unique activity signatures to avoid duplicates\n  const uniqueActivities = new Set<string>();\n  \n  // Make a copy to avoid modifying the original\n  const structuredData: StructuredRequest = {\n    ...validatedData,\n    fixedTimeEntries: [], // We'll rebuild this with de-duplication\n    flexibleTimeEntries: [...(validatedData.flexibleTimeEntries || [])],\n    preferences: validatedData.preferences ? { ...validatedData.preferences } : undefined,\n    travelGroup: validatedData.travelGroup ? { ...validatedData.travelGroup } : undefined,\n    specialRequests: validatedData.specialRequests ? [...validatedData.specialRequests] : undefined\n  };\n\n  console.log(\"Processing Gemini response with raw data:\", JSON.stringify(validatedData, null, 2));\n\n  // Set default start location if not provided\n  if (!structuredData.startLocation) {\n    structuredData.startLocation = \"Midtown\";\n  }\n  \n  // First process fixed time entries with duplicate detection\n  if (validatedData.fixedTimeEntries && validatedData.fixedTimeEntries.length > 0) {\n    console.log(`Processing ${validatedData.fixedTimeEntries.length} fixed time entries with duplicate detection`);\n    \n    for (const entry of validatedData.fixedTimeEntries) {\n      if (entry && entry.location && entry.time && entry.activity) {\n        // Create a unique signature for this activity\n        const activitySignature = `${entry.location}|${entry.time}|${entry.activity}`;\n        \n        // Only add if we haven't seen this exact activity before\n        if (!uniqueActivities.has(activitySignature)) {\n          uniqueActivities.add(activitySignature);\n          structuredData.fixedTimeEntries.push(entry);\n          console.log(`Added fixed time entry: ${entry.activity} at ${entry.location}, ${entry.time}`);\n        } else {\n          console.log(`Skipped duplicate fixed time entry: ${entry.activity} at ${entry.location}, ${entry.time}`);\n        }\n      }\n    }\n  }\n  \n  // Process flexible time entries and convert them to fixed time entries\n  if (structuredData.flexibleTimeEntries && structuredData.flexibleTimeEntries.length > 0) {\n    console.log(`Found ${structuredData.flexibleTimeEntries.length} flexible time entries to process`);\n    \n    // Process each flexible entry with duplicate detection\n    for (const entry of structuredData.flexibleTimeEntries) {\n      // Convert time period names to specific times\n      const convertedTime = convertTo24Hour(entry.time);\n      \n      // Create converted entry\n      const convertedEntry = {\n        ...entry,\n        time: convertedTime\n      };\n      \n      // Create a unique signature for this activity\n      const activitySignature = `${convertedEntry.location}|${convertedEntry.time}|${convertedEntry.activity}`;\n      \n      // Only add if we haven't seen this exact activity before\n      if (!uniqueActivities.has(activitySignature)) {\n        uniqueActivities.add(activitySignature);\n        structuredData.fixedTimeEntries.push(convertedEntry);\n        console.log(`Added flexible time entry to fixedTimes: ${convertedEntry.activity} at ${convertedEntry.location}, ${convertedEntry.time}`);\n      } else {\n        console.log(`Skipped duplicate flexible time entry: ${convertedEntry.activity} at ${convertedEntry.location}, ${convertedEntry.time}`);\n      }\n    }\n  }\n  \n  // Sort fixed time entries chronologically\n  if (structuredData.fixedTimeEntries && structuredData.fixedTimeEntries.length > 0) {\n    structuredData.fixedTimeEntries.sort((a, b) => {\n      // Convert times to 24-hour format for comparison\n      const timeA = convertTo24Hour(a.time);\n      const timeB = convertTo24Hour(b.time);\n      return timeA.localeCompare(timeB);\n    });\n  }\n  \n  // Ensure each fixed time entry has search parameters\n  structuredData.fixedTimeEntries = structuredData.fixedTimeEntries.map(entry => {\n    // SIMPLIFIED: Location defaulting removed - Gemini prompt now ensures valid locations\n    // Original code removed:\n    // if (!entry.location) {\n    //   entry.location = \"Central London\";\n    // }\n    // const vagueLocations = ['somewhere', 'anywhere', 'london', 'nearby'];\n    // if (vagueLocations.includes(entry.location.toLowerCase())) {\n    //   entry.location = \"Central London\";\n    // }\n    \n    // Ensure search parameters object exists\n    if (!entry.searchParameters) {\n      entry.searchParameters = {};\n    }\n    \n    // Apply global preferences to individual entries when appropriate\n    if (structuredData.preferences) {\n      if (structuredData.preferences.budget && !entry.searchParameters.priceLevel) {\n        entry.searchParameters.priceLevel = structuredData.preferences.budget;\n      }\n      \n      // Apply cuisine preferences for food-related activities\n      const foodKeywords = ['lunch', 'dinner', 'breakfast', 'brunch', 'coffee', 'eat', 'dining', 'restaurant', 'cafe', 'food'];\n      const hasCuisinePreferences = structuredData.preferences.cuisine && \n                                  Array.isArray(structuredData.preferences.cuisine) && \n                                  structuredData.preferences.cuisine.length > 0;\n      \n      if (\n        hasCuisinePreferences && \n        foodKeywords.some(keyword => entry.activity.toLowerCase().includes(keyword)) &&\n        !entry.searchParameters.cuisine\n      ) {\n        // Safe to access at index 0 since we've checked array length above\n        entry.searchParameters.cuisine = structuredData.preferences.cuisine![0];\n      }\n    }\n    \n    return entry;\n  });\n  \n  console.log(\"Final processed result:\", JSON.stringify(structuredData, null, 2));\n  return structuredData;\n}\n\n/**\n * Convert time strings to 24-hour format for consistent comparison\n */\nfunction convertTo24Hour(timeStr: string): string {\n  // If already in 24-hour format (e.g., \"14:30\"), return as is\n  if (/^\\d{1,2}:\\d{2}$/.test(timeStr) && !timeStr.includes('am') && !timeStr.includes('pm')) {\n    // Add leading zero if needed\n    const [hours, minutes] = timeStr.split(':').map(Number);\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) {\n      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n    }\n  }\n  \n  // Handle \"3pm\", \"3 pm\", \"3PM\", etc.\n  const pmMatch = timeStr.match(/(\\d{1,2})(?::(\\d{2}))?\\s*(?:pm|PM|p\\.m\\.|P\\.M\\.)/);\n  if (pmMatch) {\n    const hours = parseInt(pmMatch[1]);\n    const minutes = pmMatch[2] ? parseInt(pmMatch[2]) : 0;\n    const adjustedHours = hours === 12 ? 12 : hours + 12;\n    return `${adjustedHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n  }\n  \n  // Handle \"3am\", \"3 am\", \"3AM\", etc.\n  const amMatch = timeStr.match(/(\\d{1,2})(?::(\\d{2}))?\\s*(?:am|AM|a\\.m\\.|A\\.M\\.)/);\n  if (amMatch) {\n    const hours = parseInt(amMatch[1]);\n    const minutes = amMatch[2] ? parseInt(amMatch[2]) : 0;\n    const adjustedHours = hours === 12 ? 0 : hours;\n    return `${adjustedHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n  }\n  \n  // For vague times like \"morning\", \"afternoon\", etc., assign reasonable defaults\n  const timeMapping: Record<string, string> = {\n    'morning': '09:00',\n    'early morning': '07:00',\n    'late morning': '11:00',\n    'noon': '12:00',\n    'midday': '12:00',\n    'afternoon': '14:00',\n    'early afternoon': '13:00',\n    'late afternoon': '16:00',\n    'evening': '18:00',\n    'early evening': '17:00',\n    'late evening': '21:00',\n    'night': '20:00',\n    'midnight': '00:00'\n  };\n  \n  const lowerTimeStr = timeStr.toLowerCase();\n  for (const [key, value] of Object.entries(timeMapping)) {\n    if (lowerTimeStr.includes(key)) {\n      return value;\n    }\n  }\n  \n  // For numeric times without am/pm, make educated guesses\n  const numericMatch = timeStr.match(/^(\\d{1,2})(?::(\\d{2}))?$/);\n  if (numericMatch) {\n    const hours = parseInt(numericMatch[1]);\n    const minutes = numericMatch[2] ? parseInt(numericMatch[2]) : 0;\n    \n    // Assume times 0-6 are early morning (in 24h format)\n    // Assume times 7-11 are morning (in 12h format, so 7AM-11AM)\n    // Assume times 12 is noon (12PM)\n    // Assume times 1-6 are afternoon/evening (in 12h format, so 1PM-6PM)\n    let adjustedHours = hours;\n    if (hours >= 1 && hours <= 6) {\n      adjustedHours = hours + 12; // Convert to PM\n    }\n    \n    return `${adjustedHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n  }\n  \n  // If all else fails, return a default time\n  return '12:00';\n}","size_bytes":22551},"server/lib/googleAuth.ts":{"content":"import { OAuth2Client } from 'google-auth-library';\nimport { getApiKey } from '../config';\n\n// Get the Google Client ID from environment variables\nconst googleClientId = getApiKey('GOOGLE_CLIENT_ID');\n\n// Create a Google OAuth client with the client ID\nconst client = new OAuth2Client(googleClientId);\n\nexport interface GoogleUserInfo {\n  email: string;\n  name: string;\n  sub: string; // This is the Google user ID\n  picture?: string;\n}\n\n/**\n * Verify a Google ID token and extract user information\n * \n * @param token The Google ID token to verify\n * @returns The verified user information from Google\n * @throws Error if the token is invalid\n */\nexport async function verifyGoogleToken(token: string): Promise<GoogleUserInfo> {\n  try {\n    // Verify the token\n    const ticket = await client.verifyIdToken({\n      idToken: token,\n      audience: googleClientId,\n    });\n\n    // Get the payload from the verified token\n    const payload = ticket.getPayload();\n    \n    if (!payload) {\n      throw new Error('Could not get payload from Google token');\n    }\n\n    if (!payload.email || !payload.sub) {\n      throw new Error('Token does not contain required user information');\n    }\n\n    // Return the user information we need\n    return {\n      email: payload.email,\n      name: payload.name || '',\n      sub: payload.sub,\n      picture: payload.picture\n    };\n  } catch (error) {\n    console.error('Google token verification error:', error);\n    throw new Error('Failed to verify Google token');\n  }\n}","size_bytes":1502},"server/lib/googlePlaces.ts":{"content":"import type { PlaceDetails, VenueSearchResult, SearchParameters } from \"@shared/schema\";\nimport { normalizeLocationName, verifyPlaceMatch, suggestSimilarLocations } from \"./locationNormalizer\";\nimport { nycAreas, findAreasByCharacteristics } from \"../data/new-york-areas\";\n\nconst GOOGLE_PLACES_API_KEY = process.env.GOOGLE_PLACES_API_KEY;\nconst PLACES_API_BASE = \"https://maps.googleapis.com/maps/api/place\";\nconst MAX_ALTERNATIVES = 3; // Maximum number of alternative venues to return\n\ninterface SearchOptions {\n  type?: string;\n  openNow?: boolean;\n  minRating?: number;\n  searchTerm?: string;\n  keywords?: string[];\n  requireOpenNow?: boolean;\n  checkReviewsForKeywords?: boolean; // Whether to perform the more intensive review check\n  searchPreference?: string; // Specific venue preference (e.g., \"hipster coffee shop\", \"authentic Jewish deli\")\n}\n\n// Helper function to calculate distance between two points using Haversine formula\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371; // Radius of the earth in km\n  const dLat = (lat2 - lat1) * Math.PI / 180;\n  const dLon = (lon2 - lon1) * Math.PI / 180;\n  const a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * \n    Math.sin(dLon/2) * Math.sin(dLon/2); \n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n  const distance = R * c; // Distance in km\n  return Math.round(distance * 1000) / 1000; // Round to 3 decimal places\n}\n\n// Helper function to fetch place details\nasync function fetchPlaceDetails(placeId: string, includeReviews: boolean = false): Promise<any> {\n  // Add reviews field if requested\n  const fields = includeReviews \n    ? \"name,formatted_address,geometry,opening_hours,business_status,rating,price_level,types,reviews\" \n    : \"name,formatted_address,geometry,opening_hours,business_status,rating,price_level,types\";\n  \n  const detailsUrl = `${PLACES_API_BASE}/details/json?place_id=${placeId}&fields=${fields}&key=${GOOGLE_PLACES_API_KEY}`;\n  const detailsRes = await fetch(detailsUrl);\n  const detailsData = await detailsRes.json();\n  \n  if (detailsData.status !== \"OK\") {\n    throw new Error(`Error fetching details for place ${placeId}.`);\n  }\n  \n  return detailsData.result;\n}\n\n/**\n * Check if any of the place's reviews mention specific keywords\n * Useful for food-specific searches like \"focaccia sandwich\"\n * \n * @param placeId Google Places ID\n * @param keywords List of keywords to look for in reviews\n * @returns Boolean indicating if any keywords were found in reviews\n */\nasync function checkPlaceReviewsForKeywords(placeId: string, keywords: string[]): Promise<boolean> {\n  try {\n    // Get detailed place information including reviews\n    const details = await fetchPlaceDetails(placeId, true);\n    \n    if (!details?.reviews || !Array.isArray(details.reviews)) {\n      return false;\n    }\n    \n    // Check if any keywords appear in review text\n    return details.reviews.some((review: any) => {\n      if (!review.text) return false;\n      const reviewText = review.text.toLowerCase();\n      return keywords.some(keyword => reviewText.includes(keyword.toLowerCase()));\n    });\n  } catch (error) {\n    console.error(\"Error checking reviews:\", error);\n    return false;\n  }\n}\n\nexport async function searchPlace(\n  query: string, \n  options: SearchOptions = {}\n): Promise<VenueSearchResult> {\n  try {\n    console.log(`Search request for query: \"${query}\" with options:`, options);\n    \n    // Add better search term extraction from complex activity types\n    let searchType = options.type;\n    let searchKeyword = '';\n    let keywordsList: string[] = [];\n    \n    // Use search preference as the highest priority if available\n    if (options.searchPreference) {\n      console.log(`VENUE PREFERENCE: Using specific venue preference as primary search term: \"${options.searchPreference}\"`);\n      searchKeyword = options.searchPreference;\n    } \n    // Otherwise use regular searchTerm if available\n    else if (options.searchTerm) {\n      console.log(`VENUE SEARCH: Using searchTerm: \"${options.searchTerm}\"`);\n      searchKeyword = options.searchTerm;\n    } else {\n      // Ensure we have at least a basic search term for all searches\n      console.log(`VENUE SEARCH: Using query as fallback search term: \"${query}\"`);\n      searchKeyword = query;\n    }\n    \n    if (options.keywords && Array.isArray(options.keywords)) {\n      keywordsList = options.keywords;\n    }\n    \n    // If we have a searchPreference, add it to the keywords list as well for maximum effect\n    if (options.searchPreference && (!keywordsList.includes(options.searchPreference))) {\n      if (!keywordsList) keywordsList = [];\n      keywordsList.push(options.searchPreference);\n    }\n\n    // Extract better search terms from complex activity types\n    if (typeof options.type === 'string') {\n      // Map complex activity types to better search terms\n      if (options.type.includes('coffee shop') || options.type.includes('cafe')) {\n        searchType = 'cafe';\n        searchKeyword = 'coffee shop';\n      } else if (options.type.includes('dinner') || options.type.includes('restaurant')) {\n        searchType = 'restaurant';\n        searchKeyword = options.type;\n      } else if (options.type.includes('library')) {\n        searchType = 'library';\n      } else if (options.type.includes('bar') || options.type.includes('pub')) {\n        searchType = 'bar';\n      }\n    }\n    \n    // First check if this matches any of our known areas\n    const matchingArea = nycAreas.find(area => \n      area.name.toLowerCase() === query.toLowerCase() ||\n      area.neighbors.some(n => n.toLowerCase() === query.toLowerCase())\n    );\n\n    // Normalize the location name\n    const normalizedLocation = normalizeLocationName(query);\n    console.log(`Normalized location: ${query} -> ${normalizedLocation}`);\n\n    // Build search query with appropriate context\n    let searchQuery = normalizedLocation;\n    if (!normalizedLocation.toLowerCase().includes('new york')) {\n      // Add more specific context for stations and streets\n      if (normalizedLocation.toLowerCase().includes('station')) {\n        searchQuery = `${normalizedLocation}, Subway Station, New York`;\n      } else if (matchingArea) {\n        searchQuery = `${normalizedLocation}, ${matchingArea.borough || 'New York'}, NY`;\n      } else {\n        searchQuery = `${normalizedLocation}, New York`;\n      }\n    }\n\n    // When searching for an activity type near a landmark, use a two-step approach\n    if (options.type && options.type !== \"landmark\") {\n      console.log(`Searching for ${options.type} near ${searchQuery} (using searchType: ${searchType}, searchKeyword: ${searchKeyword})`);\n\n      // First find the landmark\n      const landmarkParams = new URLSearchParams({\n        query: searchQuery,\n        region: \"us\",\n        key: GOOGLE_PLACES_API_KEY || \"\",\n        language: \"en\",\n        radius: \"5000\"\n      });\n\n      const landmarkUrl = `${PLACES_API_BASE}/textsearch/json?${landmarkParams.toString()}`;\n      const landmarkRes = await fetch(landmarkUrl);\n      const landmarkData = await landmarkRes.json();\n\n      if (landmarkData.status !== \"OK\" || !landmarkData.results?.length) {\n        const suggestions = suggestSimilarLocations(query);\n        throw new Error(\n          `Could not find \"${query}\"${suggestions.length ? `. Did you mean: ${suggestions.join(\", \")}?` : \"\"}. ` +\n          \"Try being more specific or using the full name.\"\n        );\n      }\n\n      // Get the landmark's location\n      const landmark = landmarkData.results[0];\n      const { lat, lng } = landmark.geometry.location;\n\n      // Now search for the activity type near this landmark\n      const nearbyParams = new URLSearchParams({\n        location: `${lat},${lng}`,\n        radius: \"2000\", // 2km radius\n        key: GOOGLE_PLACES_API_KEY || \"\",\n        language: \"en\"\n      });\n\n      // Add proper search parameters\n      if (searchType && searchType !== \"landmark\") {\n        nearbyParams.append(\"type\", searchType);\n      } else if (options.type && options.type !== \"landmark\") {\n        // Fallback to original type if no improved searchType was extracted\n        nearbyParams.append(\"type\", options.type);\n      }\n      \n      // Add keyword for better results\n      if (searchKeyword) {\n        nearbyParams.append(\"keyword\", searchKeyword);\n      }\n      \n      // Use the enhanced keywords list if available\n      if (keywordsList.length > 0) {\n        const combinedKeywords = keywordsList.join(' ');\n        // If we already have a keyword, add the additional keywords with a space\n        if (searchKeyword) {\n          nearbyParams.set(\"keyword\", `${searchKeyword} ${combinedKeywords}`);\n        } else {\n          nearbyParams.append(\"keyword\", combinedKeywords);\n        }\n      }\n\n      // Handle OpenNow parameter - prefer the enhanced requireOpenNow if available\n      if (options.requireOpenNow || options.openNow) {\n        nearbyParams.append(\"opennow\", \"true\");\n      }\n      \n      // Use the enhanced minRating parameter if available\n      if (options.minRating) {\n        nearbyParams.append(\"minRating\", options.minRating.toString());\n      }\n\n      const nearbyUrl = `${PLACES_API_BASE}/nearbysearch/json?${nearbyParams.toString()}`;\n      const nearbyRes = await fetch(nearbyUrl);\n      const nearbyData = await nearbyRes.json();\n\n      if (nearbyData.status !== \"OK\" || !nearbyData.results?.length) {\n        console.log(`No results found for ${options.type} near ${normalizedLocation}. Trying a more generic search...`);\n        \n        // Try a more generic search without the type restriction\n        const fallbackParams = new URLSearchParams({\n          location: `${lat},${lng}`,\n          radius: \"2000\", // 2km radius\n          keyword: searchKeyword || query,\n          key: GOOGLE_PLACES_API_KEY || \"\",\n          language: \"en\"\n        });\n        \n        const fallbackUrl = `${PLACES_API_BASE}/nearbysearch/json?${fallbackParams.toString()}`;\n        const fallbackRes = await fetch(fallbackUrl);\n        const fallbackData = await fallbackRes.json();\n        \n        if (fallbackData.status === \"OK\" && fallbackData.results?.length > 0) {\n          console.log(`Fallback search successful, found ${fallbackData.results.length} results`);\n          nearbyData.results = fallbackData.results;\n        } else {\n          // If we still couldn't find anything, throw an error\n          throw new Error(`No ${options.type || 'venues'} found near ${normalizedLocation}. Try a different location or activity type.`);\n        }\n      }\n\n      // Filter results by rating if specified\n      let results = [...nearbyData.results];\n      if (options.minRating !== undefined) {\n        const minRating = options.minRating; // Store in a constant to avoid the \"possibly undefined\" error\n        const qualifiedResults = results.filter(\n          (r: any) => r.rating >= minRating\n        );\n        if (qualifiedResults.length > 0) {\n          results = qualifiedResults;\n        }\n      }\n      \n      // Check reviews for specific food items or keywords if requested\n      if (options.checkReviewsForKeywords && keywordsList.length > 0) {\n        try {\n          console.log(`Checking reviews for specific keywords: ${keywordsList.join(', ')}`);\n          \n          // Look through the top 10 results for keyword matches in reviews\n          const reviewPromises = results.slice(0, 10).map(async (result) => {\n            const hasKeywords = await checkPlaceReviewsForKeywords(result.place_id, keywordsList);\n            return { result, hasKeywords };\n          });\n          \n          const reviewResults = await Promise.all(reviewPromises);\n          const matchingResults = reviewResults.filter(item => item.hasKeywords).map(item => item.result);\n          \n          // If we found venues with matching reviews, prioritize these results\n          if (matchingResults.length > 0) {\n            console.log(`Found ${matchingResults.length} venues with reviews mentioning keywords`);\n            \n            // Preserve other results but put the matching ones first\n            const nonMatchingResults = results.filter(result => \n              !matchingResults.some(match => match.place_id === result.place_id)\n            );\n            \n            results = [...matchingResults, ...nonMatchingResults];\n          }\n        } catch (error) {\n          console.error(\"Error during review checking:\", error);\n          // Continue with regular search if review checking fails\n        }\n      }\n      \n      // Enhanced type filtering to exclude inappropriate venues\n      if (options.type) {\n        if (options.type === 'cafe' || options.type === 'coffee') {\n          // For cafes/coffee, exclude inappropriate places and prioritize dedicated cafes\n          const filteredResults = results.filter(place => \n            // Exclude inappropriate venues\n            !place.types.includes('gas_station') && \n            !place.types.includes('lodging') &&\n            !place.types.includes('hospital') &&\n            !place.types.includes('car_dealer') &&\n            !place.types.includes('car_rental') &&\n            // Prioritize venues that are actually cafes or restaurants\n            (place.types.includes('cafe') || \n             place.types.includes('restaurant') || \n             place.types.includes('bakery') ||\n             place.types.includes('food'))\n          );\n          \n          // Only use filtered results if we didn't filter everything out\n          if (filteredResults.length > 0) {\n            results = filteredResults;\n          }\n        } else if (options.type === 'restaurant' || options.type === 'lunch' || options.type === 'dinner' || options.type === 'breakfast') {\n          // For food activities, exclude inappropriate venues and prioritize restaurants\n          const filteredResults = results.filter(place => \n            // Exclude inappropriate venues\n            !place.types.includes('gas_station') && \n            !place.types.includes('lodging') &&\n            !place.types.includes('hospital') &&\n            !place.types.includes('car_dealer') &&\n            !place.types.includes('car_rental') &&\n            // At least one of these types should be present\n            (place.types.includes('restaurant') || \n             place.types.includes('meal_takeaway') || \n             place.types.includes('meal_delivery') ||\n             place.types.includes('food'))\n          );\n          \n          if (filteredResults.length > 0) {\n            results = filteredResults;\n          }\n          \n          // Further sort by prioritizing dedicated restaurants\n          results = results.sort((a, b) => {\n            // Calculate relevance score based on venue types\n            const scoreTypes = (types: string[]) => {\n              let score = 0;\n              if (types.includes('restaurant')) score += 5;\n              if (types.includes('food')) score += 3;\n              if (types.includes('meal_takeaway')) score += 2;\n              if (types.includes('cafe')) score += 1;\n              return score;\n            };\n            \n            return scoreTypes(b.types) - scoreTypes(a.types);\n          });\n        } else if (options.type === 'bar' || options.type === 'drinks' || options.type === 'night_club' || options.type === 'nightlife') {\n          // For nightlife venues, prioritize bars and clubs\n          const filteredResults = results.filter(place => \n            !place.types.includes('gas_station') && \n            !place.types.includes('hospital') &&\n            (place.types.includes('bar') || \n             place.types.includes('night_club') ||\n             place.types.includes('restaurant'))\n          );\n          \n          if (filteredResults.length > 0) {\n            results = filteredResults;\n          }\n        }\n        \n        // If we still don't have good results, try a more generic search\n        if (results.length === 0) {\n          // First try with our enhanced keywords if available\n          if (searchKeyword || keywordsList.length > 0) {\n            let finalKeyword = searchKeyword;\n            \n            // If we have additional keywords, use them too\n            if (keywordsList.length > 0) {\n              const combinedKeywords = keywordsList.join(' ');\n              finalKeyword = searchKeyword ? `${searchKeyword} ${combinedKeywords}` : combinedKeywords;\n            }\n            \n            console.log(`All results filtered out, trying generic search with keyword: ${finalKeyword}`);\n            const keywordParams = new URLSearchParams({\n              location: `${lat},${lng}`,\n              radius: \"2000\",\n              keyword: finalKeyword,\n              key: GOOGLE_PLACES_API_KEY || \"\",\n              language: \"en\"\n            });\n            \n            const keywordUrl = `${PLACES_API_BASE}/nearbysearch/json?${keywordParams.toString()}`;\n            const keywordRes = await fetch(keywordUrl);\n            const keywordData = await keywordRes.json();\n            \n            if (keywordData.status === \"OK\" && keywordData.results?.length > 0) {\n              results = keywordData.results;\n              \n              // Apply some basic filtering to these results too\n              results = results.filter(place => \n                !place.types.includes('gas_station') && \n                !place.types.includes('lawyer') &&\n                !place.types.includes('finance')\n              );\n            }\n          }\n          \n          // If still no results or no keyword was available, try with original type\n          if (results.length === 0) {\n            console.log(`No ${options.type} found with strict filtering, using more generic search`);\n            const genericParams = new URLSearchParams({\n              location: `${lat},${lng}`,\n              radius: \"2000\",\n              keyword: options.type,\n              key: GOOGLE_PLACES_API_KEY || \"\",\n              language: \"en\"\n            });\n            \n            const genericUrl = `${PLACES_API_BASE}/nearbysearch/json?${genericParams.toString()}`;\n            const genericRes = await fetch(genericUrl);\n            const genericData = await genericRes.json();\n            \n            if (genericData.status === \"OK\" && genericData.results?.length > 0) {\n              results = genericData.results;\n            }\n          }\n        }\n      }\n      \n      // Limit to maximum results (1 primary + MAX_ALTERNATIVES)\n      results = results.slice(0, 1 + MAX_ALTERNATIVES);\n      \n      if (results.length === 0) {\n        throw new Error(`No ${options.type} found near ${normalizedLocation}. Try a different location or activity type.`);\n      }\n      \n      // Get primary result\n      const primaryResult = results[0];\n      const primaryLat = primaryResult.geometry.location.lat;\n      const primaryLng = primaryResult.geometry.location.lng;\n      \n      // Get details for all venues\n      const primaryDetails = await fetchPlaceDetails(primaryResult.place_id);\n      \n      // Mark as primary and add area info\n      const primary: PlaceDetails = {\n        ...primaryDetails,\n        place_id: primaryResult.place_id,\n        is_primary: true,\n        distance_from_primary: 0,\n        area_info: matchingArea\n      };\n      \n      // Get alternative venues\n      const alternativePromises = results.slice(1).map(async (result) => {\n        const details = await fetchPlaceDetails(result.place_id);\n        \n        // Calculate distance from primary result\n        const distance = calculateDistance(\n          primaryLat, \n          primaryLng,\n          result.geometry.location.lat, \n          result.geometry.location.lng\n        );\n        \n        return {\n          ...details,\n          place_id: result.place_id,\n          is_primary: false,\n          distance_from_primary: distance,\n          area_info: matchingArea\n        };\n      });\n      \n      const alternatives = await Promise.all(alternativePromises);\n      \n      console.log(`Found ${results.length} ${options.type} venues near ${normalizedLocation}:`, {\n        primary: primary.name,\n        alternatives: alternatives.map(a => a.name)\n      });\n      \n      return {\n        primary,\n        alternatives\n      };\n\n    } else {\n      // Regular landmark search\n      const params = new URLSearchParams({\n        query: searchQuery,\n        region: \"us\",\n        key: GOOGLE_PLACES_API_KEY || \"\",\n        language: \"en\",\n        radius: \"50000\" // 50km radius from London center\n      });\n\n      const searchUrl = `${PLACES_API_BASE}/textsearch/json?${params.toString()}`;\n      const searchRes = await fetch(searchUrl);\n      const searchData = await searchRes.json();\n\n      if (searchData.status !== \"OK\" || !searchData.results?.length) {\n        const suggestions = suggestSimilarLocations(query);\n        throw new Error(\n          `Could not find \"${query}\"${suggestions.length ? `. Did you mean: ${suggestions.join(\", \")}?` : \"\"}. ` +\n          \"Try being more specific or using the full name.\"\n        );\n      }\n\n      // Get up to MAX_ALTERNATIVES + 1 results, but handle cases where there are few or no similar alternatives\n      const results = searchData.results.slice(0, 1 + MAX_ALTERNATIVES);\n      // There should always be at least one result if we reach here\n      const primaryResult = results[0];\n      \n      // Verify the primary result matches what was requested\n      if (!verifyPlaceMatch(query, primaryResult.name, primaryResult.types)) {\n        console.warn(`Place match verification warning for \"${query}\". Got \"${primaryResult.name}\" instead.`);\n      }\n      \n      // Get primary landmark details\n      const primaryDetails = await fetchPlaceDetails(primaryResult.place_id);\n      const primaryLat = primaryResult.geometry.location.lat;\n      const primaryLng = primaryResult.geometry.location.lng;\n      \n      // Create primary result object\n      const primary: PlaceDetails = {\n        ...primaryDetails,\n        place_id: primaryResult.place_id,\n        is_primary: true,\n        distance_from_primary: 0,\n        area_info: matchingArea\n      };\n      \n      // Get alternative landmarks\n      const alternativePromises = results.slice(1).map(async (result: any) => {\n        const details = await fetchPlaceDetails(result.place_id);\n        \n        // Calculate distance from primary result\n        const distance = calculateDistance(\n          primaryLat, \n          primaryLng,\n          result.geometry.location.lat, \n          result.geometry.location.lng\n        );\n        \n        return {\n          ...details,\n          place_id: result.place_id,\n          is_primary: false,\n          distance_from_primary: distance,\n          area_info: matchingArea\n        };\n      });\n      \n      const alternatives = await Promise.all(alternativePromises);\n      \n      console.log(`Found landmark \"${primary.name}\" with ${alternatives.length} alternatives`);\n      \n      return {\n        primary,\n        alternatives\n      };\n    }\n  } catch (error) {\n    console.error(`Error searching place \"${query}\":`, error);\n    throw error;\n  }\n}","size_bytes":23148},"server/lib/itinerary.ts":{"content":"import type { PlaceDetails } from \"@shared/schema\";\n\n/**\n * Calculate travel time between two places\n * \n * @param from Starting location\n * @param to Destination location\n * @returns Travel time in minutes\n */\nexport function calculateTravelTime(\n  from: PlaceDetails,\n  to: PlaceDetails\n): number {\n  // Validate input parameters\n  if (!from || !to) {\n    console.warn(\"Missing 'from' or 'to' parameter in calculateTravelTime\");\n    return 30; // Default to 30 minutes\n  }\n\n  // Check for required geometry properties\n  if (!from.geometry?.location || !to.geometry?.location) {\n    console.warn(\"Missing geometry data in calculateTravelTime parameters\");\n    return 30; // Default to 30 minutes\n  }\n\n  // Check for required lat/lng properties\n  const fromLat = from.geometry.location.lat;\n  const fromLng = from.geometry.location.lng;\n  const toLat = to.geometry.location.lat;\n  const toLng = to.geometry.location.lng;\n\n  if (typeof fromLat !== 'number' || typeof fromLng !== 'number' || \n      typeof toLat !== 'number' || typeof toLng !== 'number') {\n    console.warn(\"Invalid coordinate values in calculateTravelTime:\", \n      { fromLat, fromLng, toLat, toLng });\n    return 30; // Default to 30 minutes\n  }\n\n  try {\n    // Simple mock implementation - calculate straight line distance\n    // and assume average speed of 20km/h\n    const R = 6371; // Earth's radius in km\n    \n    const dLat = (toLat - fromLat) * Math.PI / 180;\n    const dLon = (toLng - fromLng) * Math.PI / 180;\n\n    const a = \n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(fromLat * Math.PI / 180) * Math.cos(toLat * Math.PI / 180) * \n      Math.sin(dLon/2) * Math.sin(dLon/2);\n\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    const distance = R * c;\n\n    // Assume average speed of 20km/h\n    const timeInHours = distance / 20;\n    const minutes = Math.round(timeInHours * 60); // Convert to minutes\n    \n    // Add reasonable minimum and maximum constraints\n    if (minutes < 5) return 5; // Minimum travel time of 5 minutes\n    if (minutes > 120) return 120; // Cap at 2 hours\n    \n    return minutes;\n  } catch (error) {\n    console.error(\"Error calculating travel time:\", error);\n    return 30; // Default to 30 minutes in case of calculation error\n  }\n}\n","size_bytes":2264},"server/lib/languageProcessing.ts":{"content":"import { z } from \"zod\";\nimport Fuse from 'fuse.js';\nimport { nycAreas, NYCArea } from \"../data/new-york-areas\";\nimport { ACTIVITY_TYPE_MAPPINGS } from \"./locationNormalizer\";\nimport { parseAndNormalizeTime } from './timeUtils';\n\n// Types for location understanding\nexport type LocationContext = {\n  name: string;\n  type: 'neighborhood' | 'landmark' | 'station' | 'street';\n  confidence: number;\n  alternatives?: string[];\n  context?: {\n    nearbyAreas?: string[];\n    borough?: string;\n    characteristics?: string[];\n  };\n};\n\n// Types for activity understanding\nexport type ActivityContext = {\n  type: string;\n  naturalDescription: string;\n  venueType?: string | null;\n  timeContext?: {\n    preferredTime?: string;\n    duration?: number;\n    constraints?: string[];\n  };\n  requirements?: string[];\n};\n\n// Initialize fuzzy search for locations\nconst locationSearcher = new Fuse(nycAreas, {\n  keys: ['name', 'characteristics', 'neighbors'],\n  includeScore: true,\n  threshold: 0.4\n});\n\n// Time period mappings with flexible ranges\ntype TimePeriod = 'morning' | 'afternoon' | 'evening' | 'night' | 'lunch' | 'dinner' | 'breakfast' | \n                  'late evening' | 'happy hour' | 'after dinner' | 'after work' | 'tea time';\ntype TimeRange = { start: string; end: string; default: string };\n\nconst TIME_PERIODS: Record<TimePeriod, TimeRange> = {\n  morning: { start: '08:00', end: '11:59', default: '10:00' },\n  afternoon: { start: '12:00', end: '16:59', default: '14:00' },\n  evening: { start: '17:00', end: '20:59', default: '18:00' },\n  night: { start: '21:00', end: '23:59', default: '21:00' },\n  lunch: { start: '12:00', end: '14:30', default: '12:30' },\n  dinner: { start: '18:00', end: '21:00', default: '19:00' },\n  breakfast: { start: '07:00', end: '10:30', default: '09:00' },\n  // Additional nightlife periods\n  'late evening': { start: '20:00', end: '23:59', default: '20:00' },\n  'happy hour': { start: '16:00', end: '19:00', default: '17:00' },\n  'after dinner': { start: '20:00', end: '23:59', default: '20:30' },\n  'after work': { start: '17:00', end: '19:00', default: '18:00' },\n  'tea time': { start: '15:00', end: '17:00', default: '16:00' }\n};\n\n// Duration expressions mapping (in minutes)\ntype DurationExpression = 'quick' | 'brief' | 'short' | 'couple hours' | 'few hours' | 'half day' | 'all day';\nconst DURATION_EXPRESSIONS: Record<DurationExpression, number> = {\n  'quick': 30,\n  'brief': 30,\n  'short': 45,\n  'couple hours': 120,\n  'few hours': 180,\n  'half day': 240,\n  'all day': 480\n};\n\n// Helper to find locations with fuzzy matching\nexport function findLocation(query: string): LocationContext | null {\n  try {\n    // First try exact match in our areas data\n    const exactMatch = nycAreas.find((area: NYCArea) => \n      area.name.toLowerCase() === query.toLowerCase()\n    );\n\n    if (exactMatch) {\n      return {\n        name: exactMatch.name,\n        type: 'neighborhood',\n        confidence: 1,\n        context: {\n          nearbyAreas: exactMatch.neighbors,\n          borough: exactMatch.borough,\n          characteristics: exactMatch.characteristics\n        }\n      };\n    }\n\n    // Try fuzzy search\n    const fuzzyResults = locationSearcher.search(query);\n    if (fuzzyResults.length > 0) {\n      const bestMatch = fuzzyResults[0];\n      const item = bestMatch.item as NYCArea;\n      return {\n        name: item.name,\n        type: 'neighborhood',\n        confidence: 1 - (bestMatch.score || 0),\n        alternatives: fuzzyResults.slice(1, 4).map(r => (r.item as NYCArea).name),\n        context: {\n          nearbyAreas: item.neighbors,\n          borough: item.borough,\n          characteristics: item.characteristics\n        }\n      };\n    }\n\n    // No good match found\n    return null;\n\n  } catch (error) {\n    console.error('Error in location finding:', error);\n    return null;\n  }\n}\n\n// Helper to understand activity descriptions\nexport function parseActivity(description: string): ActivityContext {\n  const lowered = description.toLowerCase();\n  \n  // Check for meal-related activities first\n  const isDinner = lowered.includes('dinner');\n  const isLunch = lowered.includes('lunch');\n  \n  // Extract time context\n  const timeMatch = Object.entries(TIME_PERIODS).find(([period]) => \n    lowered.includes(period)\n  );\n\n  // Extract duration\n  const durationMatch = Object.entries(DURATION_EXPRESSIONS).find(([expr]) =>\n    lowered.includes(expr)\n  );\n\n  // Look for specific requirements\n  const requirements = [];\n  if (lowered.includes('quiet') || lowered.includes('peaceful')) requirements.push('quiet');\n  if (lowered.includes('fancy') || lowered.includes('upscale')) requirements.push('upscale');\n  if (lowered.includes('cheap') || lowered.includes('budget')) requirements.push('budget');\n  if (lowered.includes('outdoor') || lowered.includes('outside')) requirements.push('outdoor');\n\n  // Check for non-venue activities - including vague ones\n  const nonVenueActivities = [\n    'meeting', 'arrive', 'depart', 'explore', 'walk', \n    'travel', 'relax', 'break', 'rest', 'something', 'activity',\n    'see', 'visit', 'do', 'experience', 'spend time'\n  ];\n  \n  // Check for non-venue activities (but don't match on dinner/lunch as priority)\n  const isNonVenueActivity = !isDinner && !isLunch && nonVenueActivities.some(activity => \n    lowered.includes(activity)\n  );\n  \n  // Special handling for specific non-venue activities\n  let activityType = 'activity';\n  let suggestedVenueType: string | null = null;\n  \n  if (isNonVenueActivity) {\n    // For meetings, suggest appropriate venue types rather than using 'meeting' as a venue type\n    if (lowered.includes('meeting')) {\n      activityType = 'meeting';\n      // Suggest appropriate venue types based on meeting context\n      if (lowered.includes('coffee') || lowered.includes('casual')) {\n        suggestedVenueType = 'cafe';\n      } else if (lowered.includes('lunch') || lowered.includes('dinner')) {\n        suggestedVenueType = 'restaurant';\n      } else if (lowered.includes('drinks')) {\n        suggestedVenueType = 'bar';\n      } else {\n        // Default suggestion for meetings is cafe\n        suggestedVenueType = 'cafe';\n      }\n    } \n    // For exploration activities\n    else if (lowered.includes('explore')) {\n      activityType = 'explore';\n      if (lowered.includes('park') || lowered.includes('garden')) {\n        suggestedVenueType = 'park';\n      } else if (lowered.includes('shop') || lowered.includes('shopping')) {\n        suggestedVenueType = 'shopping_mall';\n      } else if (lowered.includes('museum') || lowered.includes('culture')) {\n        suggestedVenueType = 'museum';\n      } else if (lowered.includes('history')) {\n        suggestedVenueType = 'tourist_attraction';\n      }\n      // For general exploration, don't suggest a venue type\n    }\n    // For walking activities\n    else if (lowered.includes('walk')) {\n      activityType = 'walk';\n      if (lowered.includes('park')) {\n        suggestedVenueType = 'park';\n      }\n    }\n    // For rest or relaxation activities\n    else if (lowered.includes('relax') || lowered.includes('rest') || lowered.includes('break')) {\n      activityType = 'relax';\n      if (lowered.includes('cafe') || lowered.includes('coffee')) {\n        suggestedVenueType = 'cafe';\n      } else if (lowered.includes('park')) {\n        suggestedVenueType = 'park';\n      } else if (lowered.includes('spa')) {\n        suggestedVenueType = 'spa';\n      }\n    }\n    // For arrival or departure\n    else if (lowered.includes('arrive') || lowered.includes('depart')) {\n      activityType = lowered.includes('arrive') ? 'arrive' : 'depart';\n      // No venue type suggestion for arrival/departure\n    }\n    // For traveling activities\n    else if (lowered.includes('travel')) {\n      activityType = 'travel';\n      // No venue type suggestion for traveling\n    }\n  } else {\n    // For regular venue-based activities, use the existing mapping\n    // Check for specific meal types first\n    if (lowered.includes('dinner')) {\n      activityType = 'dinner';\n      suggestedVenueType = 'restaurant';\n    } else if (lowered.includes('lunch')) {\n      activityType = 'lunch';\n      suggestedVenueType = 'restaurant';\n    } else {\n      const venueTypeEntry = Object.entries(ACTIVITY_TYPE_MAPPINGS).find(([activity]) =>\n        lowered.includes(activity)\n      );\n      \n      if (venueTypeEntry) {\n        activityType = venueTypeEntry[0];\n        suggestedVenueType = venueTypeEntry[1];\n      } else {\n        // Default to generic activity type\n        activityType = 'activity';\n        \n        // Try to infer venue type from activity context\n        if (lowered.includes('food') || lowered.includes('eat')) {\n          suggestedVenueType = 'restaurant';\n        } else if (lowered.includes('visit')) {\n          suggestedVenueType = 'tourist_attraction';\n        }\n      }\n    }\n  }\n\n  return {\n    type: activityType,\n    naturalDescription: description,\n    venueType: suggestedVenueType, // Now allows string | null | undefined\n    timeContext: {\n      preferredTime: timeMatch?.[1].default,\n      duration: durationMatch?.[1],\n      constraints: timeMatch ? [`prefer_${timeMatch[0]}`] : undefined\n    },\n    requirements: requirements.length > 0 ? requirements : []\n  };\n}\n\n/**\n * Function to handle relative time periods with comprehensive parsing\n * This uses our new timeUtils for consistent time handling across the application\n * \n * @param timeString The time expression to parse (e.g., \"morning\", \"6pm\", \"at 3\")\n * @returns Normalized 24-hour time string (HH:MM)\n */\nexport function expandRelativeTime(timeString: string): string {\n  if (!timeString) return timeString;\n  \n  // Use our comprehensive time parsing utility to handle all time formats consistently\n  try {\n    return parseAndNormalizeTime(timeString);\n  } catch (error) {\n    console.warn(`Error parsing time: ${timeString}`, error);\n    return timeString; // Return original if parsing fails\n  }\n}\n\n// Helper to parse natural time expressions\nexport function parseTimeExpression(expression: string): {\n  time?: string;\n  endTime?: string;\n  duration?: number;\n  period?: string;\n  isRange?: boolean;\n} {\n  const lowered = expression.toLowerCase().trim();\n  \n  // Check for special midnight patterns first before doing any other processing\n  if (lowered === \"from 9pm until midnight\") {\n    return {\n      time: \"21:00\",\n      endTime: \"00:00\", \n      isRange: true\n    };\n  }\n  \n  if (lowered === \"from 8pm to midnight\") {\n    return {\n      time: \"20:00\",\n      endTime: \"00:00\",\n      isRange: true\n    };\n  }\n  \n  // Skip relative time expansion for range expressions\n  // This allows us to properly handle patterns like \"from X to noon\"\n  if (!expression.includes(\"-\") && !expression.includes(\"to\") && !expression.includes(\"between\") && \n      !expression.includes(\"until\")) {\n    const expandedTime = expandRelativeTime(expression);\n    if (expandedTime !== expression) {\n      return {\n        time: expandedTime,\n        period: expression.toLowerCase().trim()\n      };\n    }\n  }\n  \n  // Generic until midnight handler - will only catch patterns not exactly matching the special cases above\n  if ((lowered.includes(\"until midnight\") || lowered.includes(\"till midnight\")) && \n      lowered !== \"from 9pm until midnight\" && \n      !lowered.includes(\"from 8pm to midnight\")) {\n    const timePattern = /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n    const match = lowered.match(timePattern);\n    \n    if (match) {\n      const [_, startHours, startMinutes = \"00\", startMeridian] = match;\n      let startHour = parseInt(startHours);\n      \n      // Handle meridian (am/pm)\n      if (startMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n      if (startMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n      \n      return {\n        time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n        endTime: \"00:00\",\n        isRange: true\n      };\n    }\n  }\n\n  // Check for special time words\n  if (lowered === 'noon') {\n    return {\n      time: '12:00',\n      period: 'noon'\n    };\n  }\n  \n  if (lowered === 'midnight') {\n    return {\n      time: '00:00',\n      period: 'night'\n    };\n  }\n\n  // Check for time periods\n  const periodMatch = Object.entries(TIME_PERIODS).find(([period]) => \n    lowered.includes(period)\n  );\n  if (periodMatch) {\n    return {\n      time: periodMatch[1].default,\n      period: periodMatch[0]\n    };\n  }\n\n  // Check for duration expressions\n  const durationMatch = Object.entries(DURATION_EXPRESSIONS).find(([expr]) =>\n    lowered.includes(expr)\n  );\n  if (durationMatch) {\n    return {\n      duration: durationMatch[1]\n    };\n  }\n\n  // Handle time ranges\n  // Pattern 1: \"between X and Y\"\n  const betweenPattern = /between\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?\\s+and\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n  const betweenMatch = lowered.match(betweenPattern);\n  \n  if (betweenMatch) {\n    const [_, startHours, startMinutes = \"00\", startMeridian, endHours, endMinutes = \"00\", endMeridian] = betweenMatch;\n    \n    let startHour = parseInt(startHours);\n    let endHour = parseInt(endHours);\n    \n    // Handle meridian (am/pm)\n    // If end has meridian but start doesn't, apply the same meridian to start\n    const effectiveStartMeridian = startMeridian || endMeridian || '';\n    const effectiveEndMeridian = endMeridian || '';\n    \n    if (effectiveStartMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n    if (effectiveStartMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n    \n    if (effectiveEndMeridian?.toLowerCase() === \"pm\" && endHour < 12) endHour += 12;\n    if (effectiveEndMeridian?.toLowerCase() === \"am\" && endHour === 12) endHour = 0;\n    \n    return {\n      time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n      endTime: `${endHour.toString().padStart(2, '0')}:${endMinutes}`,\n      isRange: true\n    };\n  }\n  \n  // Direct handling of special cases to ensure they are caught first\n  if (lowered.includes(\"from\") && lowered.includes(\"to noon\")) {\n    const timePattern = /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n    const match = lowered.match(timePattern);\n    \n    if (match) {\n      const [_, startHours, startMinutes = \"00\", startMeridian] = match;\n      let startHour = parseInt(startHours);\n      \n      // Handle meridian (am/pm)\n      if (startMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n      if (startMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n      \n      return {\n        time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n        endTime: \"12:00\",\n        isRange: true\n      };\n    }\n  }\n  \n  if (lowered.includes(\"from\") && lowered.includes(\"to midnight\")) {\n    // Check for this exact pattern with a more specific regex to ensure it's matched first\n    const exactPattern = /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?\\s+to\\s+midnight\\b/i;\n    if (exactPattern.test(lowered)) {\n      const timePattern = /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n      const match = lowered.match(timePattern);\n      \n      if (match) {\n        const [_, startHours, startMinutes = \"00\", startMeridian] = match;\n        let startHour = parseInt(startHours);\n        \n        // Handle meridian (am/pm)\n        if (startMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n        if (startMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n        \n        return {\n          time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n          endTime: \"00:00\",\n          isRange: true\n        };\n      }\n    }\n  }\n  \n  // Pattern 2: \"from X to Y\" with special handling for other special time words\n  if (lowered.includes(\"from\") && lowered.includes(\"to\")) {\n    // Define special time words and their corresponding 24-hour time values\n    const specialEndTimes: Record<string, string> = {\n      \"midday\": \"12:00\",\n      \"midnight\": \"00:00\",\n      \"morning\": \"10:00\",\n      \"afternoon\": \"14:00\",\n      \"evening\": \"18:00\",\n      \"night\": \"20:00\",\n      \"lunch\": \"12:30\",\n      \"dinner\": \"19:00\",\n      \"breakfast\": \"08:30\"\n    };\n    \n    // Look for \"from X to SPECIAL_TIME\" patterns\n    for (const [timeWord, timeValue] of Object.entries(specialEndTimes)) {\n      // Use exact word boundaries to ensure we match exact time words\n      const endTimePattern = new RegExp(`to\\\\s+${timeWord}\\\\b`, 'i');\n      if (endTimePattern.test(lowered)) {\n        const timePattern = /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n        const match = lowered.match(timePattern);\n        \n        if (match) {\n          const [_, startHours, startMinutes = \"00\", startMeridian] = match;\n          let startHour = parseInt(startHours);\n          \n          // Handle meridian (am/pm)\n          if (startMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n          if (startMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n          \n          return {\n            time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n            endTime: timeValue,\n            isRange: true\n          };\n        }\n      }\n    }\n  }\n  \n  // Standard \"from X to Y\" pattern with numeric times\n  const fromToPattern = /from\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?\\s+to\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?|to\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n  const fromToMatch = lowered.match(fromToPattern);\n  \n  if (fromToMatch) {\n    // Check if we matched the \"from X to Y\" pattern or just \"to Y\"\n    const fullMatch = fromToMatch[1] !== undefined;\n    \n    if (fullMatch) {\n      const [_, startHours, startMinutes = \"00\", startMeridian, endHours, endMinutes = \"00\", endMeridian] = fromToMatch;\n      \n      let startHour = parseInt(startHours);\n      let endHour = parseInt(endHours);\n      \n      // Handle meridian (am/pm) similar to above\n      const effectiveStartMeridian = startMeridian || endMeridian || '';\n      const effectiveEndMeridian = endMeridian || '';\n      \n      if (effectiveStartMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n      if (effectiveStartMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n      \n      if (effectiveEndMeridian?.toLowerCase() === \"pm\" && endHour < 12) endHour += 12;\n      if (effectiveEndMeridian?.toLowerCase() === \"am\" && endHour === 12) endHour = 0;\n      \n      return {\n        time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n        endTime: `${endHour.toString().padStart(2, '0')}:${endMinutes}`,\n        isRange: true\n      };\n    }\n  }\n  \n  // Pattern 3: \"X-Y\" (e.g., \"3-5pm\")\n  // Handle the pattern where each time may have its own meridian indicator\n  const rangeWithSeparateMeridianPattern = /(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?\\s*-\\s*(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i;\n  const rangeWithSeparateMeridianMatch = lowered.match(rangeWithSeparateMeridianPattern);\n  \n  if (rangeWithSeparateMeridianMatch) {\n    const [_, startHours, startMinutes = \"00\", startMeridian, endHours, endMinutes = \"00\", endMeridian] = rangeWithSeparateMeridianMatch;\n    \n    let startHour = parseInt(startHours);\n    let endHour = parseInt(endHours);\n    \n    // Handle meridian indicators - if end has one but start doesn't, apply the same to start\n    const effectiveStartMeridian = startMeridian || endMeridian || '';\n    const effectiveEndMeridian = endMeridian || startMeridian || '';\n    \n    if (effectiveStartMeridian?.toLowerCase() === \"pm\" && startHour < 12) startHour += 12;\n    if (effectiveStartMeridian?.toLowerCase() === \"am\" && startHour === 12) startHour = 0;\n    \n    if (effectiveEndMeridian?.toLowerCase() === \"pm\" && endHour < 12) endHour += 12;\n    if (effectiveEndMeridian?.toLowerCase() === \"am\" && endHour === 12) endHour = 0;\n    \n    // If no meridian indicators at all, make a reasonable guess\n    // If both hours are < 12, and the second is greater than the first, \n    // assume both are in the same half of the day\n    if (!startMeridian && !endMeridian) {\n      // If both times are in the 1-11 range\n      if (startHour >= 1 && startHour < 12 && endHour >= 1 && endHour < 12) {\n        // If start time is later than end time (e.g., 10-3), assume crossing AM/PM boundary\n        if (startHour > endHour) {\n          // Start is AM, end is PM\n          endHour += 12;\n        }\n        // Otherwise both in same half of day, which we'll determine based on typical activity hours\n        // Most activities happen between 9am-10pm, so we'll assume that range\n        else if (startHour >= 9 || endHour <= 10) {\n          // Do nothing - both times are likely AM\n        }\n        else {\n          // Otherwise assume both PM (e.g., 2-5 more likely means 2pm-5pm)\n          startHour += 12;\n          endHour += 12;\n        }\n      }\n    }\n    \n    return {\n      time: `${startHour.toString().padStart(2, '0')}:${startMinutes}`,\n      endTime: `${endHour.toString().padStart(2, '0')}:${endMinutes}`,\n      isRange: true\n    };\n  }\n\n  // Standard time pattern (if no range patterns match)\n  const timeMatch = lowered.match(/(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i);\n  if (timeMatch) {\n    let [_, hours, minutes = \"00\", meridian] = timeMatch;\n    let hour = parseInt(hours);\n\n    if (meridian?.toLowerCase() === \"pm\" && hour < 12) hour += 12;\n    if (meridian?.toLowerCase() === \"am\" && hour === 12) hour = 0;\n\n    return {\n      time: `${hour.toString().padStart(2, '0')}:${minutes}`\n    };\n  }\n\n  // Return empty object if no pattern matches\n  return {};\n}\n\n// Contextual time defaulting with activity-specific logic\nexport function getDefaultTime(activity: string, currentTime?: Date): string {\n  const now = currentTime || new Date();\n  const hour = now.getHours();\n  \n  const lowered = activity.toLowerCase().trim();\n  \n  // Mealtime activities\n  if (lowered.includes('breakfast')) {\n    return hour < 10 ? '09:00' : '10:00';\n  }\n  \n  if (lowered.includes('lunch')) {\n    return hour < 13 ? '12:30' : '13:30';\n  }\n  \n  if (lowered.includes('dinner')) {\n    return hour < 19 ? '19:00' : '20:00';\n  }\n  \n  // Coffee is typically a morning/afternoon activity\n  if (lowered.includes('coffee') || lowered.includes('cafe')) {\n    if (hour < 11) return '10:30'; // Mid-morning coffee\n    if (hour < 15) return '14:00'; // Afternoon coffee\n    if (hour < 18) return '16:00'; // Late afternoon coffee\n    return '10:30';  // Default to morning coffee for next day if asked at night\n  }\n  \n  // Drinks/Bar activities are typically evening activities\n  if (lowered.includes('drinks') || lowered.includes('bar') || lowered.includes('pub')) {\n    if (hour < 17) return '18:00'; // Early evening drinks\n    if (hour < 20) return '19:30'; // Prime time drinks\n    return '21:00';  // Late evening drinks\n  }\n  \n  // Late night/club activities\n  if (lowered.includes('nightclub') || lowered.includes('club') || \n      lowered.includes('bar hop') || lowered.includes('night out')) {\n    if (hour < 20) return '21:00'; // Typical starting time for nightlife\n    if (hour < 23) return '22:30'; // Late start\n    return '22:00';  // Default to earlier next day if asked very late\n  }\n  \n  // Shopping activities\n  if (lowered.includes('shop') || lowered.includes('store') || lowered.includes('mall')) {\n    if (hour < 12) return '11:00'; // Late morning shopping\n    if (hour < 17) return '14:00'; // Afternoon shopping\n    return '11:00';  // Default to morning shopping for next day if asked late\n  }\n  \n  // Museum/Cultural activities\n  if (lowered.includes('museum') || lowered.includes('gallery') || \n      lowered.includes('exhibition') || lowered.includes('cultural')) {\n    if (hour < 12) return '11:00'; // Late morning visit\n    if (hour < 16) return '14:00'; // Afternoon visit\n    return '11:00';  // Default to morning for next day if asked late\n  }\n  \n  // Park/Outdoor activities\n  if (lowered.includes('park') || lowered.includes('garden') || \n      lowered.includes('walk') || lowered.includes('outdoor')) {\n    if (hour < 12) return '11:00'; // Late morning\n    if (hour < 15) return '14:00'; // Afternoon\n    if (hour < 18) return '16:00'; // Late afternoon (avoid evening in winter)\n    return '11:00';  // Default to morning for next day if asked late\n  }\n  \n  // Default based on current time of day (for generic activities)\n  if (hour < 11) return '10:00';  // Morning activities\n  if (hour < 14) return '13:00';  // Lunch/early afternoon activities\n  if (hour < 17) return '15:00';  // Afternoon activities\n  if (hour < 20) return '19:00';  // Early evening activities\n  return '20:00';                 // Late evening activities\n}\n","size_bytes":24555},"server/lib/locationNormalizer.ts":{"content":"import { nycAreas, NYCArea } from \"../data/new-york-areas\";\n\n// Dictionary of neighborhood name variations and colloquial references\n// This helps match common ways people refer to neighborhoods\nconst NYC_NEIGHBORHOOD_VARIATIONS: Record<string, string[]> = {\n  \"Harlem\": [\"harlem\", \"uptown harlem\", \"upper harlem\", \"central harlem\"],\n  \"East Harlem\": [\"spanish harlem\", \"el barrio\", \"east harlem\"],\n  \"West Village\": [\"west village\", \"greenwich village west\", \"west village nyc\"],\n  \"Greenwich Village\": [\"greenwich village\", \"the village\", \"village\"],\n  \"SoHo\": [\"soho\", \"so ho\", \"south of houston\"],\n  \"TriBeCa\": [\"tribeca\", \"tri beca\", \"triangle below canal\"],\n  \"Financial District\": [\"fidi\", \"financial district\", \"wall street area\"],\n  \"Upper East Side\": [\"ues\", \"upper east side\", \"east side\"],\n  \"Upper West Side\": [\"uws\", \"upper west side\", \"west side\"],\n  \"Williamsburg\": [\"williamsburg\", \"billyburg\", \"north brooklyn\"],\n  \"Dumbo\": [\"dumbo\", \"down under manhattan bridge overpass\"],\n  \"Times Square\": [\"times square\", \"times sq\", \"broadway district\", \"theater district\"],\n  \"East Village\": [\"east village\", \"alphabet city\", \"lower east side north\"],\n  \"Midtown\": [\"midtown\", \"midtown manhattan\", \"central manhattan\"],\n  \"Chelsea\": [\"chelsea\", \"chelsea nyc\", \"west chelsea\"],\n  \"Lower East Side\": [\"les\", \"lower east side\", \"lower manhattan east\"],\n  \"Murray Hill\": [\"murray hill\", \"kips bay area\", \"midtown east\"]\n};\n\n// Common NYC stations/subway stops that should always have \"station\" appended\nconst COMMON_STATIONS = [\n  \"Grand Central\",\n  \"Penn Station\",\n  \"Times Square\",\n  \"Union Square\",\n  \"World Trade Center\",\n  \"Atlantic Terminal\",\n  \"Columbus Circle\",\n  \"Herald Square\",\n  \"Bryant Park\",\n  \"Fulton Street\",\n  \"Canal Street\",\n  \"Wall Street\",\n  \"Chambers Street\",\n  \"Jay Street\",\n  \"Borough Hall\",\n  \"Rockefeller Center\",\n  \"14th Street\",\n  \"Lexington Avenue\",\n  \"34th Street\"\n] as const;\n\n// Common activity mappings to Google Places API types\nexport const ACTIVITY_TYPE_MAPPINGS = {\n  \"lunch\": \"restaurant\",\n  \"dinner\": \"restaurant\",\n  \"breakfast\": \"restaurant\",\n  \"coffee\": \"cafe\",\n  \"drinks\": \"bar\",\n  \"shopping\": \"shopping_mall\",\n  \"culture\": \"museum\",\n  \"art\": \"art_gallery\",\n  \"entertainment\": \"movie_theater\",\n  \"park\": \"park\",\n  \"hotel\": \"lodging\",\n  \"workout\": \"gym\",\n  \"spa\": \"spa\",\n  \"tourism\": \"tourist_attraction\",\n  \"nightlife\": \"night_club\",\n  \"dessert\": \"bakery\",\n  // Non-venue activities that shouldn't be sent to Google Places API\n  \"meeting\": null,\n  \"arrive\": null,\n  \"depart\": null,\n  \"explore\": null,\n  \"walk\": null,\n  \"travel\": null,\n  \"relax\": null,\n  \"break\": null,\n  \"rest\": null,\n  \"visit\": null\n} as const;\n\ntype ActivityType = keyof typeof ACTIVITY_TYPE_MAPPINGS;\ntype Station = typeof COMMON_STATIONS[number];\n\n// Common misspellings and variants of NYC locations\nconst SPELLING_CORRECTIONS: Record<string, string> = {\n  'greenwhich': 'Greenwich',\n  'greenwich village': 'Greenwich Village',\n  'green village': 'Greenwich Village',\n  'times sq': 'Times Square',\n  'time square': 'Times Square',\n  'timesquare': 'Times Square',\n  'central pk': 'Central Park',\n  'soho': 'SoHo',\n  'williamsburg': 'Williamsburg',\n  'dumbo': 'DUMBO',\n  'down under manhattan bridge': 'DUMBO',\n  'downtown brooklyn': 'Downtown Brooklyn',\n  'upper east': 'Upper East Side',\n  'upper west': 'Upper West Side',\n  'west village': 'West Village',\n  'east village': 'East Village',\n  'financial district': 'Financial District',\n  'fin district': 'Financial District',\n  'fidi': 'Financial District',\n  'midtown': 'Midtown',\n  'mid town': 'Midtown',\n  'china town': 'Chinatown',\n  'chelsea': 'Chelsea',\n  'gramercy': 'Gramercy',\n  'gramercy park': 'Gramercy Park',\n  'hells kitchen': 'Hell\\'s Kitchen',\n  'hell\\'s kitchen': 'Hell\\'s Kitchen',\n  'tribeca': 'Tribeca',\n  'little italy': 'Little Italy',\n  'nolita': 'NoLita',\n  'noho': 'NoHo',\n  'flatbush': 'Flatbush',\n  'brooklyn heights': 'Brooklyn Heights',\n  'park slope': 'Park Slope',\n  'grand central': 'Grand Central Station',\n  'penn sta': 'Penn Station'\n};\n\n// Helper to normalize location names with improved spelling corrections\nexport function normalizeLocationName(location: string): string {\n  // Handle null, undefined, or empty string\n  if (!location || typeof location !== 'string') return '';\n  \n  const trimmed = location.trim();\n  if (trimmed === '') return '';\n  \n  const lowercased = trimmed.toLowerCase();\n  \n  // Check for colloquial neighborhood names first\n  for (const [canonicalName, variations] of Object.entries(NYC_NEIGHBORHOOD_VARIATIONS)) {\n    if (variations.includes(lowercased)) {\n      console.log(`Matched colloquial name: \"${location}\" -> \"${canonicalName}\"`);\n      return canonicalName;\n    }\n  }\n  \n  // Check for common spelling corrections\n  for (const [misspelled, correct] of Object.entries(SPELLING_CORRECTIONS)) {\n    if (lowercased === misspelled) {\n      return correct;\n    }\n  }\n  \n  // Handle hyphenated location names (e.g., \"Covent-Garden\" → \"Covent Garden\")\n  if (trimmed.includes('-')) {\n    const dehyphenated = trimmed.replace(/-/g, ' ');\n    // Check if the dehyphenated version has a correction\n    const dehyphenatedLower = dehyphenated.toLowerCase();\n    for (const [misspelled, correct] of Object.entries(SPELLING_CORRECTIONS)) {\n      if (dehyphenatedLower === misspelled) {\n        return correct;\n      }\n    }\n    \n    // If no correction found, properly capitalize the dehyphenated version\n    return dehyphenated.split(' ')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n\n  // Check if it's a common tube station that needs \"Station\" appended\n  const station = COMMON_STATIONS.find(s => \n    s.toLowerCase() === lowercased ||\n    lowercased === `${s.toLowerCase()} station`\n  );\n\n  // Normalize station names\n  if (station) {\n    return `${station} Station`;\n  }\n  \n  // For other locations, apply proper capitalization\n  // Convert to title case (first letter of each word capitalized)\n  return trimmed.split(' ')\n    .map(word => {\n      // Special case for King's Cross and similar possessives\n      if (word.toLowerCase() === 'kings') return 'King\\'s';\n      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    })\n    .join(' ');\n}\n\n// Helper to verify if a returned place matches the requested location\n// Updated to be more lenient with neighborhood matching\nexport function verifyPlaceMatch(\n  requestedLocation: string, \n  returnedName: string,\n  types: string[]\n): boolean {\n  // Handle invalid inputs\n  if (!requestedLocation || !returnedName) return false;\n  if (!Array.isArray(types)) types = [];\n  \n  // Normalize inputs for comparison\n  const normalized = requestedLocation.toLowerCase().trim();\n  const returnedNormalized = returnedName.toLowerCase().trim();\n  \n  if (normalized === '' || returnedNormalized === '') return false;\n\n  // Exact match\n  if (normalized === returnedNormalized) {\n    return true;\n  }\n  \n  // Check if this is a known neighborhood variation\n  for (const [canonicalName, variations] of Object.entries(NYC_NEIGHBORHOOD_VARIATIONS)) {\n    // If the requested location is a variation of this canonical neighborhood name\n    if (variations.includes(normalized)) {\n      // Check if the returned name matches or contains the canonical form\n      if (returnedNormalized.includes(canonicalName.toLowerCase())) {\n        console.log(`Matched variation \"${normalized}\" to canonical \"${canonicalName}\"`);\n        return true;\n      }\n    }\n    \n    // If the returned location contains any of the variations\n    if (variations.some(variation => returnedNormalized.includes(variation))) {\n      console.log(`Matched returned location \"${returnedNormalized}\" to a variation of \"${canonicalName}\"`);\n      return true;\n    }\n  }\n\n  // Check if the returned place contains the normalized name or vice versa\n  if (returnedNormalized.includes(normalized) || normalized.includes(returnedNormalized)) {\n    return true;\n  }\n  \n  // Split words and check for partial matches\n  const requestWords = normalized.split(/\\s+/).filter(word => word.length > 2);\n  const returnedWords = returnedNormalized.split(/\\s+/).filter(word => word.length > 2);\n  \n  // If the requested location has multiple meaningful words, check if most match\n  if (requestWords.length > 1) {\n    const matchingWords = requestWords.filter(word => \n      returnedWords.some(retWord => retWord.includes(word) || word.includes(retWord))\n    );\n    // If more than half the words match, consider it a match\n    if (matchingWords.length >= Math.ceil(requestWords.length / 2)) {\n      return true;\n    }\n  }\n\n  // For areas and neighborhoods, be extra lenient\n  const isArea = types.some(t => \n    t.includes('sublocality') || \n    t.includes('neighborhood') || \n    t.includes('political') ||\n    t.includes('locality')\n  );\n\n  if (isArea) {\n    // For neighborhoods, even a single word match can be considered valid\n    // since Google may return full official names like \"Mayfair, London, UK\"\n    for (const word of requestWords) {\n      if (word.length > 3 && returnedNormalized.includes(word)) {\n        return true;\n      }\n    }\n    \n    // Check if it's a known NYC area in our database\n    const matchingArea = nycAreas.find((area: NYCArea) => {\n      const areaLower = area.name.toLowerCase();\n      \n      // Check the area name\n      if (areaLower === normalized) return true;\n      \n      // Check area name contains or is contained by the normalized string\n      if (areaLower.includes(normalized) || normalized.includes(areaLower)) {\n        return true;\n      }\n      \n      // Check the neighboring areas if available\n      if (area.neighbors && Array.isArray(area.neighbors)) {\n        return area.neighbors.some((n: string) => {\n          if (typeof n !== 'string') return false;\n          const nLower = n.toLowerCase();\n          return nLower === normalized || \n                 nLower.includes(normalized) || \n                 normalized.includes(nLower);\n        });\n      }\n      \n      return false;\n    });\n\n    if (matchingArea) {\n      return true;\n    }\n  }\n  \n  // For stations, check if the returned name includes \"station\" and matches one of our known stations\n  if (returnedNormalized.includes('station')) {\n    for (const station of COMMON_STATIONS) {\n      const stationLower = station.toLowerCase();\n      if (returnedNormalized.includes(stationLower) || normalized.includes(stationLower)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// Helper to suggest similar locations when a match isn't found\nexport function suggestSimilarLocations(location: string): string[] {\n  // Handle null, undefined, or empty string\n  if (!location || typeof location !== 'string' || location.trim() === '') {\n    return ['Times Square', 'SoHo', 'Central Park']; // Default popular areas\n  }\n  \n  const normalized = location.toLowerCase().trim();\n  const suggestions = new Set<string>();\n\n  // First check if this is a neighborhood variation\n  for (const [canonicalName, variations] of Object.entries(NYC_NEIGHBORHOOD_VARIATIONS)) {\n    // If the requested location is similar to any of the variations\n    if (variations.some(variation => \n      variation.includes(normalized) || normalized.includes(variation)\n    )) {\n      suggestions.add(canonicalName);\n      \n      // If we have a direct match, also suggest the neighboring areas\n      if (variations.includes(normalized)) {\n        const matchingArea = nycAreas.find(area => area.name === canonicalName);\n        if (matchingArea && matchingArea.neighbors) {\n          // Add a few neighboring areas as suggestions\n          matchingArea.neighbors.slice(0, 2).forEach(neighbor => {\n            suggestions.add(neighbor);\n          });\n        }\n      }\n    }\n  }\n  \n  // Then check stations\n  for (const station of COMMON_STATIONS) {\n    const stationLower = station.toLowerCase();\n    if (stationLower.includes(normalized) || normalized.includes(stationLower)) {\n      suggestions.add(`${station} Station`);\n    }\n  }\n\n  // Split the location into words for partial matching\n  const requestWords = normalized.split(/\\s+/).filter(word => word.length > 2);\n\n  // Check areas, preserving original area names from our database\n  for (const area of nycAreas) {\n    const areaLower = area.name.toLowerCase();\n    \n    // Full or partial location matching\n    if (areaLower.includes(normalized) || normalized.includes(areaLower)) {\n      suggestions.add(area.name); // Use proper case from our data\n    } else {\n      // Try word-level matching for multi-word locations\n      const matchingWords = requestWords.filter(word => \n        areaLower.includes(word) || word.includes(areaLower)\n      );\n      if (matchingWords.length > 0) {\n        suggestions.add(area.name);\n      }\n    }\n\n    // Check neighboring areas, maintaining their original names\n    if (area.neighbors && Array.isArray(area.neighbors)) {\n      for (const neighbor of area.neighbors) {\n        if (typeof neighbor === 'string') {\n          const neighborLower = neighbor.toLowerCase();\n          if (neighborLower.includes(normalized) || normalized.includes(neighborLower)) {\n            suggestions.add(neighbor); // Keep the original name\n          }\n        }\n      }\n    }\n  }\n  \n  // If we didn't find any matches, return popular areas\n  if (suggestions.size === 0) {\n    return ['Times Square', 'SoHo', 'Greenwich Village'];\n  }\n\n  // Convert to array and sort by relevance\n  return Array.from(suggestions)\n    .sort((a, b) => {\n      const aLower = a.toLowerCase();\n      const bLower = b.toLowerCase();\n      \n      const aScore = aLower === normalized ? 5 :\n                    aLower.startsWith(normalized) ? 4 :\n                    normalized.startsWith(aLower) ? 3 :\n                    aLower.includes(normalized) ? 2 :\n                    normalized.includes(aLower) ? 1 : 0;\n                    \n      const bScore = bLower === normalized ? 5 :\n                    bLower.startsWith(normalized) ? 4 :\n                    normalized.startsWith(bLower) ? 3 :\n                    bLower.includes(normalized) ? 2 :\n                    normalized.includes(bLower) ? 1 : 0;\n                    \n      return bScore - aScore;\n    })\n    .slice(0, 3); // Return up to 3 suggestions\n}\n\n// Convert activity types to Google Places API types\nexport function mapActivityToPlaceType(activity: string): string | null | undefined {\n  if (!activity) return undefined;\n  \n  const normalized = activity.toLowerCase().trim();\n  \n  // Check if the normalized string is a valid key in our mapping\n  const isValidActivityType = Object.keys(ACTIVITY_TYPE_MAPPINGS).includes(normalized);\n  \n  if (isValidActivityType) {\n    // The value might be null for non-venue activities\n    const mappedValue = ACTIVITY_TYPE_MAPPINGS[normalized as ActivityType];\n    return mappedValue; // This might be null for non-venue activities\n  }\n  \n  // Try to find partial matches\n  for (const [key, value] of Object.entries(ACTIVITY_TYPE_MAPPINGS)) {\n    if ((normalized.includes(key) || key.includes(normalized)) && value !== null) {\n      return value;\n    }\n  }\n  \n  // Default to restaurant for food-related terms\n  if (normalized.includes('food') || normalized.includes('eat')) {\n    return 'restaurant';\n  }\n  \n  return undefined;\n}","size_bytes":15271},"server/lib/mapGeocoding.ts":{"content":"/**\n * Google Maps Geocoding API Integration\n * \n * This module provides geocoding functions to validate and improve location data\n * by using the Google Maps Geocoding API.\n */\n\nimport { getApiKey, isFeatureEnabled } from \"../config\";\n\n// Interface for address component\ninterface AddressComponent {\n  long_name: string;\n  short_name: string;\n  types: string[];\n}\n\n// Interface for geocoding result\nexport interface GeocodingResult {\n  lat: number;\n  lng: number;\n  formattedAddress: string;\n  neighborhood?: string;\n  locality?: string;  \n  administrativeArea?: string;\n  country?: string;\n}\n\n/**\n * Validates and normalizes a location name by geocoding it through Google Maps API\n * \n * @param location Location name to validate (e.g., \"Hackney\", \"Soho\", etc.)\n * @returns Verified location name (neighborhood or locality) or original if verification fails\n */\nexport async function validateAndNormalizeLocation(location: string): Promise<string> {\n  // Skip if the feature is disabled\n  if (!isFeatureEnabled(\"PLACES_API\")) {\n    console.log(\"Places API is disabled, skipping location validation for:\", location);\n    return location;\n  }\n\n  try {\n    const apiKey = getApiKey(\"GOOGLE_PLACES_API_KEY\");\n    \n    // Ensure the location is specifically within New York City\n    const searchQuery = `${location}, New York, NY, USA`;\n    const geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(searchQuery)}&key=${apiKey}`;\n    \n    console.log(`Validating location: \"${location}\" with Google Maps Geocoding API`);\n    \n    const response = await fetch(geocodeUrl);\n    \n    if (!response.ok) {\n      throw new Error(`Geocoding API request failed with status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    if (data.status !== \"OK\" || !data.results || data.results.length === 0) {\n      console.log(`No geocoding results found for \"${location}\"`);\n      return location;\n    }\n    \n    // Get the first (most relevant) result\n    const result = data.results[0];\n    \n    // Extract the most specific address component\n    // Prioritize: neighborhood > sublocality > locality > administrative_area\n    const components = result.address_components || [];\n    \n    // First, try to find a neighborhood or sublocality\n    const neighborhood = components.find(\n      (component: AddressComponent) => \n        component.types.includes(\"neighborhood\") || \n        component.types.includes(\"sublocality_level_1\") ||\n        component.types.includes(\"sublocality\")\n    );\n    \n    if (neighborhood) {\n      console.log(`Validated \"${location}\" as neighborhood: \"${neighborhood.long_name}\"`);\n      return neighborhood.long_name;\n    }\n    \n    // Next, try to find a locality (city/town)\n    const locality = components.find(\n      (component: AddressComponent) => component.types.includes(\"locality\")\n    );\n    \n    if (locality && locality.long_name.toLowerCase() !== \"new york\") {\n      console.log(`Validated \"${location}\" as locality: \"${locality.long_name}\"`);\n      return locality.long_name;\n    }\n    \n    // Check for administrative area as last resort\n    const adminArea = components.find(\n      (component: AddressComponent) => component.types.includes(\"administrative_area_level_2\")\n    );\n    \n    if (adminArea && adminArea.long_name.toLowerCase() !== \"new york county\") {\n      console.log(`Validated \"${location}\" as admin area: \"${adminArea.long_name}\"`);\n      return adminArea.long_name;\n    }\n    \n    // If we couldn't find a specific component, just return the original\n    console.log(`Could not find specific component for \"${location}\", keeping original`);\n    return location;\n    \n  } catch (error) {\n    console.error(`Error in location validation for \"${location}\":`, error);\n    return location;  // Return original on error\n  }\n}\n\n/**\n * Get full geocoding details for a location\n * \n * @param location Location name or address\n * @returns Detailed geocoding result or null if not found\n */\nexport async function getLocationDetails(location: string): Promise<GeocodingResult | null> {\n  if (!isFeatureEnabled(\"PLACES_API\")) {\n    return null;\n  }\n\n  try {\n    const apiKey = getApiKey(\"GOOGLE_PLACES_API_KEY\");\n    const searchQuery = `${location}, New York, NY, USA`;\n    const geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(searchQuery)}&key=${apiKey}`;\n    \n    const response = await fetch(geocodeUrl);\n    \n    if (!response.ok) {\n      throw new Error(`Geocoding API request failed with status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    if (data.status !== \"OK\" || !data.results || data.results.length === 0) {\n      return null;\n    }\n    \n    const result = data.results[0];\n    const components = result.address_components || [];\n    \n    const neighborhood = components.find((c: AddressComponent) => \n      c.types.includes(\"neighborhood\") || \n      c.types.includes(\"sublocality_level_1\") ||\n      c.types.includes(\"sublocality\")\n    );\n    \n    const locality = components.find((c: AddressComponent) => \n      c.types.includes(\"locality\")\n    );\n    \n    const adminArea = components.find((c: AddressComponent) => \n      c.types.includes(\"administrative_area_level_2\") || \n      c.types.includes(\"administrative_area_level_1\")\n    );\n    \n    const country = components.find((c: AddressComponent) => \n      c.types.includes(\"country\")\n    );\n    \n    return {\n      lat: result.geometry.location.lat,\n      lng: result.geometry.location.lng,\n      formattedAddress: result.formatted_address,\n      neighborhood: neighborhood?.long_name,\n      locality: locality?.long_name,\n      administrativeArea: adminArea?.long_name,\n      country: country?.long_name\n    };\n    \n  } catch (error) {\n    console.error(`Error in getLocationDetails for \"${location}\":`, error);\n    return null;\n  }\n}\n\n/**\n * Process location information using a two-phase approach:\n * 1. Try to extract with AI (Gemini)\n * 2. Verify with Google Maps Geocoding\n * \n * This provides the most accurate location information possible.\n */\nexport async function processLocationWithAIAndMaps(query: string, extractedLocation?: string): Promise<string> {\n  let locationToProcess = extractedLocation || \"Midtown\";\n  \n  try {\n    // Verify with Google Maps\n    const verifiedLocation = await validateAndNormalizeLocation(locationToProcess);\n    \n    if (verifiedLocation && verifiedLocation !== \"New York\") {\n      console.log(`Location processing result: \"${locationToProcess}\" -> \"${verifiedLocation}\"`);\n      return verifiedLocation;\n    }\n    \n    // If we couldn't verify with Maps or got a generic \"London\" result,\n    // try to extract more specific location information from the query\n    \n    // Look for explicit location mentions with prepositions\n    const locationMatch = query.match(/\\b(?:in|at|near|around|by)\\s+([A-Z][a-zA-Z\\s]{2,})\\b/i);\n    if (locationMatch && locationMatch[1]) {\n      locationToProcess = locationMatch[1].trim();\n      console.log(`Found potential location in query: \"${locationToProcess}\"`);\n      \n      // Try to validate this extracted location\n      const verifiedExplicitLocation = await validateAndNormalizeLocation(locationToProcess);\n      if (verifiedExplicitLocation && verifiedExplicitLocation !== \"New York\") {\n        console.log(`Verified explicit location: \"${verifiedExplicitLocation}\"`);\n        return verifiedExplicitLocation;\n      }\n    }\n    \n    // If we still don't have a specific location, return the original or use Midtown as default\n    return locationToProcess;\n    \n  } catch (error) {\n    console.error(\"Error in processLocationWithAIAndMaps:\", error);\n    return locationToProcess; // Return original on error\n  }\n}","size_bytes":7749},"server/lib/nlp-fixed.ts":{"content":"import { z } from \"zod\";\nimport { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';\nimport type { PlaceDetails } from \"@shared/schema\";\nimport { StructuredRequest } from \"@shared/types\";\nimport { nycAreas } from \"../data/new-york-areas\";\nimport { \n  findLocation, \n  parseActivity, \n  parseTimeExpression, \n  getDefaultTime,\n  expandRelativeTime,\n  LocationContext,\n  ActivityContext \n} from \"./languageProcessing\";\nimport { getApiKey, isFeatureEnabled, validateApiKey } from \"../config\";\nimport { processWithGemini, StructuredRequest as GeminiStructuredRequest } from './geminiProcessor';\nimport { validateAndNormalizeLocation, processLocationWithAIAndMaps } from './mapGeocoding';\nimport { parseAndNormalizeTime } from './timeUtils';\nimport { format, parseISO } from 'date-fns';\nimport { formatInTimeZone, toZonedTime } from 'date-fns-tz';\n\n// Configure Gemini model with safety settings\nlet genAI: GoogleGenerativeAI | null = null;\nlet model: any = null;\n\n// Initialize AI only if API key is available\n// Check if AI processing is enabled\nconsole.log(\"AI_PROCESSING feature flag status:\", isFeatureEnabled(\"AI_PROCESSING\"));\n\nif (isFeatureEnabled(\"AI_PROCESSING\")) {\n  try {\n    // Check if Gemini API key is valid\n    const geminiApiKey = getApiKey(\"GEMINI_API_KEY\");\n    console.log(\"GEMINI_API_KEY validation:\", validateApiKey(\"GEMINI_API_KEY\"));\n    \n    if (!geminiApiKey) {\n      console.error(\"Gemini API Key is missing or empty\");\n    } else if (!validateApiKey(\"GEMINI_API_KEY\")) {\n      console.error(\"Gemini API Key failed validation pattern\");\n    } else {\n      console.log(\"Initializing Gemini API with valid API key\");\n      \n      // Initialize Google Generative AI with centralized config\n      genAI = new GoogleGenerativeAI(geminiApiKey);\n      \n      // Configure Gemini model with safety settings\n      model = genAI.getGenerativeModel({\n        model: \"gemini-1.5-pro-latest\",\n        safetySettings: [\n          {\n            category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n          {\n            category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n          {\n            category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n          {\n            category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n        ],\n      });\n      \n      console.log(\"Gemini API successfully initialized\");\n    }\n  } catch (err) {\n    console.error(\"Failed to initialize Gemini API:\", err);\n    // Leave genAI and model as null to trigger fallback handling\n  }\n}\n\n// Using the imported StructuredRequest interface from shared/types.ts\n\n// Define fixed time entry type for use in parsing\ntype FixedTimeEntry = {\n  location: string;\n  time: string;\n  type?: string;\n  // Additional search parameters for richer venue search\n  searchTerm?: string;\n  keywords?: string[];\n  minRating?: number;\n  displayTime?: string; // New property for formatted display time in NYC timezone\n  searchPreference?: string; // Specific user preference for the venue (e.g., \"sandwich place\")\n};\n\n/**\n * Helper function to correctly convert a time string into NYC timezone-aware values\n * \n * @param timeString Time string in 24-hour format (HH:MM)\n * @returns Object containing the ISO timestamp and formatted display time\n */\nfunction convertTimeStringToNYC(timeString: string): { isoTimestamp: string, displayTime: string } {\n  const timeZone = 'America/New_York';\n  const [hours, minutes] = timeString.split(':').map(Number);\n  \n  // Get current date in NYC time zone to ensure proper DST handling\n  const now = new Date();\n  const nycTime = toZonedTime(now, timeZone);\n  \n  // Extract date components from NYC time\n  const year = nycTime.getFullYear();\n  const month = nycTime.getMonth(); // 0-indexed in JavaScript\n  const day = nycTime.getDate();\n  \n  // Create a new date with the parsed time components but NYC date\n  const localDate = new Date(year, month, day, hours, minutes);\n  \n  // Calculate UTC equivalent by accounting for timezone offset\n  const utcDate = new Date(localDate.getTime() + (localDate.getTimezoneOffset() * 60000));\n  \n  // Format for output\n  const isoTimestamp = utcDate.toISOString();\n  const displayTime = formatInTimeZone(localDate, timeZone, 'h:mm a');\n  \n  return { isoTimestamp, displayTime };\n}\n\n/**\n * Convert Gemini structured request to the application's expected format\n */\nfunction convertGeminiToAppFormat(geminiResult: GeminiStructuredRequest | null): StructuredRequest | null {\n  console.log(\"Converting Gemini result to app format:\", JSON.stringify(geminiResult, null, 2));\n  \n  if (!geminiResult) {\n    return null;\n  }\n  \n  // Initialize the result structure\n  const appFormatRequest: StructuredRequest = {\n    startLocation: geminiResult.startLocation || \"Midtown\", // Default to Midtown Manhattan\n    destinations: [],\n    fixedTimes: [],\n    preferences: {\n      type: undefined,\n      requirements: []\n    }\n  };\n  \n  // Inspect the venuePreference data in the Gemini response\n  if (geminiResult.fixedTimeEntries && geminiResult.fixedTimeEntries.length > 0) {\n    geminiResult.fixedTimeEntries.forEach(entry => {\n      if (entry.searchParameters?.venuePreference) {\n        console.log(`Found raw venuePreference in Gemini fixed time entry: \"${entry.searchParameters.venuePreference}\" for activity \"${entry.activity}\"`);\n      }\n    });\n  }\n  \n  // Create a map to track unique activities by location and similar activity text\n  // This will help us avoid duplicates from both fixedTimeEntries and flexibleTimeEntries\n  const activityMap = new Map<string, FixedTimeEntry>();\n  \n  // Helper function to determine the most specific activity type\n  const determineActivityType = (activityText: string): string => {\n    const activityLower = activityText.toLowerCase();\n    \n    if (activityLower.includes('museum') || activityLower.includes('gallery') || activityLower.includes('exhibition')) {\n      return \"museum\";\n    } else if (activityLower.includes('lunch') || activityLower.includes('dinner') || \n               activityLower.includes('breakfast') || activityLower.includes('eat') || \n               activityLower.includes('restaurant') || activityLower.includes('food')) {\n      return \"restaurant\";\n    } else if (activityLower.includes('coffee') || activityLower.includes('cafe')) {\n      return \"cafe\";\n    } else if (activityLower.includes('park') || activityLower.includes('garden')) {\n      return \"park\";\n    } else if (activityLower.includes('shop') || activityLower.includes('store') || activityLower.includes('mall')) {\n      return \"shopping_mall\";\n    } else {\n      return \"attraction\";\n    }\n  };\n  \n  // Helper function to create a unique key for an activity at a location\n  const createActivityKey = (location: string, activityText: string): string => {\n    // Normalize the location and activity text to avoid case-sensitive duplicates\n    const normalizedLocation = location.toLowerCase();\n    const normalizedActivity = activityText.toLowerCase();\n    \n    return `${normalizedLocation}|${determineActivityType(normalizedActivity)}`;\n  };\n  \n  // Process fixed time entries if present\n  if (geminiResult.fixedTimeEntries && Array.isArray(geminiResult.fixedTimeEntries)) {\n    console.log(\"Raw fixed time entries from Gemini:\", JSON.stringify(geminiResult.fixedTimeEntries, null, 2));\n    for (const entry of geminiResult.fixedTimeEntries) {\n      if (entry && typeof entry === 'object' && entry.location && entry.time) {\n        // Parse time expressions using our enhanced timeUtils\n        let timeValue = entry.time;\n        let displayTime = '';\n        \n        // Process time values with our improved parser\n        if (typeof timeValue === 'string') {\n          // Parse times like \"noon\", \"around 3 PM\", etc.\n          const originalTime = timeValue;\n          timeValue = parseAndNormalizeTime(timeValue);\n          console.log(`Fixed time entry: Normalized time from \"${originalTime}\" to \"${timeValue}\"`);\n          \n          // Convert the normalized time string (HH:MM) to NYC timezone-aware values\n          const { isoTimestamp, displayTime: formattedTime } = convertTimeStringToNYC(timeValue);\n          \n          // Store the ISO timestamp for backend processing\n          timeValue = isoTimestamp;\n          displayTime = formattedTime;\n          \n          console.log(`Correctly interpreted time \"${originalTime}\" as NYC time: ${displayTime} (${timeValue})`);\n        }\n        \n        // Determine the most appropriate activity type\n        const activityType = entry.searchParameters?.venueType || determineActivityType(entry.activity);\n        \n        // Create a key for this activity\n        const activityKey = createActivityKey(entry.location, entry.activity);\n        \n        // Check if there's a specific search preference from multiple possible locations\n        let searchPreference: string | undefined = undefined;\n        \n        // First check for the venue preference at the top level of the Gemini response object\n        if (geminiResult.venuePreference) {\n          searchPreference = geminiResult.venuePreference;\n          console.log(`Found top-level venue preference in Gemini response: \"${searchPreference}\" for activity: ${entry.activity}`);\n        }\n        // Then check for the entry-specific venuePreference field directly\n        else if (entry.venuePreference) {\n          searchPreference = entry.venuePreference;\n          console.log(`Found entry-level venue preference: \"${searchPreference}\" for activity: ${entry.activity}`);\n        }\n        // Then check if searchParameters.venuePreference exists\n        else if (entry.searchParameters?.venuePreference) {\n          searchPreference = entry.searchParameters.venuePreference;\n          console.log(`Found venue preference in searchParameters: \"${searchPreference}\" for activity: ${entry.activity}`);\n        }\n        \n        // Log whether we found a preference or not, for debugging\n        if (!searchPreference) {\n          console.log(`No venue preference found in Gemini data for activity: ${entry.activity}`);\n        }\n        \n        // Store in our map, potentially overwriting less specific entries\n        activityMap.set(activityKey, {\n          location: entry.location,\n          time: timeValue,\n          type: activityType,\n          searchTerm: entry.activity,\n          keywords: entry.searchParameters?.specificRequirements || undefined,\n          minRating: 4.0, // Default to high quality\n          displayTime: displayTime, // Add the display time for the frontend\n          searchPreference: searchPreference // Add user's specific venue preference\n        });\n        \n        console.log(`Processed fixed time entry: ${entry.activity} at ${entry.location}, time: ${timeValue}, type: ${activityType}`);\n      }\n    }\n  }\n  \n  // Process flexible time entries - THIS IS THE KEY FIX for the correct timezone handling\n  if (geminiResult.flexibleTimeEntries && Array.isArray(geminiResult.flexibleTimeEntries)) {\n    console.log(\"Raw flexible time entries from Gemini:\", JSON.stringify(geminiResult.flexibleTimeEntries, null, 2));\n    \n    for (const entry of geminiResult.flexibleTimeEntries) {\n      if (entry && typeof entry === 'object' && entry.location) {\n        // Convert time formats\n        let timeValue = entry.time || \"12:00\";\n        let displayTime = '';\n        \n        // Handle time periods using the timeUtils functions\n        if (typeof timeValue === 'string') {\n          // This will handle \"morning\", \"afternoon\", \"evening\", \"night\"\n          // as well as \"around noon\", \"around 3 PM\", etc.\n          const originalTime = timeValue;\n          timeValue = parseAndNormalizeTime(timeValue);\n          console.log(`Normalized time from \"${originalTime}\" to \"${timeValue}\"`);\n          \n          // Convert the normalized time string (HH:MM) to NYC timezone-aware values\n          const { isoTimestamp, displayTime: formattedTime } = convertTimeStringToNYC(timeValue);\n          \n          // Store the ISO timestamp for backend processing\n          timeValue = isoTimestamp;\n          displayTime = formattedTime;\n          \n          console.log(`Correctly interpreted time \"${originalTime}\" as NYC time: ${displayTime} (${timeValue})`);\n        }\n        \n        // Determine the most appropriate activity type\n        const activityType = determineActivityType(entry.activity);\n        \n        // Create a key for this activity\n        const activityKey = createActivityKey(entry.location, entry.activity);\n        \n        // Check if there's a specific search preference from multiple possible locations\n        let searchPreference: string | undefined = undefined;\n        \n        // First check for the venue preference at the top level of the Gemini response object\n        if (geminiResult.venuePreference) {\n          searchPreference = geminiResult.venuePreference;\n          console.log(`Found top-level venue preference in Gemini response: \"${searchPreference}\" for flexible activity: ${entry.activity}`);\n        }\n        // Then check for the entry-specific venuePreference field directly\n        else if (entry.venuePreference) {\n          searchPreference = entry.venuePreference;\n          console.log(`Found entry-level venue preference (flexible): \"${searchPreference}\" for activity: ${entry.activity}`);\n        }\n        // Then check if searchParameters.venuePreference exists\n        else if (entry.searchParameters?.venuePreference) {\n          searchPreference = entry.searchParameters.venuePreference;\n          console.log(`Found venue preference in searchParameters (flexible): \"${searchPreference}\" for activity: ${entry.activity}`);\n        }\n        \n        // Log whether we found a preference or not, for debugging\n        if (!searchPreference) {\n          console.log(`No venue preference found in Gemini data for flexible activity: ${entry.activity}`);\n        }\n        \n        // Only add if we don't already have this activity, or if we're adding a more specific type\n        if (!activityMap.has(activityKey)) {\n          activityMap.set(activityKey, {\n            location: entry.location,\n            time: timeValue,\n            type: activityType,\n            searchTerm: entry.activity,\n            minRating: 4.0, // Default to high quality\n            displayTime: displayTime, // Add the display time for the frontend\n            searchPreference: searchPreference // Add user's specific venue preference\n          });\n          \n          console.log(`Processed flexible time entry: ${entry.activity} at ${entry.location}, time: ${timeValue}, type: ${activityType}`);\n        }\n      }\n    }\n  }\n  \n  // Convert our map of unique activities to the fixedTimes array\n  appFormatRequest.fixedTimes = Array.from(activityMap.values());\n  console.log(`Final de-duplicated activities count: ${appFormatRequest.fixedTimes.length}`);\n  \n  // If we have no start location but have activities, use the first activity location\n  if (!appFormatRequest.startLocation && appFormatRequest.fixedTimes.length > 0) {\n    appFormatRequest.startLocation = appFormatRequest.fixedTimes[0].location;\n    console.log(`No startLocation provided, using first activity location: ${appFormatRequest.startLocation}`);\n  }\n  \n  // Process other preferences if available\n  if (geminiResult.preferences) {\n    // Extract budget preferences if available\n    if (geminiResult.preferences.budget) {\n      appFormatRequest.preferences.type = geminiResult.preferences.budget;\n    }\n    \n    // Extract requirements/restrictions if available\n    if (Array.isArray(geminiResult.specialRequests)) {\n      appFormatRequest.preferences.requirements = geminiResult.specialRequests;\n    }\n  }\n  \n  // Sort fixed times chronologically\n  appFormatRequest.fixedTimes.sort((a, b) => {\n    if (!a.time) return -1;\n    if (!b.time) return 1;\n    return a.time.localeCompare(b.time);\n  });\n  \n  // Create destinations array from fixed time locations\n  const uniqueLocations = new Set<string>();\n  appFormatRequest.fixedTimes.forEach(entry => {\n    if (entry.location && entry.location !== \"New York\" && entry.location !== \"NYC\" && entry.location !== \"Midtown\") {\n      uniqueLocations.add(entry.location);\n    }\n  });\n  \n  appFormatRequest.destinations = Array.from(uniqueLocations);\n  \n  console.log(\"Converted app format request:\", JSON.stringify(appFormatRequest, null, 2));\n  return appFormatRequest;\n}\n\n// Extract locations with confidence scores\nfunction extractLocations(text: string): LocationContext[] {\n  const locations: LocationContext[] = [];\n\n  // Split text into potential location phrases\n  const phrases = text.split(/[,.]|\\s+(?:then|and|to|at)\\s+/);\n\n  for (const phrase of phrases) {\n    // Look for common NYC street name patterns like \"Wall St\" or \"5th Ave\"\n    const streetMatch = phrase.match(/\\b(wall\\s*st|fifth\\s*ave|5th\\s*avenue|broadway|times\\s*square|madison\\s*ave|lexington\\s*ave|park\\s*ave|canal\\s*st|mott\\s*st|mulberry\\s*st|bowery|houston\\s*st|bleecker\\s*st|christopher\\s*st|west\\s*4th|42nd\\s*st|34th\\s*st|14th\\s*st|canal\\s*st|grand\\s*st|delancey\\s*st)\\b/i);\n    if (streetMatch?.[1]) {\n      const streetName = streetMatch[1].trim();\n      console.log(`Found NYC street reference: \"${streetName}\"`);\n      \n      // Map common street abbreviations to full names\n      const normalizedStreet = streetName.toLowerCase()\n        .replace(/wall\\s*st/, \"Wall Street\")\n        .replace(/5th\\s*ave/, \"Fifth Avenue\")\n        .replace(/fifth\\s*ave/, \"Fifth Avenue\")\n        .replace(/madison\\s*ave/, \"Madison Avenue\")\n        .replace(/lexington\\s*ave/, \"Lexington Avenue\")\n        .replace(/park\\s*ave/, \"Park Avenue\")\n        .replace(/canal\\s*st/, \"Canal Street\")\n        .replace(/mott\\s*st/, \"Mott Street\")\n        .replace(/mulberry\\s*st/, \"Mulberry Street\")\n        .replace(/houston\\s*st/, \"Houston Street\")\n        .replace(/bleecker\\s*st/, \"Bleecker Street\")\n        .replace(/christopher\\s*st/, \"Christopher Street\")\n        .replace(/west\\s*4th/, \"West 4th Street\")\n        .replace(/42nd\\s*st/, \"42nd Street\")\n        .replace(/34th\\s*st/, \"34th Street\")\n        .replace(/14th\\s*st/, \"14th Street\")\n        .replace(/grand\\s*st/, \"Grand Street\")\n        .replace(/delancey\\s*st/, \"Delancey Street\");\n      \n      locations.push({\n        name: normalizedStreet,\n        confidence: 0.9,\n        type: \"street\"\n      });\n      continue;\n    }\n    \n    // Look for location indicators with prepositions (in, at, near, from)\n    const locationMatch = phrase.match(/(?:in|at|near|from)\\s+([A-Z][a-zA-Z\\s]+)/);\n    if (locationMatch?.[1]) {\n      const location = findLocation(locationMatch[1]);\n      if (location) {\n        locations.push(location);\n      }\n    }\n  }\n\n  return locations;\n}\n\n// Extract activities with their context\nfunction extractActivities(text: string): ActivityContext[] {\n  const activities: ActivityContext[] = [];\n\n  // Split text into activity segments - expanded to catch more transition words\n  const segments = text.split(/[,.]|\\s+(?:then|and|afterwards|later|after that|following that|next)\\s+/);\n\n  for (const segment of segments) {\n    // Expanded regex to capture more vague activity indicators\n    if (segment.match(/(?:want|like|need|do|have|get|see|visit|explore|enjoy|experience|something|activity)\\s+(.+)/) ||\n        segment.match(/(?:around|at|by|from|until|before|after)\\s+\\d{1,2}(?::\\d{2})?(?:\\s*[ap]m)?/) || // Time indicators\n        segment.match(/(?:in the|during the|for)\\s+(?:morning|afternoon|evening|night)/)) { // Period indicators\n      const activity = parseActivity(segment);\n      activities.push(activity);\n    }\n  }\n\n  return activities;\n}\n\n/**\n * Parse a natural language itinerary request into structured data\n * \n * @param query User's natural language request\n * @returns StructuredRequest object with parsed locations, activities and preferences\n */\nexport async function parseItineraryRequest(query: string): Promise<StructuredRequest> {\n  // We've already imported processWithGemini from './geminiProcessor'\n  \n  // Initialize basic fallback structure with direct extraction methods\n  const extractedLocations = extractLocations(query);\n  const extractedActivities = extractActivities(query);\n  \n  // Extract time from the query directly for 6PM, 9AM style inputs\n  const timeRegex = /(\\d{1,2})\\s*(am|pm)/i;\n  const timeMatch = query.match(timeRegex);\n  let timeFromQuery = null;\n  \n  if (timeMatch) {\n    const [_, hour, meridian] = timeMatch;\n    const parsedHour = parseInt(hour);\n    const hourIn24 = meridian.toLowerCase() === 'pm' && parsedHour < 12 ? parsedHour + 12 : parsedHour;\n    timeFromQuery = `${hourIn24.toString().padStart(2, '0')}:00`;\n  }\n\n  // Create fallback structure that will be used if AI processing fails\n  const fallbackStructure: StructuredRequest = {\n    startLocation: null,\n    destinations: extractedLocations.map(loc => loc.name),\n    fixedTimes: extractedActivities.length > 0 ? \n      extractedActivities.map(activity => {\n        const location = extractedLocations[0]?.name || \"Midtown\";\n        \n        // Try to extract time from the query directly if it's a simple time reference\n        const time = timeFromQuery || activity.timeContext?.preferredTime || \n              (activity.type === 'breakfast' ? '09:00' : \n               activity.type === 'lunch' ? '13:00' : \n               activity.type === 'dinner' ? '19:00' : '12:00');\n        \n        return {\n          location,\n          time,\n          type: activity.venueType || activity.type,\n          searchTerm: activity.naturalDescription\n        };\n      }) : \n      // If no activities extracted but we found a time, create an entry with that time\n      timeFromQuery ? [{\n        location: extractedLocations[0]?.name || \"Midtown\",\n        time: timeFromQuery,\n        type: 'activity',\n        searchTerm: query\n      }] : [],\n    preferences: {\n      type: null,\n      requirements: []\n    }\n  };\n\n  try {\n    // First attempt: Use the new Gemini processor\n    console.log(\"Attempting to process query with new Gemini processor\");\n    const rawGeminiResult = await processWithGemini(query);\n    \n    if (rawGeminiResult) {\n      console.log(\"Successfully processed query with new Gemini processor\");\n      console.log(\"Raw Gemini API response:\", JSON.stringify(rawGeminiResult, null, 2));\n      \n      // Convert from Gemini processor format to application format\n      const geminiResult = convertGeminiToAppFormat(rawGeminiResult);\n      \n      if (geminiResult) {\n        // We don't need to process flexible time entries here again.\n        // The convertGeminiToAppFormat function we just updated already \n        // handles both fixedTimeEntries and flexibleTimeEntries with proper de-duplication.\n        console.log(\"Using optimized Gemini result that was converted by convertGeminiToAppFormat function\");\n        console.log(`Gemini result contains ${geminiResult.fixedTimes.length} de-duplicated activities`);\n        \n        // Sort fixed times chronologically if they exist\n        if (geminiResult.fixedTimes) {\n          geminiResult.fixedTimes.sort((a, b) => {\n            if (!a.time) return -1;\n            if (!b.time) return 1;\n            return a.time.localeCompare(b.time);\n          });\n        }\n        \n        // Apply location validation and normalization when possible\n        try {\n          // Using imported functions directly\n          for (const destination of geminiResult.destinations) {\n            const validatedLocation = await validateAndNormalizeLocation(destination);\n            // If validation succeeds, replace the original location with the validated one\n            if (validatedLocation) {\n              console.log(`Validated \"${destination}\" as neighborhood: \"${validatedLocation}\"`);\n              // Update it in-place\n              const index = geminiResult.destinations.indexOf(destination);\n              if (index !== -1) {\n                geminiResult.destinations[index] = validatedLocation;\n              }\n            }\n          }\n          \n          // Validate fixed time locations\n          if (geminiResult.fixedTimes) {\n            for (const fixedTime of geminiResult.fixedTimes) {\n              if (fixedTime.location) {\n                // Try more advanced mapping with AI first if it's a vague location\n                if (fixedTime.location.toLowerCase() === 'central manhattan' || \n                    fixedTime.location.toLowerCase() === 'central nyc' || \n                    fixedTime.location.toLowerCase() === 'central new york') {\n                  \n                  const enhancedLocation = await processLocationWithAIAndMaps(fixedTime.location, fixedTime.searchTerm);\n                  if (enhancedLocation && enhancedLocation !== \"New York\" && enhancedLocation !== \"NYC\" && enhancedLocation !== \"Midtown\") {\n                    fixedTime.location = enhancedLocation;\n                    console.log(`Enhanced fixed time location from generic to \"${enhancedLocation}\"`);\n                  }\n                } else if (fixedTime.location) {\n                  const validatedLocation = await validateAndNormalizeLocation(fixedTime.location);\n                  if (validatedLocation) {\n                    fixedTime.location = validatedLocation;\n                  }\n                }\n              }\n            }\n          }\n        } catch (error) {\n          console.warn(\"Location enhancement skipped due to error:\", error);\n        }\n        \n        // Debug the final processed output\n        console.log(\"Final processed Gemini result:\", JSON.stringify(geminiResult, null, 2));\n        return geminiResult;\n      }\n    }\n    \n    // If the new Gemini processor isn't available or fails, fall back to the original method\n    console.log(\"New Gemini processor unavailable or failed, falling back to original method\");\n    \n    // Skip Gemini processing if the feature is disabled or model initialization failed\n    if (!isFeatureEnabled(\"AI_PROCESSING\") || !model) {\n      console.log(\"AI processing skipped - using basic fallback structure\");\n      \n      // Even though we're using the fallback structure, let's improve it with Google Maps verification\n      // This will help improve the location data quality even without Gemini\n      for (let i = 0; i < fallbackStructure.destinations.length; i++) {\n        const destination = fallbackStructure.destinations[i];\n        const validated = await validateAndNormalizeLocation(destination);\n        if (validated) {\n          fallbackStructure.destinations[i] = validated;\n        }\n      }\n      \n      // Also validate fixed time locations\n      for (const fixedTime of fallbackStructure.fixedTimes) {\n        const validated = await validateAndNormalizeLocation(fixedTime.location);\n        if (validated) {\n          fixedTime.location = validated;\n        }\n      }\n      \n      return fallbackStructure;\n    }\n\n    // Still here? Use the fallback structure\n    return fallbackStructure;\n\n  } catch (error) {\n    console.error(\"Error during NLP processing:\", error);\n    return fallbackStructure;\n  }\n}\n\n// Re-export everything from this file\nexport * from './nlp';","size_bytes":27404},"server/lib/nlp.ts":{"content":"import { z } from \"zod\";\nimport { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from '@google/generative-ai';\nimport type { PlaceDetails } from \"@shared/schema\";\nimport { StructuredRequest } from \"@shared/types\";\nimport { nycAreas } from \"../data/new-york-areas\";\nimport { \n  findLocation, \n  parseActivity, \n  parseTimeExpression, \n  getDefaultTime,\n  expandRelativeTime,\n  LocationContext,\n  ActivityContext \n} from \"./languageProcessing\";\nimport { getApiKey, isFeatureEnabled, validateApiKey } from \"../config\";\nimport { processWithGemini, StructuredRequest as GeminiStructuredRequest } from './geminiProcessor';\nimport { validateAndNormalizeLocation, processLocationWithAIAndMaps } from './mapGeocoding';\nimport { parseAndNormalizeTime } from './timeUtils';\nimport { format, parseISO } from 'date-fns';\nimport { formatInTimeZone, toZonedTime } from 'date-fns-tz';\n\n// Configure Gemini model with safety settings\nlet genAI: GoogleGenerativeAI | null = null;\nlet model: any = null;\n\n// Initialize AI only if API key is available\n// Check if AI processing is enabled\nconsole.log(\"AI_PROCESSING feature flag status:\", isFeatureEnabled(\"AI_PROCESSING\"));\n\nif (isFeatureEnabled(\"AI_PROCESSING\")) {\n  try {\n    // Check if Gemini API key is valid\n    const geminiApiKey = getApiKey(\"GEMINI_API_KEY\");\n    console.log(\"GEMINI_API_KEY validation:\", validateApiKey(\"GEMINI_API_KEY\"));\n    \n    if (!geminiApiKey) {\n      console.error(\"Gemini API Key is missing or empty\");\n    } else if (!validateApiKey(\"GEMINI_API_KEY\")) {\n      console.error(\"Gemini API Key failed validation pattern\");\n    } else {\n      console.log(\"Initializing Gemini API with valid API key\");\n      \n      // Initialize Google Generative AI with centralized config\n      genAI = new GoogleGenerativeAI(geminiApiKey);\n      \n      // Configure Gemini model with safety settings\n      model = genAI.getGenerativeModel({\n        model: \"gemini-1.5-pro-latest\",\n        safetySettings: [\n          {\n            category: HarmCategory.HARM_CATEGORY_HARASSMENT,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n          {\n            category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n          {\n            category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n          {\n            category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,\n            threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,\n          },\n        ],\n      });\n      \n      console.log(\"Gemini API successfully initialized\");\n    }\n  } catch (err) {\n    console.error(\"Failed to initialize Gemini API:\", err);\n    // Leave genAI and model as null to trigger fallback handling\n  }\n}\n\n// Using the imported StructuredRequest interface from shared/types.ts\n\n// Define fixed time entry type for use in parsing\ntype FixedTimeEntry = {\n  location: string;\n  time: string;\n  type?: string;\n  // Additional search parameters for richer venue search\n  searchTerm?: string;\n  keywords?: string[];\n  minRating?: number;\n  displayTime?: string; // New property for formatted display time in NYC timezone\n  searchPreference?: string; // Specific user preference for the venue (e.g., \"sandwich place\")\n};\n\n/**\n * Convert Gemini structured request to the application's expected format\n */\nfunction convertGeminiToAppFormat(geminiResult: GeminiStructuredRequest | null): StructuredRequest | null {\n  console.log(\"Converting Gemini result to app format:\", JSON.stringify(geminiResult, null, 2));\n  \n  if (!geminiResult) {\n    return null;\n  }\n  \n  // Initialize the result structure\n  const appFormatRequest: StructuredRequest = {\n    startLocation: geminiResult.startLocation || \"Midtown\", // Default to Midtown Manhattan\n    destinations: [],\n    fixedTimes: [],\n    preferences: {\n      type: undefined,\n      requirements: []\n    }\n  };\n  \n  // Inspect the venuePreference data in the Gemini response\n  if (geminiResult.fixedTimeEntries && geminiResult.fixedTimeEntries.length > 0) {\n    geminiResult.fixedTimeEntries.forEach(entry => {\n      if (entry.searchParameters?.venuePreference) {\n        console.log(`Found raw venuePreference in Gemini fixed time entry: \"${entry.searchParameters.venuePreference}\" for activity \"${entry.activity}\"`);\n      }\n    });\n  }\n  \n  // Create a map to track unique activities by location and similar activity text\n  // This will help us avoid duplicates from both fixedTimeEntries and flexibleTimeEntries\n  const activityMap = new Map<string, FixedTimeEntry>();\n  \n  // Helper function to determine the most specific activity type\n  const determineActivityType = (activityText: string): string => {\n    const activityLower = activityText.toLowerCase();\n    \n    if (activityLower.includes('museum') || activityLower.includes('gallery') || activityLower.includes('exhibition')) {\n      return \"museum\";\n    } else if (activityLower.includes('lunch') || activityLower.includes('dinner') || \n               activityLower.includes('breakfast') || activityLower.includes('eat') || \n               activityLower.includes('restaurant') || activityLower.includes('food')) {\n      return \"restaurant\";\n    } else if (activityLower.includes('coffee') || activityLower.includes('cafe')) {\n      return \"cafe\";\n    } else if (activityLower.includes('park') || activityLower.includes('garden')) {\n      return \"park\";\n    } else if (activityLower.includes('shop') || activityLower.includes('store') || activityLower.includes('mall')) {\n      return \"shopping_mall\";\n    } else {\n      return \"attraction\";\n    }\n  };\n  \n  // Helper function to create a unique key for an activity at a location\n  const createActivityKey = (location: string, activityText: string): string => {\n    // Normalize the location and activity text to avoid case-sensitive duplicates\n    const normalizedLocation = location.toLowerCase();\n    const normalizedActivity = activityText.toLowerCase();\n    \n    return `${normalizedLocation}|${determineActivityType(normalizedActivity)}`;\n  };\n  \n  // Process fixed time entries if present\n  if (geminiResult.fixedTimeEntries && Array.isArray(geminiResult.fixedTimeEntries)) {\n    console.log(\"Raw fixed time entries from Gemini:\", JSON.stringify(geminiResult.fixedTimeEntries, null, 2));\n    for (const entry of geminiResult.fixedTimeEntries) {\n      if (entry && typeof entry === 'object' && entry.location && entry.time) {\n        // Parse time expressions using our enhanced timeUtils\n        let timeValue = entry.time;\n        let displayTime = '';\n        \n        // Process time values with our improved parser\n        if (typeof timeValue === 'string') {\n          // Parse times like \"noon\", \"around 3 PM\", etc.\n          const originalTime = timeValue;\n          timeValue = parseAndNormalizeTime(timeValue);\n          console.log(`Fixed time entry: Normalized time from \"${originalTime}\" to \"${timeValue}\"`);\n          \n          // Convert the normalized time string (HH:MM) to a proper timezone-aware datetime\n          const timeZone = 'America/New_York';\n          \n          // Use today's date but with time components from the normalized time string\n          const [hours, minutes] = timeValue.split(':').map(Number);\n          \n          // Get current date in NYC time zone\n          const now = new Date();\n          const nycTime = toZonedTime(now, timeZone);\n          \n          // Create a date based on NYC time zone's current date (to handle DST correctly)\n          const year = nycTime.getFullYear();\n          const month = nycTime.getMonth(); // month is 0-indexed\n          const day = nycTime.getDate();\n          \n          // Create a new date with the parsed time components but NYC date\n          const localDate = new Date(year, month, day, hours, minutes);\n          \n          // Convert to UTC by adding the timezone offset (in minutes)\n          const utcMillis = localDate.getTime() + (localDate.getTimezoneOffset() * 60000);\n          const utcDate = new Date(utcMillis);\n          \n          // Generate standard ISO string for backend use\n          const correctIsoTimestamp = utcDate.toISOString();\n          \n          // Format the display time for NYC timezone\n          const correctDisplayTime = formatInTimeZone(localDate, timeZone, 'h:mm a');\n          \n          // Store the ISO timestamp for backend processing\n          timeValue = correctIsoTimestamp;\n          displayTime = correctDisplayTime;\n          \n          console.log(`Correctly interpreted time \"${originalTime}\" as NYC time: ${correctDisplayTime} (${correctIsoTimestamp})`);\n        }\n        \n        // Determine the most appropriate activity type\n        const activityType = entry.searchParameters?.venueType || determineActivityType(entry.activity);\n        \n        // Create a key for this activity\n        const activityKey = createActivityKey(entry.location, entry.activity);\n        \n        // Check if there's a specific search preference from multiple possible locations\n        let searchPreference: string | undefined = undefined;\n        \n        // First check for the new top-level venuePreference field we added\n        if (entry.venuePreference) {\n          searchPreference = entry.venuePreference;\n          console.log(`Found venue preference in top-level field: \"${searchPreference}\"`);\n        }\n        // Then check if searchParameters.venuePreference exists\n        else if (entry.searchParameters?.venuePreference) {\n          searchPreference = entry.searchParameters.venuePreference;\n          console.log(`Found venue preference in searchParameters: \"${searchPreference}\"`);\n        }\n        // Finally try to extract from activity description if it contains venue-type keywords\n        else {\n          const activityDesc = entry.activity.toLowerCase();\n          const venueKeywords = [\n            \"authentic\", \"traditional\", \"hipster\", \"trendy\", \"upscale\", \n            \"casual\", \"artisanal\", \"specialty\", \"boutique\", \"unique\"\n          ];\n          \n          for (const keyword of venueKeywords) {\n            if (activityDesc.includes(keyword)) {\n              // Extract possible venue preference from activity description\n              const words = activityDesc.split(' ');\n              const keywordIndex = words.findIndex(w => w.includes(keyword));\n              \n              if (keywordIndex !== -1 && keywordIndex < words.length - 1) {\n                // Take up to 4 words after the keyword to capture the venue preference\n                const preference = words.slice(keywordIndex, keywordIndex + 4).join(' ');\n                console.log(`Extracted venue preference from activity description: \"${preference}\"`);\n                searchPreference = preference;\n                break;\n              }\n            }\n          }\n        }\n        \n        // Store in our map, potentially overwriting less specific entries\n        activityMap.set(activityKey, {\n          location: entry.location,\n          time: timeValue,\n          type: activityType,\n          searchTerm: entry.activity,\n          keywords: entry.searchParameters?.specificRequirements || undefined,\n          minRating: 4.0, // Default to high quality\n          displayTime: displayTime, // Add the display time for the frontend\n          searchPreference: searchPreference // Add user's specific venue preference\n        });\n        \n        console.log(`Processed fixed time entry: ${entry.activity} at ${entry.location}, time: ${timeValue}, type: ${activityType}`);\n      }\n    }\n  }\n  \n  // Process flexible time entries - THIS IS THE KEY FIX for the British Museum/Soho case\n  if (geminiResult.flexibleTimeEntries && Array.isArray(geminiResult.flexibleTimeEntries)) {\n    console.log(\"Raw flexible time entries from Gemini:\", JSON.stringify(geminiResult.flexibleTimeEntries, null, 2));\n    \n    for (const entry of geminiResult.flexibleTimeEntries) {\n      if (entry && typeof entry === 'object' && entry.location) {\n        // Convert time formats\n        let timeValue = entry.time || \"12:00\";\n        let displayTime = '';\n        \n        // Handle time periods using the timeUtils functions\n        if (typeof timeValue === 'string') {\n          // This will handle \"morning\", \"afternoon\", \"evening\", \"night\"\n          // as well as \"around noon\", \"around 3 PM\", etc.\n          const originalTime = timeValue;\n          timeValue = parseAndNormalizeTime(timeValue);\n          console.log(`Normalized time from \"${originalTime}\" to \"${timeValue}\"`);\n          \n          // Convert the normalized time string (HH:MM) to a proper timezone-aware datetime\n          const timeZone = 'America/New_York';\n          \n          // Use today's date but with time components from the normalized time string\n          const [hours, minutes] = timeValue.split(':').map(Number);\n          \n          // Get current date in NYC time zone\n          const now = new Date();\n          const nycTime = toZonedTime(now, timeZone);\n          \n          // Create a date based on NYC time zone's current date (to handle DST correctly)\n          const year = nycTime.getFullYear();\n          const month = nycTime.getMonth(); // month is 0-indexed\n          const day = nycTime.getDate();\n          \n          // Create a new date with the parsed time components but NYC date\n          const localDate = new Date(year, month, day, hours, minutes);\n          \n          // Convert to UTC by adding the timezone offset (in minutes)\n          const utcMillis = localDate.getTime() + (localDate.getTimezoneOffset() * 60000);\n          const utcDate = new Date(utcMillis);\n          \n          // Generate standard ISO string for backend use\n          const correctIsoTimestamp = utcDate.toISOString();\n          \n          // Format the display time for NYC timezone\n          const correctDisplayTime = formatInTimeZone(localDate, timeZone, 'h:mm a');\n          \n          // Store the ISO timestamp for backend processing\n          timeValue = correctIsoTimestamp;\n          displayTime = correctDisplayTime;\n          \n          console.log(`Correctly interpreted time \"${originalTime}\" as NYC time: ${correctDisplayTime} (${correctIsoTimestamp})`);\n        }\n        \n        // Determine the most appropriate activity type\n        const activityType = determineActivityType(entry.activity);\n        \n        // Create a key for this activity\n        const activityKey = createActivityKey(entry.location, entry.activity);\n        \n        // Check if there's a specific search preference from multiple possible locations\n        let searchPreference: string | undefined = undefined;\n        \n        // First check for the new top-level venuePreference field we added\n        if (entry.venuePreference) {\n          searchPreference = entry.venuePreference;\n          console.log(`Found venue preference in top-level field (flexible): \"${searchPreference}\"`);\n        }\n        // Then check if searchParameters.venuePreference exists\n        else if (entry.searchParameters?.venuePreference) {\n          searchPreference = entry.searchParameters.venuePreference;\n          console.log(`Found venue preference in searchParameters (flexible): \"${searchPreference}\"`);\n        }\n        // Finally try to extract from activity description if it contains venue-type keywords\n        else {\n          const activityDesc = entry.activity.toLowerCase();\n          const venueKeywords = [\n            \"authentic\", \"traditional\", \"hipster\", \"trendy\", \"upscale\", \n            \"casual\", \"artisanal\", \"specialty\", \"boutique\", \"unique\"\n          ];\n          \n          for (const keyword of venueKeywords) {\n            if (activityDesc.includes(keyword)) {\n              // Extract possible venue preference from activity description\n              const words = activityDesc.split(' ');\n              const keywordIndex = words.findIndex(w => w.includes(keyword));\n              \n              if (keywordIndex !== -1 && keywordIndex < words.length - 1) {\n                // Take up to 4 words after the keyword to capture the venue preference\n                const preference = words.slice(keywordIndex, keywordIndex + 4).join(' ');\n                console.log(`Extracted venue preference from flexible activity: \"${preference}\"`);\n                searchPreference = preference;\n                break;\n              }\n            }\n          }\n        }\n        \n        // Only add if we don't already have this activity, or if we're adding a more specific type\n        if (!activityMap.has(activityKey)) {\n          activityMap.set(activityKey, {\n            location: entry.location,\n            time: timeValue,\n            type: activityType,\n            searchTerm: entry.activity,\n            minRating: 4.0, // Default to high quality\n            displayTime: displayTime, // Add the display time for the frontend\n            searchPreference: searchPreference // Add user's specific venue preference\n          });\n          \n          console.log(`Processed flexible time entry: ${entry.activity} at ${entry.location}, time: ${timeValue}, type: ${activityType}`);\n        }\n      }\n    }\n  }\n  \n  // Convert our map of unique activities to the fixedTimes array\n  appFormatRequest.fixedTimes = Array.from(activityMap.values());\n  console.log(`Final de-duplicated activities count: ${appFormatRequest.fixedTimes.length}`);\n  \n  // If we have no start location but have activities, use the first activity location\n  if (!appFormatRequest.startLocation && appFormatRequest.fixedTimes.length > 0) {\n    appFormatRequest.startLocation = appFormatRequest.fixedTimes[0].location;\n    console.log(`No startLocation provided, using first activity location: ${appFormatRequest.startLocation}`);\n  }\n  \n  // Process other preferences if available\n  if (geminiResult.preferences) {\n    // Extract budget preferences if available\n    if (geminiResult.preferences.budget) {\n      appFormatRequest.preferences.type = geminiResult.preferences.budget;\n    }\n    \n    // Extract requirements/restrictions if available\n    if (Array.isArray(geminiResult.specialRequests)) {\n      appFormatRequest.preferences.requirements = geminiResult.specialRequests;\n    }\n  }\n  \n  // Sort fixed times chronologically\n  appFormatRequest.fixedTimes.sort((a, b) => {\n    if (!a.time) return -1;\n    if (!b.time) return 1;\n    return a.time.localeCompare(b.time);\n  });\n  \n  // Create destinations array from fixed time locations\n  const uniqueLocations = new Set<string>();\n  appFormatRequest.fixedTimes.forEach(entry => {\n    if (entry.location && entry.location !== \"New York\" && entry.location !== \"NYC\" && entry.location !== \"Midtown\") {\n      uniqueLocations.add(entry.location);\n    }\n  });\n  \n  appFormatRequest.destinations = Array.from(uniqueLocations);\n  \n  console.log(\"Converted app format request:\", JSON.stringify(appFormatRequest, null, 2));\n  return appFormatRequest;\n}\n\n// Extract locations with confidence scores\nfunction extractLocations(text: string): LocationContext[] {\n  const locations: LocationContext[] = [];\n\n  // Split text into potential location phrases\n  const phrases = text.split(/[,.]|\\s+(?:then|and|to|at)\\s+/);\n\n  for (const phrase of phrases) {\n    // Look for common NYC street name patterns like \"Wall St\" or \"5th Ave\"\n    const streetMatch = phrase.match(/\\b(wall\\s*st|fifth\\s*ave|5th\\s*avenue|broadway|times\\s*square|madison\\s*ave|lexington\\s*ave|park\\s*ave|canal\\s*st|mott\\s*st|mulberry\\s*st|bowery|houston\\s*st|bleecker\\s*st|christopher\\s*st|west\\s*4th|42nd\\s*st|34th\\s*st|14th\\s*st|canal\\s*st|grand\\s*st|delancey\\s*st)\\b/i);\n    if (streetMatch?.[1]) {\n      const streetName = streetMatch[1].trim();\n      console.log(`Found NYC street reference: \"${streetName}\"`);\n      \n      // Map common street abbreviations to full names\n      const normalizedStreet = streetName.toLowerCase()\n        .replace(/wall\\s*st/, \"Wall Street\")\n        .replace(/5th\\s*ave/, \"Fifth Avenue\")\n        .replace(/fifth\\s*ave/, \"Fifth Avenue\")\n        .replace(/madison\\s*ave/, \"Madison Avenue\")\n        .replace(/lexington\\s*ave/, \"Lexington Avenue\")\n        .replace(/park\\s*ave/, \"Park Avenue\")\n        .replace(/canal\\s*st/, \"Canal Street\")\n        .replace(/mott\\s*st/, \"Mott Street\")\n        .replace(/mulberry\\s*st/, \"Mulberry Street\")\n        .replace(/houston\\s*st/, \"Houston Street\")\n        .replace(/bleecker\\s*st/, \"Bleecker Street\")\n        .replace(/christopher\\s*st/, \"Christopher Street\")\n        .replace(/west\\s*4th/, \"West 4th Street\")\n        .replace(/42nd\\s*st/, \"42nd Street\")\n        .replace(/34th\\s*st/, \"34th Street\")\n        .replace(/14th\\s*st/, \"14th Street\")\n        .replace(/grand\\s*st/, \"Grand Street\")\n        .replace(/delancey\\s*st/, \"Delancey Street\");\n      \n      locations.push({\n        name: normalizedStreet,\n        confidence: 0.9,\n        type: \"street\"\n      });\n      continue;\n    }\n    \n    // Look for location indicators with prepositions (in, at, near, from)\n    const locationMatch = phrase.match(/(?:in|at|near|from)\\s+([A-Z][a-zA-Z\\s]+)/);\n    if (locationMatch?.[1]) {\n      const location = findLocation(locationMatch[1]);\n      if (location) {\n        locations.push(location);\n      }\n    }\n  }\n\n  return locations;\n}\n\n// Extract activities with their context\nfunction extractActivities(text: string): ActivityContext[] {\n  const activities: ActivityContext[] = [];\n\n  // Split text into activity segments - expanded to catch more transition words\n  const segments = text.split(/[,.]|\\s+(?:then|and|afterwards|later|after that|following that|next)\\s+/);\n\n  for (const segment of segments) {\n    // Expanded regex to capture more vague activity indicators\n    if (segment.match(/(?:want|like|need|do|have|get|see|visit|explore|enjoy|experience|something|activity)\\s+(.+)/) ||\n        segment.match(/(?:around|at|by|from|until|before|after)\\s+\\d{1,2}(?::\\d{2})?(?:\\s*[ap]m)?/) || // Time indicators\n        segment.match(/(?:in the|during the|for)\\s+(?:morning|afternoon|evening|night)/)) { // Period indicators\n      const activity = parseActivity(segment);\n      activities.push(activity);\n    }\n  }\n\n  return activities;\n}\n\n/**\n * Parse a natural language itinerary request into structured data\n * \n * @param query User's natural language request\n * @returns StructuredRequest object with parsed locations, activities and preferences\n */\nexport async function parseItineraryRequest(query: string): Promise<StructuredRequest> {\n  // We've already imported processWithGemini from './geminiProcessor'\n  \n  // Initialize basic fallback structure with direct extraction methods\n  const extractedLocations = extractLocations(query);\n  const extractedActivities = extractActivities(query);\n  \n  // Extract time from the query directly for 6PM, 9AM style inputs\n  const timeRegex = /(\\d{1,2})\\s*(am|pm)/i;\n  const timeMatch = query.match(timeRegex);\n  let timeFromQuery = null;\n  \n  if (timeMatch) {\n    const [_, hour, meridian] = timeMatch;\n    const parsedHour = parseInt(hour);\n    const hourIn24 = meridian.toLowerCase() === 'pm' && parsedHour < 12 ? parsedHour + 12 : parsedHour;\n    timeFromQuery = `${hourIn24.toString().padStart(2, '0')}:00`;\n  }\n\n  // Create fallback structure that will be used if AI processing fails\n  const fallbackStructure: StructuredRequest = {\n    startLocation: null,\n    destinations: extractedLocations.map(loc => loc.name),\n    fixedTimes: extractedActivities.length > 0 ? \n      extractedActivities.map(activity => {\n        const location = extractedLocations[0]?.name || \"Midtown\";\n        \n        // Try to extract time from the query directly if it's a simple time reference\n        const time = timeFromQuery || activity.timeContext?.preferredTime || \n              (activity.type === 'breakfast' ? '09:00' : \n               activity.type === 'lunch' ? '13:00' : \n               activity.type === 'dinner' ? '19:00' : '12:00');\n        \n        return {\n          location,\n          time,\n          type: activity.venueType || activity.type,\n          searchTerm: activity.naturalDescription\n        };\n      }) : \n      // If no activities extracted but we found a time, create an entry with that time\n      timeFromQuery ? [{\n        location: extractedLocations[0]?.name || \"Midtown\",\n        time: timeFromQuery,\n        type: 'activity',\n        searchTerm: query\n      }] : [],\n    preferences: {\n      requirements: extractedActivities\n        .filter(a => a.requirements)\n        .flatMap(a => a.requirements || [])\n    }\n  };\n\n  try {\n    // First attempt: Use the new Gemini processor\n    console.log(\"Attempting to process query with new Gemini processor\");\n    const rawGeminiResult = await processWithGemini(query);\n    \n    if (rawGeminiResult) {\n      console.log(\"Successfully processed query with new Gemini processor\");\n      console.log(\"Raw Gemini API response:\", JSON.stringify(rawGeminiResult, null, 2));\n      \n      // Convert from Gemini processor format to application format\n      const geminiResult = convertGeminiToAppFormat(rawGeminiResult);\n      \n      if (geminiResult) {\n        // We don't need to process flexible time entries here again.\n        // The convertGeminiToAppFormat function we just updated already \n        // handles both fixedTimeEntries and flexibleTimeEntries with proper de-duplication.\n        console.log(\"Using optimized Gemini result that was converted by convertGeminiToAppFormat function\");\n        console.log(`Gemini result contains ${geminiResult.fixedTimes.length} de-duplicated activities`);\n        \n        // Sort fixed times chronologically if they exist\n        if (geminiResult.fixedTimes) {\n          geminiResult.fixedTimes.sort((a, b) => {\n            if (!a.time) return -1;\n            if (!b.time) return 1;\n            return a.time.localeCompare(b.time);\n          });\n        }\n        \n        // Apply location validation and normalization when possible\n        try {\n          // Using imported functions directly\n          \n          // Create destinations array from fixed time locations\n          const uniqueLocations = new Set<string>();\n          geminiResult.fixedTimes.forEach(entry => {\n            if (entry.location && entry.location !== \"New York\" && entry.location !== \"NYC\" && entry.location !== \"Midtown\") {\n              uniqueLocations.add(entry.location);\n            }\n          });\n          \n          geminiResult.destinations = Array.from(uniqueLocations);\n          \n          // Process each destination\n          if (geminiResult.destinations.length > 0) {\n            const validatedDestinations = await Promise.all(\n              geminiResult.destinations.map(async (destination: string) => {\n                return await validateAndNormalizeLocation(destination);\n              })\n            );\n            \n            geminiResult.destinations = validatedDestinations.filter(Boolean);\n          }\n          \n          // Process each fixed time location\n          if (geminiResult.fixedTimes.length > 0) {\n            for (const fixedTime of geminiResult.fixedTimes) {\n              // Only process if location is generic but searchTerm contains hints\n              if ((fixedTime.location === \"New York\" || fixedTime.location === \"NYC\" || fixedTime.location === \"Midtown\") && fixedTime.searchTerm) {\n                const enhancedLocation = await processLocationWithAIAndMaps(fixedTime.searchTerm);\n                if (enhancedLocation && enhancedLocation !== \"New York\" && enhancedLocation !== \"NYC\" && enhancedLocation !== \"Midtown\") {\n                  fixedTime.location = enhancedLocation;\n                  console.log(`Enhanced fixed time location from generic to \"${enhancedLocation}\"`);\n                }\n              } else if (fixedTime.location) {\n                const validatedLocation = await validateAndNormalizeLocation(fixedTime.location);\n                if (validatedLocation) {\n                  fixedTime.location = validatedLocation;\n                }\n              }\n            }\n          }\n        } catch (error) {\n          console.warn(\"Location enhancement skipped due to error:\", error);\n        }\n        \n        // Debug the final processed output\n        console.log(\"Final processed Gemini result:\", JSON.stringify(geminiResult, null, 2));\n        return geminiResult;\n      }\n    }\n    \n    // If the new Gemini processor isn't available or fails, fall back to the original method\n    console.log(\"New Gemini processor unavailable or failed, falling back to original method\");\n    \n    // Skip Gemini processing if the feature is disabled or model initialization failed\n    if (!isFeatureEnabled(\"AI_PROCESSING\") || !model) {\n      console.log(\"AI processing skipped - using basic fallback structure\");\n      \n      // Even though we're using the fallback structure, let's improve it with Google Maps verification\n      // This will help improve the location data quality even without Gemini\n      try {\n        // Using imported functions directly\n        \n        // Process each destination\n        if (fallbackStructure.destinations.length > 0) {\n          const validatedDestinations = await Promise.all(\n            fallbackStructure.destinations.map(async (destination: string) => {\n              return await validateAndNormalizeLocation(destination);\n            })\n          );\n          \n          fallbackStructure.destinations = validatedDestinations.filter(Boolean);\n        }\n        \n        // Process each fixed time location\n        if (fallbackStructure.fixedTimes.length > 0) {\n          for (const fixedTime of fallbackStructure.fixedTimes) {\n            // Only process if location is explicitly set to \"London\" (generic) but searchTerm contains hints\n            if ((fixedTime.location === \"New York\" || fixedTime.location === \"NYC\" || fixedTime.location === \"Midtown\") && fixedTime.searchTerm) {\n              const enhancedLocation = await processLocationWithAIAndMaps(fixedTime.searchTerm);\n              if (enhancedLocation && enhancedLocation !== \"New York\" && enhancedLocation !== \"NYC\" && enhancedLocation !== \"Midtown\") {\n                fixedTime.location = enhancedLocation;\n                console.log(`Enhanced fixed time location from generic NYC reference to \"${enhancedLocation}\"`);\n              }\n            } else if (fixedTime.location) {\n              const validatedLocation = await validateAndNormalizeLocation(fixedTime.location);\n              if (validatedLocation) {\n                fixedTime.location = validatedLocation;\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error(\"Error during location enhancement:\", error);\n        // Continue with original fallback structure if enhancement fails\n      }\n      \n      return fallbackStructure;\n    }\n\n    // Try to use the original Gemini implementation for more intelligent parsing\n    try {\n      // Then use our comprehensive Gemini prompt for enhanced understanding\n      const prompt = `\nYou are a New York City travel planning expert with deep knowledge of NYC's geography, neighborhoods, and venues. Analyze this request carefully:\n\n\"${query}\"\n\nTASK: Provide a complete interpretation for creating a NYC itinerary with Google Places API integration.\n\nStep 1: Identify all NYC locations with full context:\n- Distinguish between neighborhoods (SoHo, Greenwich Village), landmarks (Empire State Building), and transport hubs (Grand Central)\n- For ambiguous references, clarify which specific NYC location is meant\n- Recognize colloquial area names and local terminology (The Village, Midtown, FiDi, etc.)\n\nStep 2: Understand all activities with venue-specific details:\n- Extract explicit activities (coffee, lunch, museum visit)\n- Infer implied activities based on context (\"something nice\" → what specifically?)\n- Capture qualitative requirements (quiet, fancy, historic, family-friendly)\n- Note when activities are vague and need appropriate venue suggestions\n\nStep 3: Interpret time references carefully:\n- Convert all time formats to 24-hour format\n- Handle time ranges correctly (e.g., \"between 2-4pm\" → 14:00-16:00)\n- Interpret relative times (morning, afternoon, evening) \n- Avoid creating duplicate activities for similar times\n\nStep 4: Create optimal Google Places search parameters:\n- Provide the exact search term to use (e.g., \"specialty coffee shop\" rather than just \"coffee\")\n- Specify the correct Google Places 'type' parameter (cafe, restaurant, museum, etc.)\n- Suggest additional keywords that will improve search relevance\n- Recommend minimum rating thresholds based on quality expectations\n\nRETURN ONLY this JSON structure:\n{\n  \"startLocation\": string | null,\n  \"destinations\": string[],\n  \"activities\": [\n    {\n      \"description\": string, // Original activity description from request\n      \"location\": string, // Where this should happen\n      \"time\": string, // Time in 24h format or period name like \"afternoon\"\n      \"searchParameters\": { // CRITICAL - Parameters for Google Places API\n        \"searchTerm\": string, // Optimized search term (e.g., \"quiet cafe with workspace\")\n        \"type\": string, // Google Places API type parameter (e.g., \"cafe\", \"restaurant\")\n        \"keywords\": string[], // Additional keywords to improve search\n        \"minRating\": number, // Recommended minimum rating (1.0-5.0)\n        \"requireOpenNow\": boolean // Whether time constraints require the venue to be open now\n      },\n      \"requirements\": string[] // Special requirements like \"quiet\", \"outdoor seating\"\n    }\n  ],\n  \"preferences\": {\n    \"venueQualities\": string[], // Qualities applying to all venues (upscale, budget, etc.)\n    \"restrictions\": string[] // Restrictions applying to all venues (no chains, etc.)\n  }\n}`;\n\n      try {\n        const result = await model.generateContent(prompt);\n        const responseText = result.response.text();\n        \n        if (!responseText || responseText.trim() === '') {\n          throw new Error(\"Empty response received from language model\");\n        }\n      \n        // Clean and parse the response\n        let cleanedContent = responseText.trim();\n        \n        // Remove markdown code block syntax if present\n        if (cleanedContent.startsWith('```json') || cleanedContent.startsWith('```')) {\n          const firstBlockEnd = cleanedContent.indexOf('\\n');\n          const lastBlockStart = cleanedContent.lastIndexOf('```');\n          \n          if (firstBlockEnd !== -1) {\n            cleanedContent = cleanedContent.substring(firstBlockEnd + 1);\n            if (lastBlockStart !== -1 && lastBlockStart > firstBlockEnd) {\n              cleanedContent = cleanedContent.substring(0, lastBlockStart).trim();\n            }\n          }\n        }\n        \n        // Remove any extra characters after the last closing brace\n        const lastBrace = cleanedContent.lastIndexOf('}');\n        if (lastBrace !== -1) {\n          cleanedContent = cleanedContent.substring(0, lastBrace + 1);\n        }\n        \n        // Remove comments from JSON\n        cleanedContent = cleanedContent\n          .replace(/\\/\\/.*$/gm, '')\n          .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n        \n        // Parse the JSON response with validation\n        let parsedResponse;\n        try {\n          parsedResponse = JSON.parse(cleanedContent);\n        } catch (error) {\n          // Try to extract JSON by looking for { and }\n          const jsonStart = cleanedContent.indexOf('{');\n          const jsonEnd = cleanedContent.lastIndexOf('}');\n          \n          if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {\n            const extractedJson = cleanedContent.substring(jsonStart, jsonEnd + 1);\n            parsedResponse = JSON.parse(extractedJson);\n          } else {\n            throw new Error(`Failed to parse response as JSON: ${error}`);\n          }\n        }\n        \n        // Simple validation: Check that we received some data\n        if (!parsedResponse || (typeof parsedResponse !== 'object') || !Object.keys(parsedResponse).length) {\n          throw new Error(\"JSON response is empty or invalid\");\n        }\n        \n        // Start with a copy of the fallback structure to ensure we have all required fields\n        const parsed: StructuredRequest = {\n          startLocation: parsedResponse.startLocation || null,\n          destinations: Array.isArray(parsedResponse.destinations) ? parsedResponse.destinations : [],\n          fixedTimes: [],\n          preferences: {\n            type: parsedResponse.preferences?.type || undefined,\n            requirements: [\n              ...(parsedResponse.preferences?.restrictions || []),\n              ...(parsedResponse.preferences?.venueQualities || [])\n            ]\n          }\n        };\n        \n        // Map activities to fixed times with enhanced search parameters\n        if (Array.isArray(parsedResponse.activities) && parsedResponse.activities.length > 0) {\n          // Using the FixedTimeEntry type defined at the top of the file\n          \n          parsed.fixedTimes = parsedResponse.activities.map((activity: any): FixedTimeEntry => {\n            // Convert time formats and handle special cases\n            let timeValue = activity.time || \"12:00\";\n            \n            // Process period-based times\n            if (timeValue.toLowerCase().includes('morning')) {\n              timeValue = '09:00';\n            } else if (timeValue.toLowerCase().includes('afternoon')) {\n              timeValue = '14:00';\n            } else if (timeValue.toLowerCase().includes('evening')) {\n              timeValue = '19:00';\n            } else if (timeValue.toLowerCase().includes('night')) {\n              timeValue = '21:00';\n            }\n            \n            return {\n              location: activity.location || \"Midtown\",\n              time: timeValue,\n              type: activity.searchParameters?.type,\n              searchTerm: activity.searchParameters?.searchTerm || activity.description,\n              keywords: activity.searchParameters?.keywords || [],\n              minRating: activity.searchParameters?.minRating || 3.5\n            };\n          });\n          \n          // Ensure we have at least the preference requirements\n          if (Array.isArray(parsedResponse.activities)) {\n            for (const activity of parsedResponse.activities) {\n              if (Array.isArray(activity.requirements)) {\n                parsed.preferences.requirements = [\n                  ...(parsed.preferences.requirements || []),\n                  ...activity.requirements\n                ];\n              }\n            }\n          }\n          \n          // Ensure preferences is an array if requirements exist\n          if (parsed.preferences.requirements && parsed.preferences.requirements.length > 0) {\n            // Deduplicate the requirements array\n            parsed.preferences.requirements = Array.from(new Set(parsed.preferences.requirements));\n          }\n        } else {\n          // If no activities were extracted, fallback to our basic extraction\n          parsed.fixedTimes = fallbackStructure.fixedTimes;\n        }\n        \n        // Ensure we have destination information\n        if ((!parsed.destinations || parsed.destinations.length === 0) && extractedLocations.length > 0) {\n          parsed.destinations = extractedLocations.map(loc => loc.name);\n        }\n        \n        // Add a smart default for start location if not specified\n        if (!parsed.startLocation && parsed.destinations && parsed.destinations.length > 0) {\n          // Use the first destination as default starting point\n          parsed.startLocation = parsed.destinations[0];\n        }\n        \n        // Remove duplicates from fixed times by checking for similar locations and times\n        const stringified = parsed.fixedTimes.map((item: FixedTimeEntry) => JSON.stringify(item));\n        const uniqueItems = new Set(stringified);\n        parsed.fixedTimes = Array.from(uniqueItems).map(str => JSON.parse(str));\n        \n        // Sort fixed times chronologically\n        parsed.fixedTimes.sort((a, b) => {\n          if (!a.time) return -1;\n          if (!b.time) return 1;\n          return a.time.localeCompare(b.time);\n        });\n        \n        // Sort fixed times chronologically\n        parsed.fixedTimes.sort((a, b) => {\n          if (!a.time) return -1;\n          if (!b.time) return 1;\n          return a.time.localeCompare(b.time);\n        });\n\n        return parsed;\n\n      } catch (error) {\n        // Log error details without excessive output\n        console.error(\"Error during Gemini API processing:\", {\n          errorMessage: error instanceof Error ? error.message : 'Unknown error',\n          query: query.substring(0, 100) + (query.length > 100 ? '...' : '')\n        });\n        \n        return fallbackStructure;\n      }\n    } catch (error) {\n      // Log error details while avoiding excessive console output\n      console.error(\"Fatal error in parseItineraryRequest:\", {\n        errorType: error instanceof Error ? error.constructor.name : typeof error,\n        message: error instanceof Error ? error.message : String(error),\n        query: query.substring(0, 100) + (query.length > 100 ? '...' : '')\n      });\n\n      return fallbackStructure;\n    }\n  } catch (error) {\n    // This is the outer catch block to handle any errors in the entire function\n    console.error(\"Catastrophic error in parseItineraryRequest:\", {\n      errorType: error instanceof Error ? error.constructor.name : typeof error,\n      message: error instanceof Error ? error.message : String(error),\n      query: query.substring(0, 100) + (query.length > 100 ? '...' : '')\n    });\n    \n    return fallbackStructure;\n  }\n}","size_bytes":41667},"server/lib/testPlaces.ts":{"content":"\nimport { searchPlace } from './googlePlaces';\n\nasync function testLandmarks() {\n  const testCases = [\n    {\n      name: 'Basic landmark query',\n      query: 'Green Park',\n      options: {}\n    },\n    {\n      name: 'Full address query',\n      query: 'Green Park, London, UK',\n      options: {}\n    },\n    {\n      name: 'Landmark with type',\n      query: 'Green Park',\n      options: { type: 'park' }\n    },\n    {\n      name: 'Landmark with rating filter',\n      query: 'Green Park',\n      options: { minRating: 4.0 }\n    },\n    {\n      name: 'Alternative landmark names',\n      query: 'The Green Park',\n      options: {}\n    }\n  ];\n\n  console.log('Starting landmark recognition tests...\\n');\n\n  for (const test of testCases) {\n    console.log(`\\n=== Test Case: ${test.name} ===`);\n    console.log(`Query: \"${test.query}\"`);\n    console.log('Options:', test.options);\n    \n    try {\n      const result = await searchPlace(test.query, test.options);\n      console.log('Success:', !!result);\n      console.log('Response:', result ? {\n        name: result.name,\n        formattedAddress: result.formatted_address,\n        types: result.types,\n        placeId: result.place_id,\n        rating: result.rating,\n        location: result.geometry?.location\n      } : 'No results');\n    } catch (error) {\n      console.error('Error:', error.message);\n    }\n    console.log('===============================\\n');\n  }\n}\n\ntestLandmarks().catch(console.error);\n","size_bytes":1446},"server/lib/timeUtils.ts":{"content":"/**\n * Time Utilities Module\n * \n * This module provides functions for parsing and handling time-related operations\n * for the itinerary planning application.\n * \n * All time operations use America/New_York timezone unless otherwise specified.\n */\n\nimport { format as formatDateFns } from 'date-fns';\nimport { formatInTimeZone, toZonedTime } from 'date-fns-tz';\n\n// Default timezone for NYC\nexport const NYC_TIMEZONE = 'America/New_York';\n\n/**\n * Parse and normalize a time string into 24-hour format (HH:MM)\n * \n * This function handles various time formats including:\n * - 12-hour format (e.g. \"6pm\", \"3 PM\", \"10:30am\")\n * - 24-hour format (e.g. \"14:00\", \"18:00\")\n * - Relative time expressions (e.g. \"morning\", \"afternoon\", \"evening\")\n * \n * @param timeStr String representation of time to parse\n * @returns Normalized time string in 24-hour format (HH:MM)\n */\nexport function parseAndNormalizeTime(timeStr: string): string {\n  if (!timeStr) return \"12:00\"; // Default to noon if no time provided\n  \n  // First, check if it's already in HH:MM format\n  if (/^\\d{1,2}:\\d{2}$/.test(timeStr)) {\n    const [hours, minutes] = timeStr.split(':').map(Number);\n    // Ensure hours are within valid range\n    const validHours = Math.min(Math.max(hours, 0), 23);\n    const validMinutes = Math.min(Math.max(minutes, 0), 59);\n    \n    return `${validHours.toString().padStart(2, '0')}:${validMinutes.toString().padStart(2, '0')}`;\n  }\n  \n  // Handle relative time periods (morning, afternoon, evening, night)\n  const timeOfDay = timeStr.toLowerCase().trim();\n  \n  // Extract time from \"around X\" phrases first\n  const aroundTimeMatch = timeOfDay.match(/around\\s+(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm)?/i);\n  if (aroundTimeMatch) {\n    // This matches phrases like \"around 3\" or \"around 3pm\" or \"around 3:30 PM\"\n    let [_, hours, minutes, meridian] = aroundTimeMatch;\n    let hoursNum = parseInt(hours);\n    \n    // Handle meridian (AM/PM) if provided\n    if (meridian) {\n      const isPM = meridian.toLowerCase().startsWith('p');\n      // Handle 12 AM -> 00:00, 12 PM -> 12:00\n      if (hoursNum === 12) {\n        hoursNum = isPM ? 12 : 0;\n      } else if (isPM) {\n        hoursNum += 12;\n      }\n    } else {\n      // If no AM/PM provided, assume PM for 1-11 during the day\n      if (hoursNum >= 1 && hoursNum <= 11) {\n        hoursNum += 12;\n      }\n    }\n    \n    const minutesNum = minutes ? parseInt(minutes) : 0;\n    return `${hoursNum.toString().padStart(2, '0')}:${minutesNum.toString().padStart(2, '0')}`;\n  }\n  \n  // Standard time periods\n  if (['morning', 'breakfast', 'dawn', 'early'].some(term => timeOfDay.includes(term))) {\n    return \"09:00\"; // 9 AM for morning\n  }\n  if (['noon', 'midday', 'lunch'].some(term => timeOfDay.includes(term))) {\n    return \"12:00\"; // 12 PM for noon\n  }\n  if (['afternoon', 'tea', 'post-lunch'].some(term => timeOfDay.includes(term))) {\n    return \"15:00\"; // 3 PM for afternoon\n  }\n  if (['evening', 'dinner', 'sunset'].some(term => timeOfDay.includes(term))) {\n    return \"18:00\"; // 6 PM for evening\n  }\n  if (['night', 'late', 'drinks', 'pub', 'bar', 'club'].some(term => timeOfDay.includes(term))) {\n    return \"21:00\"; // 9 PM for night/nightlife\n  }\n  \n  // Parse 12-hour format with meridian (am/pm)\n  const meridianMatch = timeStr.match(/(\\d{1,2})(?::(\\d{2}))?\\s*(am|pm|a\\.m\\.|p\\.m\\.)/i);\n  if (meridianMatch) {\n    let [_, hours, minutes, meridian] = meridianMatch;\n    const isPM = meridian.toLowerCase().startsWith('p');\n    \n    let hoursNum = parseInt(hours);\n    // Handle 12 AM -> 00:00, 12 PM -> 12:00\n    if (hoursNum === 12) {\n      hoursNum = isPM ? 12 : 0;\n    } else if (isPM) {\n      hoursNum += 12;\n    }\n    \n    const minutesNum = minutes ? parseInt(minutes) : 0;\n    \n    return `${hoursNum.toString().padStart(2, '0')}:${minutesNum.toString().padStart(2, '0')}`;\n  }\n  \n  // Handle simple hour mentions like \"at 6\" (assume PM for 1-11, AM for 12)\n  const simpleHourMatch = timeStr.match(/\\b(?:at|around|by|from)\\s+(\\d{1,2})\\b/i);\n  if (simpleHourMatch) {\n    const hourNum = parseInt(simpleHourMatch[1]);\n    const fullText = timeStr.toLowerCase();\n    \n    // Context-aware time parsing\n    // For dinner, steak, evening activities, assume evening/night hours\n    const isEveningContext = fullText.includes('dinner') || \n                            fullText.includes('steak') || \n                            fullText.includes('evening') || \n                            fullText.includes('night') ||\n                            fullText.includes('drinks');\n                            \n    // For breakfast, coffee, morning activities, assume morning hours\n    const isMorningContext = fullText.includes('breakfast') || \n                            fullText.includes('coffee') ||\n                            fullText.includes('morning') ||\n                            fullText.includes('early');\n    \n    // For lunch, afternoon activities, assume afternoon hours\n    const isAfternoonContext = fullText.includes('lunch') || \n                              fullText.includes('afternoon');\n    \n    // Make time adjustments based on context\n    let adjusted = hourNum;\n    \n    if (hourNum >= 1 && hourNum <= 11) {\n      if (isEveningContext && hourNum >= 5) {\n        // Evening context - use PM time (5-11 PM)\n        adjusted = hourNum + 12;\n        console.log(`Evening context detected in \"${timeStr}\", adjusted ${hourNum} to ${adjusted}:00`);\n      } else if (isMorningContext) {\n        // Morning context - keep as AM time\n        adjusted = hourNum;\n        console.log(`Morning context detected in \"${timeStr}\", keeping as ${adjusted}:00 AM`);\n      } else if (isAfternoonContext) {\n        // Afternoon context - use PM time for 1-5\n        adjusted = hourNum + 12;\n        console.log(`Afternoon context detected in \"${timeStr}\", adjusted ${hourNum} to ${adjusted}:00`);\n      } else {\n        // Default behavior - assume PM for 1-11 in absence of specific context\n        adjusted = hourNum + 12;\n        console.log(`No specific context in \"${timeStr}\", assuming PM, adjusted ${hourNum} to ${adjusted}:00`);\n      }\n    }\n    \n    return `${adjusted.toString().padStart(2, '0')}:00`;\n  }\n  \n  // If we can't parse it, return a reasonable default (noon)\n  console.warn(`Could not parse time string: \"${timeStr}\", defaulting to noon`);\n  return \"12:00\";\n}\n\n/**\n * Determines if a time is in the morning (before noon)\n */\nexport function isMorning(timeStr: string): boolean {\n  const normalized = parseAndNormalizeTime(timeStr);\n  const [hours] = normalized.split(':').map(Number);\n  return hours >= 5 && hours < 12;\n}\n\n/**\n * Determines if a time is in the afternoon (12pm-5pm)\n */\nexport function isAfternoon(timeStr: string): boolean {\n  const normalized = parseAndNormalizeTime(timeStr);\n  const [hours] = normalized.split(':').map(Number);\n  return hours >= 12 && hours < 17;\n}\n\n/**\n * Determines if a time is in the evening (5pm-9pm)\n */\nexport function isEvening(timeStr: string): boolean {\n  const normalized = parseAndNormalizeTime(timeStr);\n  const [hours] = normalized.split(':').map(Number);\n  return hours >= 17 && hours < 21;\n}\n\n/**\n * Determines if a time is at night (9pm-5am)\n */\nexport function isNight(timeStr: string): boolean {\n  const normalized = parseAndNormalizeTime(timeStr);\n  const [hours] = normalized.split(':').map(Number);\n  return hours >= 21 || hours < 5;\n}\n\n/**\n * Format a time string for display (e.g. \"14:30\" to \"2:30 PM\")\n * Uses the NYC timezone for consistent time display\n * \n * @param timeStr String representation of time to format\n * @param format Optional date-fns format string (defaults to 'h:mm a')\n * @returns Formatted time string in NYC timezone\n */\nexport function formatTimeForDisplay(timeStr: string, format: string = 'h:mm a'): string {\n  // First normalize the time string\n  const normalized = parseAndNormalizeTime(timeStr);\n  \n  // Check if timeStr is already a full ISO timestamp\n  if (timeStr.includes('T') && timeStr.includes('Z')) {\n    // If it's already an ISO string, use it directly\n    try {\n      const date = new Date(timeStr);\n      return formatInTimeZone(date, NYC_TIMEZONE, format);\n    } catch (err) {\n      console.warn(`Could not parse ISO timestamp: ${timeStr}, falling back to manual parsing`);\n      // Fall through to the manual parsing below\n    }\n  }\n  \n  // Extract hours and minutes\n  const [hoursStr, minutesStr] = normalized.split(':');\n  const hours = parseInt(hoursStr);\n  const minutes = parseInt(minutesStr);\n  \n  // Create a date with today's date and the parsed time\n  const date = new Date();\n  date.setHours(hours, minutes, 0, 0);\n  \n  // Convert to NYC timezone and format\n  const nycDate = toZonedTime(date, NYC_TIMEZONE);\n  return formatInTimeZone(nycDate, NYC_TIMEZONE, format);\n}\n\n/**\n * Add minutes to a time string and return the new time\n * Handles timezone-aware calculations in NYC timezone\n * \n * @param timeStr String representation of time\n * @param minutesToAdd Number of minutes to add\n * @returns New time string in HH:MM format (24-hour)\n */\nexport function addMinutesToTime(timeStr: string, minutesToAdd: number): string {\n  // Check if timeStr is already an ISO timestamp\n  if (timeStr.includes('T') && timeStr.includes('Z')) {\n    try {\n      // Parse the ISO timestamp\n      const date = new Date(timeStr);\n      \n      // Convert to NYC timezone\n      const nycDate = toZonedTime(date, NYC_TIMEZONE);\n      \n      // Add minutes\n      nycDate.setMinutes(nycDate.getMinutes() + minutesToAdd);\n      \n      // Format and return as HH:MM\n      return formatInTimeZone(nycDate, NYC_TIMEZONE, 'HH:mm');\n    } catch (err) {\n      console.warn(`Could not parse ISO timestamp: ${timeStr}, falling back to manual parsing`);\n      // Fall through to the manual parsing below\n    }\n  }\n  \n  // Handle regular HH:MM time string\n  const normalized = parseAndNormalizeTime(timeStr);\n  const [hours, minutes] = normalized.split(':').map(Number);\n  \n  // Create a date object with the current date\n  const date = new Date();\n  \n  // Set the hours and minutes\n  date.setHours(hours, minutes, 0, 0);\n  \n  // Convert to NYC timezone\n  const nycDate = toZonedTime(date, NYC_TIMEZONE);\n  \n  // Add the minutes\n  nycDate.setMinutes(nycDate.getMinutes() + minutesToAdd);\n  \n  // Return formatted time string\n  return formatInTimeZone(nycDate, NYC_TIMEZONE, 'HH:mm');\n}\n\n/**\n * Calculate the time difference in minutes between two time strings\n * Handles timezone-aware calculations in NYC timezone\n * \n * @param startTimeStr Start time string (either HH:MM or ISO timestamp)\n * @param endTimeStr End time string (either HH:MM or ISO timestamp)\n * @returns Number of minutes between the two times\n */\nexport function getMinutesBetweenTimes(startTimeStr: string, endTimeStr: string): number {\n  // Process start time\n  let startDate: Date;\n  if (startTimeStr.includes('T') && startTimeStr.includes('Z')) {\n    // ISO timestamp\n    startDate = new Date(startTimeStr);\n  } else {\n    // Parse HH:MM format\n    const start = parseAndNormalizeTime(startTimeStr);\n    const [startHours, startMinutes] = start.split(':').map(Number);\n    \n    startDate = new Date();\n    startDate.setHours(startHours, startMinutes, 0, 0);\n  }\n  \n  // Process end time\n  let endDate: Date;\n  if (endTimeStr.includes('T') && endTimeStr.includes('Z')) {\n    // ISO timestamp\n    endDate = new Date(endTimeStr);\n  } else {\n    // Parse HH:MM format\n    const end = parseAndNormalizeTime(endTimeStr);\n    const [endHours, endMinutes] = end.split(':').map(Number);\n    \n    endDate = new Date();\n    endDate.setHours(endHours, endMinutes, 0, 0);\n  }\n  \n  // Convert both dates to NYC timezone\n  const startNYC = toZonedTime(startDate, NYC_TIMEZONE);\n  const endNYC = toZonedTime(endDate, NYC_TIMEZONE);\n  \n  // Handle times that cross midnight\n  if (endNYC < startNYC) {\n    endNYC.setDate(endNYC.getDate() + 1);\n  }\n  \n  // Calculate difference in minutes\n  return Math.round((endNYC.getTime() - startNYC.getTime()) / (1000 * 60));\n}\n\n/**\n * Converts a time string to an ISO timestamp in NYC timezone\n * \n * @param timeStr Time string to convert (HH:MM format or natural language)\n * @returns ISO timestamp string representing the time in NYC timezone\n */\nexport function timeStringToNYCISOString(timeStr: string): string {\n  // First normalize the time to HH:MM format\n  const normalized = parseAndNormalizeTime(timeStr);\n  \n  // Split hours and minutes\n  const [hours, minutes] = normalized.split(':').map(Number);\n  \n  // Create a date with today's date\n  const date = new Date();\n  date.setHours(hours, minutes, 0, 0);\n  \n  // Convert to NYC timezone\n  const nycDate = toZonedTime(date, NYC_TIMEZONE);\n  \n  // Return ISO string\n  return nycDate.toISOString();\n}\n\n/**\n * Creates a formatted display time string from an ISO timestamp\n * \n * @param isoTimestamp ISO timestamp to format\n * @param format Optional format string (defaults to 'h:mm a')\n * @returns Formatted time string in NYC timezone\n */\nexport function formatISOToNYCTime(isoTimestamp: string, format: string = 'h:mm a'): string {\n  try {\n    const date = new Date(isoTimestamp);\n    return formatInTimeZone(date, NYC_TIMEZONE, format);\n  } catch (err) {\n    console.warn(`Invalid ISO timestamp: ${isoTimestamp}, returning as-is`);\n    return isoTimestamp;\n  }\n}","size_bytes":13264},"server/lib/weatherService.ts":{"content":"import { PlaceDetails } from '@shared/schema';\nimport { getApiKey, isFeatureEnabled } from '../config';\n\n// API configuration\nconst WEATHER_API_URL = 'https://api.openweathermap.org/data/2.5/forecast';\n\n// Set up a cache to avoid redundant API calls\ninterface CacheEntry {\n  data: any;\n  timestamp: number;\n}\n\n// Weather data cache with location key (rounded lat/lng) as key\nconst weatherCache = new Map<string, CacheEntry>();\nconst CACHE_DURATION = 30 * 60 * 1000; // 30 minutes in milliseconds\n\n/**\n * Generate a cache key from coordinates (rounded to avoid excessive API calls for nearby locations)\n */\nfunction getCacheKey(lat: number, lng: number): string {\n  // Round to 2 decimal places to group nearby locations\n  const roundedLat = Math.round(lat * 100) / 100;\n  const roundedLng = Math.round(lng * 100) / 100;\n  return `${roundedLat},${roundedLng}`;\n}\n\n/**\n * Fetch weather forecast for a location\n * Uses caching to reduce API calls\n * \n * @param latitude Location latitude\n * @param longitude Location longitude\n * @returns Weather forecast data\n */\nexport async function getWeatherForecast(latitude: number, longitude: number): Promise<any> {\n  const cacheKey = getCacheKey(latitude, longitude);\n  const cachedData = weatherCache.get(cacheKey);\n  \n  // Return cached data if it exists and is recent\n  if (cachedData && (Date.now() - cachedData.timestamp < CACHE_DURATION)) {\n    console.log(`Using cached weather data for ${cacheKey}`);\n    return cachedData.data;\n  }\n  \n  // No valid cache entry, fetch from API\n  console.log(`Fetching weather data for ${cacheKey}`);\n  \n  // Check if weather feature is enabled\n  if (!isFeatureEnabled(\"WEATHER_AWARENESS\")) {\n    throw new Error('Weather API feature is disabled - missing API key');\n  }\n  \n  // Construct API URL with params\n  const url = new URL(WEATHER_API_URL);\n  url.searchParams.append('lat', latitude.toString());\n  url.searchParams.append('lon', longitude.toString());\n  url.searchParams.append('units', 'metric'); // Use Celsius\n  url.searchParams.append('cnt', '24'); // 24 forecasts (3-hour intervals for 3 days)\n  url.searchParams.append('appid', getApiKey(\"WEATHER\", true)); // Will throw if key missing\n  \n  try {\n    const response = await fetch(url.toString());\n    \n    if (!response.ok) {\n      throw new Error(`Weather API error: ${response.status} ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    // Cache the result\n    weatherCache.set(cacheKey, {\n      data,\n      timestamp: Date.now()\n    });\n    \n    return data;\n  } catch (error) {\n    console.error('Error fetching weather data:', error);\n    throw error;\n  }\n}\n\n/**\n * Determine if a venue is primarily outdoors based on its place types\n * \n * @param types Array of place types from Google Places API\n * @returns boolean indicating if the venue is outdoor\n */\nexport function isVenueOutdoor(types: string[]): boolean {\n  const outdoorTypes = [\n    'park',\n    'campground',\n    'natural_feature',\n    'point_of_interest',\n    'tourist_attraction',\n    'zoo'\n  ];\n  \n  // Consider strong indoor types that should override outdoor classification\n  const strongIndoorTypes = [\n    'museum',\n    'restaurant',\n    'cafe',\n    'bar',\n    'movie_theater',\n    'shopping_mall',\n    'department_store',\n    'library'\n  ];\n  \n  // Check for strong indoor types first (these override outdoor classification)\n  if (types.some(type => strongIndoorTypes.includes(type))) {\n    return false;\n  }\n  \n  // Check if any type suggests an outdoor venue\n  return types.some(type => outdoorTypes.includes(type));\n}\n\n/**\n * Check if the weather is suitable for outdoor activities at a given time\n * \n * @param weatherData Weather forecast data\n * @param dateTime Date and time to check weather for\n * @returns boolean indicating if weather is suitable for outdoor activities\n */\nexport function isWeatherSuitableForOutdoor(weatherData: any, dateTime: Date): boolean {\n  // Find the closest forecast to the given time\n  const targetTimestamp = Math.floor(dateTime.getTime() / 1000);\n  \n  if (!weatherData.list || !Array.isArray(weatherData.list)) {\n    console.warn('No forecast data available');\n    return true; // Default to true if no data\n  }\n  \n  // Find the closest forecast to the target time\n  let closestForecast = weatherData.list[0];\n  let minTimeDiff = Math.abs(targetTimestamp - closestForecast.dt);\n  \n  for (const forecast of weatherData.list) {\n    const timeDiff = Math.abs(targetTimestamp - forecast.dt);\n    if (timeDiff < minTimeDiff) {\n      closestForecast = forecast;\n      minTimeDiff = timeDiff;\n    }\n  }\n  \n  // Define conditions that make outdoor activities less enjoyable\n  const badWeatherConditions = [\n    'Rain', 'Thunderstorm', 'Snow', 'Drizzle'\n  ];\n  \n  const weatherMain = closestForecast.weather[0].main;\n  const temperature = closestForecast.main.temp;\n  \n  // Check if weather conditions are unfavorable\n  const isBadWeather = badWeatherConditions.includes(weatherMain);\n  const isTooHot = temperature > 30; // Too hot (above 30°C)\n  const isTooCold = temperature < 5;  // Too cold (below 5°C)\n  \n  return !isBadWeather && !isTooHot && !isTooCold;\n}\n\n/**\n * Get a weather-aware venue recommendation\n * If the original venue is outdoor and weather is bad, it will\n * try to provide an indoor alternative\n * \n * @param place Original place\n * @param alternatives Alternative places\n * @param latitude Location latitude\n * @param longitude Location longitude\n * @param visitTime Planned visit time\n */\nexport async function getWeatherAwareVenue(\n  place: PlaceDetails,\n  alternatives: PlaceDetails[],\n  latitude: number,\n  longitude: number,\n  visitTime: Date\n): Promise<{venue: PlaceDetails, weatherSuitable: boolean}> {\n  // Default to the original place if anything fails\n  let bestVenue = place;\n  let isWeatherSuitable = true;\n  \n  try {\n    // Skip weather check if there are no alternatives or weather feature is disabled\n    if (!alternatives || alternatives.length === 0 || !isFeatureEnabled(\"WEATHER_AWARENESS\")) {\n      console.log(\"Skipping weather check - no alternatives or weather feature disabled\");\n      return { venue: place, weatherSuitable: true };\n    }\n    \n    // Check if original place is outdoors\n    if (place.types && isVenueOutdoor(place.types)) {\n      // Try to fetch weather data\n      try {\n        const weatherData = await getWeatherForecast(latitude, longitude);\n        \n        // Check if weather is suitable for outdoor activities\n        isWeatherSuitable = isWeatherSuitableForOutdoor(weatherData, visitTime);\n        \n        // If weather is bad for outdoor activities, recommend an indoor alternative\n        if (!isWeatherSuitable) {\n          // Find indoor alternatives\n          const indoorAlternatives = alternatives.filter(alt => \n            alt.types && !isVenueOutdoor(alt.types)\n          );\n          \n          // Use the first indoor alternative if available\n          if (indoorAlternatives.length > 0) {\n            bestVenue = indoorAlternatives[0];\n            console.log(`Weather not suitable for outdoor venue. Recommending indoor alternative: ${bestVenue.name}`);\n          } else {\n            console.log(\"Weather not suitable for outdoor venue, but no indoor alternatives available\");\n          }\n        } else {\n          console.log(`Weather is suitable for outdoor venue: ${place.name}`);\n        }\n      } catch (weatherError) {\n        // If we can't get weather data, use a simple fallback based on venue type\n        console.warn(\"Could not fetch weather data:\", weatherError);\n        console.log(\"Using fallback venue selection based on venue types only\");\n        \n        // Even without weather data, we can provide an indoor alternative\n        // Just to give options if the primary venue is outdoor\n        const indoorAlternatives = alternatives.filter(alt => \n          alt.types && !isVenueOutdoor(alt.types)\n        );\n        \n        if (indoorAlternatives.length > 0) {\n          // We don't switch automatically without weather data\n          // But provide the information for the client to display\n          console.log(`Outdoor venue has indoor alternatives: ${indoorAlternatives[0].name}`);\n        }\n      }\n    } else {\n      // Primary venue is already indoor, no need for weather check\n      console.log(`Primary venue is indoor: ${place.name}`);\n    }\n    \n    return { venue: bestVenue, weatherSuitable: isWeatherSuitable };\n  } catch (error) {\n    console.error('Error in weather-aware venue selection:', error);\n    // On error, just return the original venue\n    return { venue: place, weatherSuitable: true };\n  }\n}\n\nasync function testWeatherService() {\n  // Test location (London)\n  const londonLat = 51.5074;\n  const londonLng = -0.1278;\n  \n  console.log(\"--- Testing Weather Service ---\");\n  \n  // Test weather forecast fetch\n  try {\n    console.log(\"Fetching London weather forecast...\");\n    const forecast = await getWeatherForecast(londonLat, londonLng);\n    \n    console.log(\"✅ Successfully fetched weather data:\");\n    console.log(`  First forecast temp: ${forecast.list[0].main.temp}°C`);\n    console.log(`  Conditions: ${forecast.list[0].weather[0].main}`);\n    \n    // Test cache by making a second request\n    console.log(\"\\nTesting cache (should be instant):\");\n    const startTime = Date.now();\n    const cachedForecast = await getWeatherForecast(londonLat, londonLng);\n    const duration = Date.now() - startTime;\n    console.log(`  Second request took ${duration}ms`);\n  } catch (error) {\n    console.error(\"❌ Error fetching weather:\", error);\n  }\n  \n  // Test venue classification\n  console.log(\"\\n--- Testing Venue Classification ---\");\n  const testVenueTypes = [\n    [\"park\"], \n    [\"restaurant\"], \n    [\"museum\"], \n    [\"tourist_attraction\", \"park\"]\n  ];\n  \n  for (const types of testVenueTypes) {\n    const isOutdoor = isVenueOutdoor(types);\n    console.log(`Types [${types.join(', ')}] → ${isOutdoor ? \"Outdoor\" : \"Indoor\"}`);\n  }\n  \n  // Test weather suitability with mock data\n  console.log(\"\\n--- Testing Weather Suitability ---\");\n  const mockWeatherData = {\n    list: [\n      {\n        dt: Math.floor(Date.now() / 1000),\n        main: { temp: 20 },\n        weather: [{ id: 800, main: \"Clear\", description: \"clear sky\" }]\n      },\n      {\n        dt: Math.floor(Date.now() / 1000) + 3600,\n        main: { temp: 18 },\n        weather: [{ id: 500, main: \"Rain\", description: \"light rain\" }]\n      }\n    ]\n  };\n  \n  const testTimes = [\n    new Date(),\n    new Date(Date.now() + 3600 * 1000)\n  ];\n  \n  for (const time of testTimes) {\n    const suitable = isWeatherSuitableForOutdoor(mockWeatherData, time);\n    console.log(`Time ${time.toLocaleTimeString()} → ${suitable ? \"Suitable\" : \"Not suitable\"} for outdoor activities`);\n  }\n}\n\n// Comment this out after testing\n// testWeatherService();","size_bytes":10834},"server/middleware/requireAuth.ts":{"content":"import { Request, Response, NextFunction } from 'express';\nimport { storage } from '../storage';\n\n/**\n * Middleware to require authentication for protected routes\n * If user is not authenticated, redirects to login or returns 401\n */\nexport const requireAuth = (req: Request, res: Response, next: NextFunction) => {\n  // Check for Accept header to ensure proper response\n  const acceptHeader = req.get('Accept');\n  const wantsJSON = acceptHeader && acceptHeader.includes('application/json');\n  \n  if (!req.session || !req.session.userId) {\n    if (wantsJSON) {\n      return res.status(401).json({\n        error: 'Unauthorized',\n        message: 'You must be logged in to access this resource'\n      });\n    } else {\n      return res.redirect('/login');\n    }\n  }\n  \n  next();\n};\n\n/**\n * Middleware to attach the current user to the request\n * This does not block the request if user is not authenticated\n */\nexport const attachCurrentUser = async (req: Request, res: Response, next: NextFunction) => {\n  if (req.session && req.session.userId) {\n    try {\n      const user = await storage.getUserById(req.session.userId);\n      \n      if (user) {\n        // Attach user to request object, excluding sensitive data\n        req.currentUser = {\n          id: user.id,\n          email: user.email,\n          name: user.name || '',\n          avatar_url: user.avatar_url || undefined\n        };\n      }\n    } catch (error) {\n      console.error('Error attaching current user:', error);\n      // Continue without attaching user\n    }\n  }\n  \n  next();\n};","size_bytes":1545},"server/migrations/aiLogging.ts":{"content":"/**\n * AI logging migrations\n * \n * This file contains the database migrations for AI logging.\n */\n\nimport { db } from '../db';\nimport { aiInteractions } from '../lib/aiLogging';\nimport { sql } from 'drizzle-orm';\n\n/**\n * Create a new table for AI interaction logs\n */\nasync function createAiInteractionsTable() {\n  try {\n    console.log(\"Creating AI interactions table...\");\n    \n    // Execute the create table query\n    await db.execute(sql`\n      CREATE TABLE IF NOT EXISTS ai_interactions (\n        id SERIAL PRIMARY KEY,\n        session_id TEXT NOT NULL,\n        timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n        user_query TEXT NOT NULL,\n        model_name TEXT NOT NULL,\n        raw_request JSONB,\n        raw_response TEXT,\n        parsed_response JSONB,\n        processing_time_ms INTEGER,\n        status TEXT NOT NULL,\n        error_details TEXT,\n        parameters JSONB,\n        meta_data JSONB\n      )\n    `);\n    \n    console.log(\"AI interactions table created successfully\");\n    return true;\n  } catch (error) {\n    console.error(\"Failed to create AI interactions table:\", error);\n    return false;\n  }\n}\n\nasync function runMigrations() {\n  console.log(\"Running AI logging migrations...\");\n  \n  try {\n    // Create the table\n    const success = await createAiInteractionsTable();\n    \n    if (success) {\n      console.log(\"AI logging migrations completed successfully\");\n    } else {\n      console.error(\"AI logging migrations failed\");\n    }\n    \n    return success;\n  } catch (error) {\n    console.error(\"Error in AI logging migrations:\", error);\n    return false;\n  }\n}\n\n// Run migrations from the main application rather than directly\n// This ensures compatibility with ESM modules\n\nexport { runMigrations, createAiInteractionsTable };","size_bytes":1764},"server/routes/auth.ts":{"content":"import { Request, Response, Router } from 'express';\nimport { db } from '../db';\nimport { users } from '@shared/schema';\nimport { eq } from 'drizzle-orm';\nimport bcrypt from 'bcrypt';\nimport { insertLocalUserSchema, loginSchema, googleAuthSchema, insertGoogleUserSchema } from '@shared/schema';\nimport { attachCurrentUser } from '../middleware/requireAuth';\nimport { SessionData } from 'express-session';\nimport { storage } from '../storage';\n\n// Create a router for authentication routes\nconst router = Router();\n\n/**\n * Register a new user\n * POST /api/auth/register\n */\nrouter.post('/register', async (req: Request, res: Response) => {\n  try {\n    // Validate request body against the schema\n    const validation = insertLocalUserSchema.safeParse(req.body);\n    \n    if (!validation.success) {\n      return res.status(400).json({ \n        error: 'Invalid input', \n        details: validation.error.format() \n      });\n    }\n    \n    const { email, password, name } = validation.data;\n    \n    // Check if user already exists\n    const existingUser = await storage.getUserByEmail(email);\n    \n    if (existingUser) {\n      return res.status(409).json({ \n        error: 'User already exists',\n        message: 'A user with this email already exists'\n      });\n    }\n    \n    // Hash password\n    const saltRounds = 10;\n    const password_hash = await bcrypt.hash(password, saltRounds);\n    \n    // Create new user\n    const user = await storage.createLocalUser(\n      { email, name, password, confirmPassword: password }, \n      password_hash\n    );\n      \n    // Set user ID in session\n    req.session.userId = user.id;\n    \n    // Return user without password hash\n    return res.status(201).json({\n      message: 'User registered successfully',\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    });\n  } catch (error) {\n    console.error('Error registering user:', error);\n    return res.status(500).json({ \n      error: 'Server error',\n      message: 'An error occurred while registering user'\n    });\n  }\n});\n\n/**\n * Login a user\n * POST /api/auth/login\n */\nrouter.post('/login', async (req: Request, res: Response) => {\n  try {\n    // Validate request body\n    const validation = loginSchema.safeParse(req.body);\n    \n    if (!validation.success) {\n      return res.status(400).json({ \n        error: 'Invalid input', \n        details: validation.error.format() \n      });\n    }\n    \n    const { email, password } = validation.data;\n    \n    // Find user by email\n    const user = await storage.getUserByEmail(email);\n    \n    if (!user) {\n      return res.status(401).json({ \n        error: 'Authentication failed',\n        message: 'Invalid email or password'\n      });\n    }\n    \n    // Check if this is a local auth account\n    if (!user.password_hash || user.auth_provider !== 'local') {\n      return res.status(401).json({ \n        error: 'Authentication failed',\n        message: 'Please use the appropriate login method for this account'\n      });\n    }\n    \n    // Compare password with hash\n    const passwordMatch = await bcrypt.compare(password, user.password_hash || '');\n    \n    if (!passwordMatch) {\n      return res.status(401).json({ \n        error: 'Authentication failed',\n        message: 'Invalid email or password'\n      });\n    }\n    \n    // Set user ID in session\n    req.session.userId = user.id;\n    \n    // Return user without password hash\n    return res.json({\n      message: 'Login successful',\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    });\n  } catch (error) {\n    console.error('Error logging in:', error);\n    return res.status(500).json({ \n      error: 'Server error',\n      message: 'An error occurred while processing login'\n    });\n  }\n});\n\n/**\n * Logout a user\n * POST /api/auth/logout\n */\nrouter.post('/logout', (req: Request, res: Response) => {\n  // Check for Accept header to ensure proper response\n  const acceptHeader = req.get('Accept');\n  const wantsJSON = acceptHeader && acceptHeader.includes('application/json');\n  \n  // Check if user is already logged out\n  if (!req.session || !req.session.userId) {\n    if (wantsJSON) {\n      return res.json({\n        message: 'Already logged out'\n      });\n    } else {\n      return res.redirect('/login');\n    }\n  }\n  \n  // Destroy session\n  req.session.destroy((err: Error | null) => {\n    if (err) {\n      console.error('Error destroying session:', err);\n      return res.status(500).json({ \n        error: 'Server error',\n        message: 'An error occurred while logging out'\n      });\n    }\n    \n    // Clear cookie\n    res.clearCookie('connect.sid');\n    \n    if (wantsJSON) {\n      return res.json({\n        message: 'Logout successful'\n      });\n    } else {\n      // Default behavior for browser requests\n      return res.redirect('/login');\n    }\n  });\n});\n\n/**\n * Get current user status\n * GET /api/auth/status\n */\nrouter.get('/status', attachCurrentUser, async (req: Request, res: Response) => {\n  try {\n    // If no user is logged in\n    if (!req.session.userId) {\n      return res.json({\n        loggedIn: false\n      });\n    }\n    \n    // Find user details\n    const user = await storage.getUserById(req.session.userId);\n    \n    if (!user) {\n      // Session exists but user doesn't - clear session\n      req.session.destroy((err: Error | null) => {\n        if (err) {\n          console.error('Error destroying session:', err);\n        }\n      });\n      return res.json({\n        loggedIn: false\n      });\n    }\n    \n    // Return user status and data\n    return res.json({\n      loggedIn: true,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching user status:', error);\n    return res.status(500).json({ \n      error: 'Server error',\n      message: 'An error occurred while fetching authentication status'\n    });\n  }\n});\n\n/**\n * Get current user\n * GET /api/auth/me\n */\nrouter.get('/me', async (req: Request, res: Response) => {\n  try {\n    // Check for Accept header to ensure we always return JSON\n    const acceptHeader = req.get('Accept');\n    const wantsJSON = acceptHeader && acceptHeader.includes('application/json');\n    \n    // If no user is logged in\n    if (!req.session.userId) {\n      if (wantsJSON) {\n        return res.status(401).json({\n          error: 'Unauthorized',\n          message: 'You must be logged in to access this resource'\n        });\n      } else {\n        // For API clients that don't explicitly request JSON, redirect to login\n        return res.redirect('/login');\n      }\n    }\n    \n    // Find user details\n    const user = await storage.getUserById(req.session.userId);\n    \n    if (!user) {\n      // Session exists but user doesn't - clear session\n      req.session.destroy((err: Error | null) => {\n        if (err) {\n          console.error('Error destroying session:', err);\n        }\n      });\n      \n      if (wantsJSON) {\n        return res.status(401).json({\n          error: 'Unauthorized',\n          message: 'Session invalid, please log in again'\n        });\n      } else {\n        return res.redirect('/login');\n      }\n    }\n    \n    // Return user data\n    return res.json({\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        avatar_url: user.avatar_url\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching current user:', error);\n    return res.status(500).json({ \n      error: 'Server error',\n      message: 'An error occurred while fetching user information'\n    });\n  }\n});\n\n/**\n * Authenticate with Google\n * POST /api/auth/google\n */\nrouter.post('/google', async (req: Request, res: Response) => {\n  try {\n    // Validate request body\n    const validation = googleAuthSchema.safeParse(req.body);\n    \n    if (!validation.success) {\n      return res.status(400).json({ \n        error: 'Invalid input', \n        details: validation.error.format() \n      });\n    }\n    \n    const { token } = validation.data;\n    \n    try {\n      // Verify the Google token\n      const { verifyGoogleToken } = await import('../lib/googleAuth');\n      const googleUserInfo = await verifyGoogleToken(token);\n      \n      // Check if user exists by Google ID\n      let user = await storage.getUserByGoogleId(googleUserInfo.sub);\n      \n      if (!user) {\n        // Check if user exists by email\n        user = await storage.getUserByEmail(googleUserInfo.email);\n        \n        if (user) {\n          // If user exists but hasn't used Google auth before\n          if (user.auth_provider === 'local') {\n            return res.status(409).json({\n              error: 'Authentication conflict',\n              message: 'An account with this email already exists. Please log in with your password.'\n            });\n          }\n        } else {\n          // Create new user with Google info\n          user = await storage.createGoogleUser({\n            email: googleUserInfo.email,\n            name: googleUserInfo.name,\n            google_id: googleUserInfo.sub,\n            avatar_url: googleUserInfo.picture,\n            auth_provider: 'google'\n          });\n        }\n      }\n      \n      // Set user ID in session\n      req.session.userId = user.id;\n      \n      // Return user info\n      return res.json({\n        message: 'Google authentication successful',\n        user: {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          avatar_url: user.avatar_url\n        }\n      });\n    } catch (error) {\n      console.error('Error verifying Google token:', error);\n      return res.status(401).json({\n        error: 'Authentication failed',\n        message: 'Could not verify Google authentication'\n      });\n    }\n  } catch (error) {\n    console.error('Error with Google authentication:', error);\n    return res.status(500).json({ \n      error: 'Server error',\n      message: 'An error occurred during Google authentication'\n    });\n  }\n});\n\nexport default router;","size_bytes":10012},"server/routes/config.ts":{"content":"import { Router, Request, Response } from 'express';\nimport { getApiKey } from '../config';\n\nconst router = Router();\n\n/**\n * Get public configuration for the client\n * GET /api/config/public\n * \n * Returns non-sensitive configuration values that the client needs\n */\nrouter.get('/public', (req: Request, res: Response) => {\n  const publicConfig = {\n    googleClientId: getApiKey('GOOGLE_CLIENT_ID'),\n    // Add other public configuration values as needed\n  };\n  \n  res.json(publicConfig);\n});\n\n/**\n * Get current URL information\n * GET /api/config/current-url\n * \n * Diagnostic endpoint to help debug OAuth redirect issues\n */\nrouter.get('/current-url', (req: Request, res: Response) => {\n  const host = req.get('host') || 'unknown';\n  const protocol = req.protocol || 'http';\n  const baseUrl = `${protocol}://${host}`;\n  \n  res.json({\n    baseUrl,\n    host,\n    protocol,\n    fullUrl: `${baseUrl}${req.originalUrl}`,\n    headers: req.headers,\n    hostname: req.hostname\n  });\n});\n\nexport default router;","size_bytes":1005},"server/routes/itineraries.ts":{"content":"import { Router, Request, Response } from 'express';\nimport { storage } from '../storage';\nimport { requireAuth } from '../middleware/requireAuth';\n\nconst router = Router();\n\n/**\n * Get all itineraries for the current user\n * GET /api/itineraries/user\n */\nrouter.get('/user', requireAuth, async (req: Request, res: Response) => {\n  try {\n    const userId = req.session.userId;\n    \n    if (!userId) {\n      return res.status(401).json({\n        error: 'Unauthorized',\n        message: 'You must be logged in to access your itineraries'\n      });\n    }\n    \n    console.log(`Fetching itineraries for user ID: ${userId}`);\n    const itineraries = await storage.getUserItineraries(userId);\n    console.log(`Found ${itineraries.length} itineraries`);\n    \n    // Format the itineraries for the frontend, handle type safety\n    const formattedItineraries = itineraries.map(itinerary => {\n      // Ensure we have valid data with fallbacks for any potentially missing fields\n      return {\n        id: itinerary.id,\n        title: `NYC Itinerary ${itinerary.id}`,\n        query: itinerary.query || 'NYC Itinerary',\n        created_at: itinerary.created?.toISOString() || new Date().toISOString(),\n      };\n    });\n    \n    // Return the itineraries, sorted by creation date (newest first)\n    const sortedItineraries = formattedItineraries.sort((a, b) => {\n      const dateA = new Date(a.created_at).getTime();\n      const dateB = new Date(b.created_at).getTime();\n      return dateB - dateA;\n    });\n    \n    console.log('Returning formatted itineraries:', sortedItineraries);\n    return res.json(sortedItineraries);\n  } catch (error) {\n    console.error('Error fetching user itineraries:', error);\n    return res.status(500).json({\n      error: 'Server error',\n      message: 'An error occurred while fetching itineraries'\n    });\n  }\n});\n\n/**\n * Get a specific itinerary by ID\n * GET /api/itineraries/:id\n */\nrouter.get('/:id', async (req: Request, res: Response) => {\n  try {\n    const id = parseInt(req.params.id);\n    \n    if (isNaN(id)) {\n      return res.status(400).json({\n        error: 'Invalid ID',\n        message: 'Itinerary ID must be a number'\n      });\n    }\n    \n    const itinerary = await storage.getItinerary(id);\n    \n    if (!itinerary) {\n      return res.status(404).json({\n        error: 'Not found',\n        message: 'Itinerary not found'\n      });\n    }\n    \n    // We need to check user permissions later when we associate itineraries with users\n    // For now, all itineraries are public\n    \n    return res.json({\n      ...itinerary,\n      created_at: itinerary.created?.toISOString() || new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Error fetching itinerary:', error);\n    return res.status(500).json({\n      error: 'Server error',\n      message: 'An error occurred while fetching the itinerary'\n    });\n  }\n});\n\nexport default router;","size_bytes":2886},"server/tests/landmark-recognition.ts":{"content":"import { fileURLToPath } from 'url';\nimport { dirname, join } from 'path';\nimport { searchPlace } from '../lib/googlePlaces';\nimport * as fs from 'fs';\n\n// ES Module compatible __dirname equivalent\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Test a variety of London landmarks and locations\nconst testLocations = [\n  'Green Park',\n  'Tower Bridge',\n  'Buckingham Palace',\n  'Fitzrovia',\n  'Shoreditch',\n  'Notting Hill',\n  'Borough Market',\n  'Covent Garden',\n  'Oxford Street',\n  'Piccadilly Circus'\n];\n\n// Create logs directory if it doesn't exist\nconst logsDir = join(__dirname, '..', 'logs');\nif (!fs.existsSync(logsDir)) {\n  fs.mkdirSync(logsDir, { recursive: true });\n}\n\nconst logFile = join(logsDir, 'location-tests.json');\n\nasync function runTests() {\n  const results = [];\n\n  for (const location of testLocations) {\n    console.log(`Testing location: ${location}`);\n    const startTime = Date.now();\n\n    try {\n      const result = await searchPlace(location, {});\n      const endTime = Date.now();\n\n      const testResult = {\n        timestamp: new Date().toISOString(),\n        query: location,\n        success: !!result,\n        executionTimeMs: endTime - startTime,\n        errorMessage: null,\n        placeDetails: result ? {\n          name: result.name,\n          formatted_address: result.formatted_address,\n          location: result.geometry?.location,\n          types: result.types\n        } : null\n      };\n\n      results.push(testResult);\n      console.log(`Result: ${testResult.success ? 'SUCCESS' : 'FAILED'}`);\n\n    } catch (error: any) {\n      const endTime = Date.now();\n      const testResult = {\n        timestamp: new Date().toISOString(),\n        query: location,\n        success: false,\n        executionTimeMs: endTime - startTime,\n        errorMessage: error.message,\n        placeDetails: null\n      };\n\n      results.push(testResult);\n      console.log(`Error testing ${location}: ${error.message}`);\n    }\n  }\n\n  // Save results to log file\n  let existingLogs = [];\n  try {\n    if (fs.existsSync(logFile)) {\n      existingLogs = JSON.parse(fs.readFileSync(logFile, 'utf8'));\n    }\n  } catch (error) {\n    console.error('Error reading existing logs:', error);\n  }\n\n  existingLogs.push({\n    testRun: new Date().toISOString(),\n    results\n  });\n\n  fs.writeFileSync(logFile, JSON.stringify(existingLogs, null, 2));\n  console.log(`Test results saved to ${logFile}`);\n\n  // Summary\n  const successCount = results.filter(r => r.success).length;\n  console.log(`\\nSummary: ${successCount}/${results.length} locations successfully recognized`);\n}\n\nrunTests().catch(console.error);","size_bytes":2657},"server/types/express.d.ts":{"content":"import 'express';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      currentUser?: {\n        id: string;\n        email: string;\n        name: string;\n        avatar_url?: string;\n      };\n    }\n  }\n}\n\n// Declaration merging for express-session\ndeclare module 'express-session' {\n  interface SessionData {\n    userId?: string;\n  }\n}","size_bytes":350},"client/src/components/InputScreen.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport Logo from './Logo';\n\ninterface InputScreenProps {\n  onSubmit: (data: { date: string; time: string; plans: string }) => void;\n  isLoading?: boolean;\n}\n\nconst InputScreen: React.FC<InputScreenProps> = ({ onSubmit, isLoading }) => {\n  // Initialize with current date and time\n  const [date, setDate] = useState(formatDateForInput(new Date()));\n  const [time, setTime] = useState(formatTimeForInput(new Date()));\n  const [plans, setPlans] = useState('');\n\n  // Format date for date input (YYYY-MM-DD)\n  function formatDateForInput(date: Date): string {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  // Format time for time input (HH:MM)\n  function formatTimeForInput(date: Date): string {\n    const hours = String(date.getHours()).padStart(2, '0');\n    const minutes = String(date.getMinutes()).padStart(2, '0');\n    return `${hours}:${minutes}`;\n  }\n\n  // Set current date and time when component mounts\n  useEffect(() => {\n    const now = new Date();\n    setDate(formatDateForInput(now));\n    setTime(formatTimeForInput(now));\n  }, []);\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit({ date, time, plans });\n  };\n\n  // Mobile-first design based on the mockup\n  return (\n    <div className=\"bg-white flex flex-col items-center min-h-screen w-full\" style={{\n      fontFamily: \"'Poppins', sans-serif\"\n    }}>\n      <div className=\"w-full max-w-md px-4 py-6 flex flex-col items-center\">\n        {/* Logo */}\n        <div className=\"mb-8 mt-4\">\n          <Logo className=\"w-full\" style={{ transform: 'scale(1.5)' }} />\n        </div>\n        \n        {/* Instruction Text */}\n        <p className=\"mb-6 font-bold tagline-text\" style={{ color: '#17B9E6' }}>\n          Enter your activities, locations and times below, we'll create a day plan for you.\n        </p>\n\n        {/* Form */}\n        <form onSubmit={handleSubmit} className=\"w-full\">\n          {/* Date Field */}\n          <div className=\"mb-6 bg-white rounded-2xl py-6 px-5 shadow-sm\"\n            style={{\n              border: '1px solid transparent',\n              backgroundImage: 'linear-gradient(white, white), linear-gradient(to right, #E6DBEE, #BCC6E6)',\n              backgroundOrigin: 'border-box',\n              backgroundClip: 'padding-box, border-box',\n              minHeight: '80px' // Increased height\n            }}\n          >\n            <label \n              htmlFor=\"date\"\n              className=\"block mb-2 font-bold text-xl text-[#1C1C1C]\"\n            >\n              Date\n            </label>\n            <input\n              type=\"date\"\n              id=\"date\"\n              value={date}\n              onChange={(e) => setDate(e.target.value)}\n              className=\"w-full bg-transparent text-gray-700 focus:outline-none text-lg pl-3 py-2\"\n              required\n            />\n          </div>\n\n          {/* Time Field */}\n          <div className=\"mb-6 bg-white rounded-2xl py-6 px-5 shadow-sm\"\n            style={{\n              border: '1px solid transparent',\n              backgroundImage: 'linear-gradient(white, white), linear-gradient(to right, #E6DBEE, #BCC6E6)',\n              backgroundOrigin: 'border-box',\n              backgroundClip: 'padding-box, border-box',\n              minHeight: '80px' // Increased height\n            }}\n          >\n            <label\n              htmlFor=\"time\"\n              className=\"block mb-2 font-bold text-xl text-[#1C1C1C]\"\n            >\n              Time\n            </label>\n            <input\n              type=\"time\"\n              id=\"time\"\n              value={time}\n              onChange={(e) => setTime(e.target.value)}\n              className=\"w-full bg-transparent text-gray-700 focus:outline-none text-lg pl-3 py-2\"\n              required\n            />\n          </div>\n\n          {/* Plans Field */}\n          <div className=\"mb-8 bg-white rounded-2xl py-6 px-5 shadow-sm\"\n            style={{\n              border: '1px solid transparent',\n              backgroundImage: 'linear-gradient(white, white), linear-gradient(to right, #E6DBEE, #BCC6E6)',\n              backgroundOrigin: 'border-box',\n              backgroundClip: 'padding-box, border-box'\n            }}\n          >\n            <label\n              htmlFor=\"plans\"\n              className=\"block mb-2 font-bold text-xl text-[#1C1C1C]\"\n            >\n              Your Plans\n            </label>\n            <textarea\n              id=\"plans\"\n              value={plans}\n              onChange={(e) => setPlans(e.target.value)}\n              className=\"w-full bg-transparent text-gray-700 focus:outline-none text-lg min-h-[135px] p-3\"\n              placeholder=\"e.g. 12pm lunch in Mayfair, then grab a coffee and have a walk\"\n              required\n            />\n          </div>\n\n          {/* Submit Button */}\n          <button\n            type=\"submit\"\n            className=\"w-full py-4 rounded-2xl\"\n            style={{\n              background: '#17B9E6',\n              color: 'white',\n              fontWeight: 600,\n              fontSize: '1rem',\n              cursor: isLoading ? 'not-allowed' : 'pointer',\n              opacity: isLoading ? 0.8 : 1,\n            }}\n            disabled={isLoading}\n          >\n            {isLoading ? (\n              <div className=\"flex items-center justify-center gap-2\">\n                <div className=\"loading-indicator\" style={{ \n                  width: 20, \n                  height: 20,\n                  border: '2px solid rgba(255, 255, 255, 0.3)',\n                  borderTopColor: 'white',\n                  borderRadius: '50%',\n                  animation: 'spin 1s linear infinite'\n                }} />\n                <span>Creating Plan...</span>\n              </div>\n            ) : (\n              'Create Plan'\n            )}\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default InputScreen; ","size_bytes":6054},"client/src/components/ItineraryScreen.tsx":{"content":"import React, { useEffect } from 'react';\nimport { format, formatInTimeZone } from 'date-fns-tz';\n\ninterface Venue {\n  name: string;\n  time: string; // Can be either displayTime (formatted) or ISO timestamp\n  address: string;\n  rating: number;\n  categories: string[];\n}\n\ninterface TravelInfo {\n  duration: string;\n  destination: string;\n}\n\ninterface ItineraryScreenProps {\n  venues: Venue[];\n  travelInfo: TravelInfo[];\n  onExport: () => void;\n}\n\nconst ItineraryScreen: React.FC<ItineraryScreenProps> = ({\n  venues,\n  travelInfo,\n  onExport\n}) => {\n  // Add debug logging to track the data flow\n  useEffect(() => {\n    console.log(\"ItineraryScreen received venues:\", venues);\n    console.log(\"ItineraryScreen received travelInfo:\", travelInfo);\n  }, [venues, travelInfo]);\n\n  const hasVenues = venues && Array.isArray(venues) && venues.length > 0;\n  const hasTravelInfo = travelInfo && Array.isArray(travelInfo);\n\n  // Don't render anything if there are no venues\n  if (!hasVenues) {\n    return null;\n  }\n\n  return (\n    <div className=\"bg-white flex flex-col items-center w-full\">\n      <div className=\"w-full max-w-md px-4 pb-12\">\n        {/* Header - only shown when we have venues */}\n        <div className=\"mb-8 text-center\">\n          <h1 className=\"text-3xl font-bold mb-8 itinerary-title\" style={{ \n            fontFamily: \"'Rozha One', serif\", /* Keep this font for the title to match the app's branding */\n            color: 'var(--color-text-black)',\n            fontSize: '1.875rem' // text-3xl is 1.875rem, which is ~20% bigger than text-2xl (1.5rem)\n          }}>\n            Your NYC Itinerary\n          </h1>\n\n          <button\n            onClick={onExport}\n            className=\"w-full py-4 rounded-2xl text-white export-button\"\n            style={{ \n              background: '#17B9E6',\n              fontWeight: 600,\n              fontSize: '1rem',\n              fontFamily: \"'Inter', sans-serif\"\n            }}\n          >\n            Export to Calendar\n          </button>\n        </div>\n\n        {/* Venues List */}\n        <div className=\"space-y-8\">\n          {venues.map((venue, index) => (\n            <React.Fragment key={`${venue.name}-${index}`}>\n              <div className=\"bg-white rounded-2xl p-6 shadow-sm border border-gray-100 venue-card\" style={{ fontFamily: \"'Inter', sans-serif\" }}>\n                <h2 className=\"text-xl font-bold mb-4 venue-name\" style={{ fontFamily: \"'Inter', sans-serif\", letterSpacing: 'normal' }}>\n                  {venue.name}\n                </h2>\n                \n                <div className=\"space-y-3 mb-5\">\n                  <p className=\"text-lg font-semibold venue-time\" style={{ fontFamily: \"'Inter', sans-serif\" }}>\n                    {/* Display time with ET (Eastern Time) suffix */}\n                    {venue.time.includes('ET') ? venue.time : `${venue.time} ET`}\n                  </p>\n                  <p className=\"text-gray-500 text-sm venue-address\" style={{ fontFamily: \"'Inter', sans-serif\", textTransform: 'none' }}>{venue.address}</p>\n                  <p className=\"text-gray-500 text-sm venue-rating\" style={{ fontFamily: \"'Inter', sans-serif\" }}>Rating: {venue.rating || 'N/A'}</p>\n                </div>\n                \n                <div className=\"flex flex-wrap gap-2\">\n                  {venue.categories && Array.isArray(venue.categories) && venue.categories.map((category, catIndex) => (\n                    <span \n                      key={`${category}-${catIndex}`} \n                      className=\"px-3 py-1 rounded-full text-xs venue-tag\"\n                      style={{\n                        background: 'rgba(23, 185, 230, 0.1)',\n                        color: 'var(--color-text-black)',\n                        border: '1px solid rgba(23, 185, 230, 0.2)',\n                        fontFamily: \"'Inter', sans-serif\"\n                      }}\n                    >\n                      {category.replace(/_/g, ' ')}\n                    </span>\n                  ))}\n                </div>\n              </div>\n              \n              {index < venues.length - 1 && hasTravelInfo && travelInfo[index] && (\n                <div className=\"flex items-center gap-3 px-5 py-4 mt-4 mb-4 bg-white rounded-lg text-gray-500 text-sm shadow-sm border border-gray-100 travel-info\" style={{ fontFamily: \"'Inter', sans-serif\" }}>\n                  <svg\n                    width=\"16\"\n                    height=\"16\"\n                    viewBox=\"0 0 16 16\"\n                    fill=\"none\"\n                    xmlns=\"http://www.w3.org/2000/svg\"\n                    style={{color: '#17B9E6'}}\n                  >\n                    <path\n                      d=\"M8 0C5.87827 0 3.84344 0.842855 2.34315 2.34315C0.842855 3.84344 0 5.87827 0 8C0 10.1217 0.842855 12.1566 2.34315 13.6569C3.84344 15.1571 5.87827 16 8 16C10.1217 16 12.1566 15.1571 13.6569 13.6569C15.1571 12.1566 16 10.1217 16 8C16 5.87827 15.1571 3.84344 13.6569 2.34315C12.1566 0.842855 10.1217 0 8 0ZM8 14.4C6.25044 14.4 4.57275 13.7257 3.32294 12.5259C2.07312 11.326 1.39819 9.64784 1.39819 7.89828C1.39819 6.14872 2.07312 4.47103 3.32294 3.27121C4.57275 2.0714 6.25044 1.39647 8 1.39647C9.74956 1.39647 11.4272 2.0714 12.6771 3.27121C13.9269 4.47103 14.6018 6.14872 14.6018 7.89828C14.6018 9.64784 13.9269 11.326 12.6771 12.5259C11.4272 13.7257 9.74956 14.4 8 14.4Z\"\n                      fill=\"currentColor\"\n                    />\n                    <path\n                      d=\"M8 3.2C7.68174 3.2 7.37652 3.32643 7.15147 3.55147C6.92643 3.77652 6.8 4.08174 6.8 4.4V7.6H4.4C4.08174 7.6 3.77652 7.72643 3.55147 7.95147C3.32643 8.17652 3.2 8.48174 3.2 8.8C3.2 9.11826 3.32643 9.42348 3.55147 9.64853C3.77652 9.87357 4.08174 10 4.4 10H8C8.31826 10 8.62348 9.87357 8.84853 9.64853C9.07357 9.42348 9.2 9.11826 9.2 8.8V4.4C9.2 4.08174 9.07357 3.77652 8.84853 3.55147C8.62348 3.32643 8.31826 3.2 8 3.2Z\"\n                      fill=\"currentColor\"\n                    />\n                  </svg>\n                  <span className=\"whitespace-normal overflow-visible travel-duration\" style={{ fontFamily: \"'Inter', sans-serif\" }}>\n                    {travelInfo[index].duration} minutes to {travelInfo[index].destination}\n                  </span>\n                </div>\n              )}\n            </React.Fragment>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ItineraryScreen;","size_bytes":6377},"client/src/components/LoadingScreen.tsx":{"content":"import React from 'react';\nimport Logo from './Logo';\n\nconst LoadingScreen: React.FC = () => {\n  return (\n    <div className=\"loading-container\">\n      <Logo className=\"mb-8\" />\n      <div className=\"loading-indicator\" />\n      <p className=\"loading-text\" style={{ \n        fontFamily: 'var(--font-button)',\n        color: 'var(--color-primary)',\n        marginTop: 'var(--spacing-md)'\n      }}>\n        Plan Your Perfect Days in Seconds\n      </p>\n    </div>\n  );\n};\n\nexport default LoadingScreen; ","size_bytes":499},"client/src/components/Logo.tsx":{"content":"import React from 'react';\n\ninterface LogoProps {\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nconst Logo: React.FC<LogoProps> = ({ className = '', style = {} }) => {\n  return (\n    <div className={`logo-container flex flex-col items-center ${className}`} style={style}>\n      <h1 \n        className=\"text-[4.5rem] text-[#1C1C1C]\"\n        style={{ \n          fontFamily: 'Rozha One, serif',\n          letterSpacing: 'normal',\n          lineHeight: '1',\n          fontSize: '4.5rem', // Explicitly set font size in both places\n          fontWeight: 'normal' // Changed from 'bold' to 'normal'\n        }}\n      >\n        Plan\n      </h1>\n    </div>\n  );\n};\n\nexport default Logo; ","size_bytes":688},"client/src/components/TimeInput.tsx":{"content":"import { useState, useEffect } from 'react';\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Clock } from \"lucide-react\";\nimport { isValidTime, convertTo24Hour, TimeFormat } from '@/lib/dateUtils';\n\ninterface TimeInputProps {\n  value: string | undefined;\n  onChange: (value: string) => void;\n  timeFormat?: TimeFormat;\n  className?: string;\n  disabled?: boolean;\n}\n\nexport function TimeInput({ value, onChange, timeFormat = '12h', className, disabled }: TimeInputProps) {\n  const [inputType, setInputType] = useState<'text' | 'time'>('text');\n  const [displayValue, setDisplayValue] = useState(value || \"\");\n\n  // Check if the device supports time input\n  useEffect(() => {\n    const input = document.createElement('input');\n    input.type = 'time';\n    const supportsTime = input.type === 'time';\n    setInputType(supportsTime ? 'time' : 'text');\n  }, []);\n\n  const handleChange = (newValue: string) => {\n    setDisplayValue(newValue);\n    \n    if (inputType === 'time') {\n      // Native time picker always returns 24h format\n      onChange(newValue);\n    } else if (isValidTime(newValue)) {\n      // Convert to 24h format for consistency\n      onChange(convertTo24Hour(newValue));\n    }\n  };\n\n  return (\n    <div className=\"relative\">\n      <Input\n        type={inputType}\n        value={displayValue || \"\"}\n        onChange={(e) => handleChange(e.target.value)}\n        className={className}\n        placeholder={timeFormat === '12h' ? \"12:00 PM\" : \"14:00\"}\n        disabled={disabled}\n      />\n      <Button\n        variant=\"ghost\"\n        size=\"icon\"\n        className=\"absolute right-2 top-1/2 -translate-y-1/2\"\n        onClick={() => setInputType(inputType === 'text' ? 'time' : 'text')}\n        disabled={disabled}\n      >\n        <Clock className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  );\n}\n","size_bytes":1861},"client/src/components/TopNav.tsx":{"content":"import React from 'react';\nimport { Link } from 'wouter';\nimport { useAuth } from '@/hooks/useAuth';\nimport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n} from '@/components/ui/avatar';\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '@/components/ui/dropdown-menu';\n\nconst TopNav = () => {\n  const { user, logout } = useAuth();\n\n  // Generate avatar fallback from user's name\n  const getAvatarFallback = (name: string) => {\n    if (!name) return 'U';\n    return name.split(' ')\n      .map(part => part[0])\n      .join('')\n      .toUpperCase()\n      .substring(0, 2);\n  };\n\n  return (\n    <div className=\"border-none bg-white\">\n      <div className=\"flex h-14 items-center px-4 container mx-auto justify-between\">\n        <div className=\"flex items-center gap-2\">\n          {/* Left side empty - removed London Day Planner text */}\n        </div>\n        \n        {user ? (\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <button className=\"rounded-full outline-none ring-offset-background focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\">\n                <Avatar className=\"h-9 w-9\">\n                  <AvatarImage src={user.avatar_url || ''} alt={user.name || 'User'} />\n                  <AvatarFallback>{getAvatarFallback(user.name || '')}</AvatarFallback>\n                </Avatar>\n              </button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\">\n              <DropdownMenuLabel>My Account</DropdownMenuLabel>\n              <DropdownMenuSeparator />\n              <DropdownMenuItem className=\"cursor-pointer\" onClick={() => window.location.href = '/profile'}>\n                My Itineraries\n              </DropdownMenuItem>\n              <DropdownMenuItem className=\"cursor-pointer\" onClick={() => window.location.href = '/'}>\n                Create New Plan\n              </DropdownMenuItem>\n              <DropdownMenuSeparator />\n              <DropdownMenuItem onClick={() => logout()} className=\"cursor-pointer\">\n                Log out\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        ) : (\n          <div className=\"flex items-center\">\n            <a \n              href=\"#\" \n              onClick={(e) => {\n                e.preventDefault();\n                window.location.href = '/login';\n              }}\n              className=\"bg-[#17B9E6] hover:bg-[#15a8d1] text-white py-2 px-4 rounded-md text-sm font-medium transition-colors shadow-sm\"\n            >\n              Sign in with Google\n            </a>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TopNav;","size_bytes":2758},"client/src/components/VenueSwiper.tsx":{"content":"import React, { useState } from 'react';\nimport { ChevronLeft, ChevronRight, CheckCircle2, Cloud, CloudRain, Sun, Umbrella } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { PlaceDetails } from '@shared/schema';\n\ninterface VenueSwiperProps {\n  primary: PlaceDetails;\n  alternatives: PlaceDetails[];\n  onSelect: (venue: PlaceDetails) => void;\n  className?: string;\n}\n\nconst VenueSwiper: React.FC<VenueSwiperProps> = ({\n  primary,\n  alternatives,\n  onSelect,\n  className,\n}) => {\n  // Create an array with primary venue first, then alternatives\n  const allVenues = [primary, ...alternatives];\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [touchStart, setTouchStart] = useState<number | null>(null);\n  const [touchEnd, setTouchEnd] = useState<number | null>(null);\n  const [selectedVenueId, setSelectedVenueId] = useState<string>(primary.place_id);\n  \n  // The required minimum distance between touchStart and touchEnd to be detected as a swipe\n  const minSwipeDistance = 50;\n  \n  const handleNext = () => {\n    if (currentIndex < allVenues.length - 1) {\n      setCurrentIndex(currentIndex + 1);\n    }\n  };\n  \n  const handlePrev = () => {\n    if (currentIndex > 0) {\n      setCurrentIndex(currentIndex - 1);\n    }\n  };\n  \n  const handleSelect = (venue: PlaceDetails) => {\n    setSelectedVenueId(venue.place_id);\n    onSelect(venue);\n  };\n  \n  // Touch event handlers\n  const onTouchStart = (e: React.TouchEvent) => {\n    setTouchEnd(null); // Reset touchEnd\n    setTouchStart(e.targetTouches[0].clientX);\n  };\n  \n  const onTouchMove = (e: React.TouchEvent) => {\n    setTouchEnd(e.targetTouches[0].clientX);\n  };\n  \n  const onTouchEnd = () => {\n    if (!touchStart || !touchEnd) return;\n    \n    const distance = touchStart - touchEnd;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n    \n    if (isLeftSwipe && currentIndex < allVenues.length - 1) {\n      handleNext();\n    } else if (isRightSwipe && currentIndex > 0) {\n      handlePrev();\n    }\n  };\n  \n  // Mouse event handlers (for desktop swiping)\n  const [mouseDown, setMouseDown] = useState<number | null>(null);\n  const [mouseUp, setMouseUp] = useState<number | null>(null);\n  \n  const onMouseDown = (e: React.MouseEvent) => {\n    setMouseUp(null);\n    setMouseDown(e.clientX);\n  };\n  \n  const onMouseMove = (e: React.MouseEvent) => {\n    if (!mouseDown) return;\n    setMouseUp(e.clientX);\n  };\n  \n  const onMouseUp = () => {\n    if (!mouseDown || !mouseUp) {\n      setMouseDown(null);\n      return;\n    }\n    \n    const distance = mouseDown - mouseUp;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n    \n    if (isLeftSwipe && currentIndex < allVenues.length - 1) {\n      handleNext();\n    } else if (isRightSwipe && currentIndex > 0) {\n      handlePrev();\n    }\n    \n    setMouseDown(null);\n    setMouseUp(null);\n  };\n  \n  const onMouseLeave = () => {\n    setMouseDown(null);\n    setMouseUp(null);\n  };\n  \n  // Get current venue\n  const currentVenue = allVenues[currentIndex];\n  const isPrimary = currentIndex === 0;\n  const isSelected = currentVenue.place_id === selectedVenueId;\n\n  return (\n    <div className={cn(\"w-full\", className)}>\n      <div className=\"relative venue-container\">\n        {/* Navigation arrows for desktop - left */}\n        {currentIndex > 0 && (\n          <button\n            onClick={handlePrev}\n            className=\"nav-arrow absolute left-0 top-1/2 -translate-y-1/2 -ml-4 z-10 md:flex hidden items-center justify-center w-10 h-10 text-brand-blue\"\n            aria-label=\"Previous venue\"\n          >\n            <ChevronLeft className=\"h-6 w-6\" />\n          </button>\n        )}\n        \n        {/* Navigation arrows for desktop - right */}\n        {currentIndex < allVenues.length - 1 && (\n          <button\n            onClick={handleNext}\n            className=\"nav-arrow absolute right-0 top-1/2 -translate-y-1/2 -mr-4 z-10 md:flex hidden items-center justify-center w-10 h-10 text-brand-blue\"\n            aria-label=\"Next venue\"\n          >\n            <ChevronRight className=\"h-6 w-6\" />\n          </button>\n        )}\n        \n        {/* Swipeable area - enhanced with premium glass effect */}\n        <div \n          className={cn(\n            \"venue-glass relative overflow-hidden transition-all cursor-pointer py-3 sm:py-5 px-4 sm:px-6\",\n            isSelected ? \"selected\" : \"\"\n          )}\n          onTouchStart={onTouchStart}\n          onTouchMove={onTouchMove}\n          onTouchEnd={onTouchEnd}\n          onMouseDown={onMouseDown}\n          onMouseMove={onMouseMove}\n          onMouseUp={onMouseUp}\n          onMouseLeave={onMouseLeave}\n          onClick={() => handleSelect(currentVenue)}\n        >\n          {/* Primary venue indicator */}\n          {isPrimary && (\n            <div className=\"flex items-center gap-1 text-brand-pink mb-2 sm:mb-3\">\n              <CheckCircle2 className=\"h-3 w-3 sm:h-4 sm:w-4\" />\n              <span className=\"text-xs sm:text-sm font-medium\">Primary Recommendation</span>\n            </div>\n          )}\n          \n          <h3 className=\"text-lg sm:text-xl font-bold text-brand-black mb-1 line-clamp-1\" style={{ letterSpacing: 'normal' }}>{currentVenue.name}</h3>\n          <p className=\"text-xs sm:text-sm text-brand-black/70 line-clamp-2\">{currentVenue.formatted_address}</p>\n          \n          {/* Rating if available */}\n          {currentVenue.rating && (\n            <div className=\"mt-2 sm:mt-3 text-xs sm:text-sm text-brand-black/80\">\n              <span className=\"font-medium\">Rating:</span> {currentVenue.rating} ★\n            </div>\n          )}\n          \n          {/* Venue types */}\n          {currentVenue.types && currentVenue.types.length > 0 && (\n            <div className=\"mt-2 sm:mt-3 flex flex-wrap gap-1 sm:gap-1.5\">\n              {currentVenue.types.slice(0, 3).map(type => (\n                <span \n                  key={type} \n                  className=\"px-2 sm:px-2.5 py-0.5 sm:py-1 bg-white/30 backdrop-blur-sm text-brand-black rounded-full text-xs\"\n                  style={{ textDecoration: 'none' }}  /* Remove any text-decoration, including underscores */\n                >\n                  {type.replace(/_/g, ' ')}\n                </span>\n              ))}\n            </div>\n          )}\n          \n          {/* Weather indicators for outdoor venues */}\n          {currentVenue.isOutdoorVenue && (\n            <div className=\"mt-2 sm:mt-3 flex items-center\">\n              {currentVenue.weatherSuitable === false ? (\n                <div className=\"weather-indicator weather-indicator-unsuitable\">\n                  <CloudRain className=\"h-3 w-3 sm:h-4 sm:w-4\" />\n                  <span className=\"text-xs font-medium\">\n                    Weather may not be ideal for outdoor activity\n                  </span>\n                </div>\n              ) : (\n                <div className=\"weather-indicator weather-indicator-suitable\">\n                  <Sun className=\"h-3 w-3 sm:h-4 sm:w-4\" />\n                  <span className=\"text-xs font-medium\">\n                    Good weather for outdoor activity\n                  </span>\n                </div>\n              )}\n            </div>\n          )}\n          \n          {/* Weather-aware recommendation badge */}\n          {currentVenue.weatherAwareRecommendation && (\n            <div className=\"mt-2 sm:mt-3 flex items-center\">\n              <div className=\"weather-indicator weather-indicator-recommendation\">\n                <Umbrella className=\"h-3 w-3 sm:h-4 sm:w-4\" />\n                <span className=\"text-xs font-medium\">\n                  Weather-aware recommendation\n                </span>\n              </div>\n            </div>\n          )}\n          \n          {/* Selected indicator */}\n          {isSelected && (\n            <div className=\"mt-3 sm:mt-4 pt-2 sm:pt-3 border-t border-white/20 text-center\">\n              <span className=\"px-3 sm:px-4 py-1 sm:py-1.5 bg-brand-blue/10 text-brand-blue rounded-full text-xs sm:text-sm font-medium\">\n                Selected Venue\n              </span>\n            </div>\n          )}\n        </div>\n        \n        {/* Pagination dots */}\n        <div className=\"pagination-dots mt-2 sm:mt-4\">\n          {allVenues.map((_, idx) => (\n            <button\n              key={idx}\n              onClick={() => setCurrentIndex(idx)}\n              className={cn(\n                \"pagination-dot h-1.5 w-1.5 sm:h-2 sm:w-2 mx-0.5 sm:mx-1\",\n                idx === currentIndex ? \"active\" : \"\"\n              )}\n              aria-label={`Go to venue ${idx + 1}`}\n            />\n          ))}\n        </div>\n      </div>\n      \n      {/* Counter */}\n      <div className=\"text-center text-xs sm:text-sm text-white/80 mt-1.5 sm:mt-2\">\n        {currentIndex + 1} of {allVenues.length} venues\n      </div>\n    </div>\n  );\n};\n\nexport default VenueSwiper;","size_bytes":8901},"client/src/components/VenueSwiperTest.tsx":{"content":"import React, { useState } from 'react';\nimport VenueSwiper from './VenueSwiper';\nimport { PlaceDetails } from '@shared/schema';\n\n// Mock venue data for testing\nconst mockVenues = {\n  primary: {\n    name: 'British Museum',\n    formatted_address: 'Great Russell St, London WC1B 3DG',\n    place_id: 'ChIJB9OTMDIbdkgRp0JWbQGZsS8',\n    geometry: {\n      location: {\n        lat: 51.5194,\n        lng: -0.1269\n      }\n    },\n    types: ['museum', 'tourist_attraction'],\n    rating: 4.7\n  } as PlaceDetails,\n  \n  alternatives: [\n    {\n      name: 'Victoria and Albert Museum',\n      formatted_address: 'Cromwell Rd, London SW7 2RL',\n      place_id: 'ChIJVUo1s9QEdkgRiYQJN8Fj0R0',\n      geometry: {\n        location: {\n          lat: 51.4966,\n          lng: -0.1722\n        }\n      },\n      types: ['museum', 'tourist_attraction'],\n      rating: 4.6\n    } as PlaceDetails,\n    {\n      name: 'Natural History Museum',\n      formatted_address: 'Cromwell Rd, London SW7 5BD',\n      place_id: 'ChIJPTNIJdUEdkgRXzlzOLR8uEo',\n      geometry: {\n        location: {\n          lat: 51.4967,\n          lng: -0.1764\n        }\n      },\n      types: ['museum', 'tourist_attraction'],\n      rating: 4.7\n    } as PlaceDetails,\n    {\n      name: 'Science Museum',\n      formatted_address: 'Exhibition Rd, South Kensington, London SW7 2DD',\n      place_id: 'ChIJ9YmMVdIEdkgRQrOVLg1vOHo',\n      geometry: {\n        location: {\n          lat: 51.4978,\n          lng: -0.1745\n        }\n      },\n      types: ['museum', 'tourist_attraction'],\n      rating: 4.5\n    } as PlaceDetails\n  ]\n};\n\nconst VenueSwiperTest: React.FC = () => {\n  const [selectedVenue, setSelectedVenue] = useState<PlaceDetails | null>(null);\n  \n  return (\n    <div className=\"container mx-auto p-4 max-w-md\">\n      <h1 className=\"text-2xl font-bold mb-4\">Venue Swiper Test</h1>\n      <p className=\"text-gray-600 mb-6\">\n        Swipe left/right or use the arrow buttons to navigate between venue options.\n        Select a venue to see it displayed below.\n      </p>\n      \n      <VenueSwiper\n        primary={mockVenues.primary}\n        alternatives={mockVenues.alternatives}\n        onSelect={(venue) => {\n          setSelectedVenue(venue);\n          console.log(\"Selected venue:\", venue);\n        }}\n      />\n      \n      {selectedVenue && (\n        <div className=\"mt-8 p-4 bg-green-100 dark:bg-green-900 rounded-lg\">\n          <h2 className=\"font-bold mb-2\">Selected Venue:</h2>\n          <p><strong>Name:</strong> {selectedVenue.name}</p>\n          <p><strong>Address:</strong> {selectedVenue.formatted_address}</p>\n          <p><strong>Type:</strong> {selectedVenue.types?.join(', ')}</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VenueSwiperTest;","size_bytes":2713},"client/src/components/theme-toggle.tsx":{"content":"import { Moon, Sun } from \"lucide-react\"\nimport { Button } from \"@/components/ui/button\"\nimport { useTheme } from \"@/lib/themes\"\n\nexport function ThemeToggle() {\n  const { theme, setTheme } = useTheme()\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}\n    >\n      <Sun className=\"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0\" />\n      <Moon className=\"absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100\" />\n      <span className=\"sr-only\">Toggle theme</span>\n    </Button>\n  )\n}\n","size_bytes":645},"client/src/hooks/use-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","size_bytes":565},"client/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","size_bytes":3895},"client/src/hooks/useAuth.tsx":{"content":"import { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { apiRequest } from '../lib/queryClient';\n\n// Define the User interface\nexport interface User {\n  id: string;\n  email: string;\n  name: string | null;\n  avatar_url?: string | null;\n}\n\n// Define the AuthContext interface\ninterface AuthContextProps {\n  user: User | null;\n  isLoading: boolean;\n  error: string | null;\n  login: (email: string, password: string) => Promise<void>;\n  loginWithGoogle: (token: string) => Promise<void>;\n  register: (email: string, password: string, confirmPassword: string, name?: string) => Promise<void>;\n  logout: () => Promise<void>;\n  clearError: () => void;\n}\n\n// Create the auth context with default values\nconst AuthContext = createContext<AuthContextProps>({\n  user: null,\n  isLoading: true,\n  error: null,\n  login: async () => {},\n  loginWithGoogle: async () => {},\n  register: async () => {},\n  logout: async () => {},\n  clearError: () => {},\n});\n\n// Create the AuthProvider component\nexport const AuthProvider = ({ children }: { children: ReactNode }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Clear error\n  const clearError = () => setError(null);\n\n  // Check if user is already logged in\n  useEffect(() => {\n    const checkAuthStatus = async () => {\n      try {\n        const response = await fetch('/api/auth/status', {\n          credentials: 'include',\n        });\n        const data = await response.json();\n        \n        if (data.loggedIn && data.user) {\n          setUser(data.user);\n        } else {\n          setUser(null);\n        }\n      } catch (err) {\n        console.error('Error checking auth status:', err);\n        setUser(null);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    checkAuthStatus();\n  }, []);\n\n  // Login with email and password\n  const login = async (email: string, password: string) => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const response = await apiRequest('POST', '/api/auth/login', { email, password });\n      const data = await response.json();\n      setUser(data.user);\n    } catch (err) {\n      console.error('Login error:', err);\n      setError(err instanceof Error ? err.message : 'Failed to login. Please try again.');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Login with Google\n  const loginWithGoogle = async (token: string) => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const response = await apiRequest('POST', '/api/auth/google', { token });\n      const data = await response.json();\n      setUser(data.user);\n    } catch (err) {\n      console.error('Google login error:', err);\n      setError(err instanceof Error ? err.message : 'Failed to login with Google. Please try again.');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Register a new user\n  const register = async (email: string, password: string, confirmPassword: string, name?: string) => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const response = await apiRequest('POST', '/api/auth/register', { \n        email, \n        password, \n        confirmPassword,\n        name: name || null\n      });\n      const data = await response.json();\n      setUser(data.user);\n    } catch (err) {\n      console.error('Registration error:', err);\n      setError(err instanceof Error ? err.message : 'Failed to register. Please try again.');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Logout\n  const logout = async () => {\n    setIsLoading(true);\n    \n    try {\n      await apiRequest('POST', '/api/auth/logout', {});\n      setUser(null);\n    } catch (err) {\n      console.error('Logout error:', err);\n      setError(err instanceof Error ? err.message : 'Failed to logout. Please try again.');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Return the auth context provider\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        isLoading,\n        error,\n        login,\n        loginWithGoogle,\n        register,\n        logout,\n        clearError\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Create the useAuth hook\nexport const useAuth = () => useContext(AuthContext);","size_bytes":4393},"client/src/hooks/usePlanMutation.ts":{"content":"import { useMutation } from '@tanstack/react-query';\nimport { apiRequest } from '../lib/queryClient';\nimport { useToast } from '@/hooks/use-toast';\nimport { formatInTimeZone } from 'date-fns-tz';\n\ninterface PlanFormData {\n  date: string;\n  time: string;\n  plans: string;\n}\n\nexport function usePlanMutation() {\n  const { toast } = useToast();\n  \n  return useMutation({\n    mutationFn: async (data: PlanFormData) => {\n      // Map to API expected format if needed\n      const apiData = {\n        date: data.date,\n        startTime: data.time,\n        query: data.plans\n      };\n      \n      console.log(\"Sending API request:\", apiData);\n      const response = await apiRequest('POST', '/api/plan', apiData);\n      const responseData = await response.json();\n      console.log(\"API response:\", responseData);\n      \n      // Transform API response to match the expected ItineraryData structure\n      const venues = responseData.places.map((place: any) => {\n        // Convert API response format to Venue format expected by the UI\n        const venueDetails = place.details || {};\n        \n        // Parse and format the time with timezone awareness\n        let formattedTime;\n        if (place.displayTime) {\n          // If displayTime is provided from the backend, use it directly\n          formattedTime = place.displayTime;\n        } else if (place.scheduledTime) {\n          // Otherwise, format the ISO timestamp with NYC timezone\n          formattedTime = formatInTimeZone(\n            new Date(place.scheduledTime),\n            'America/New_York',\n            'h:mm a'\n          );\n        } else {\n          // Fallback if no time information is available\n          formattedTime = \"Time not specified\";\n        }\n        \n        return {\n          name: place.name,\n          time: formattedTime, // This will be properly formatted for NYC timezone\n          address: place.address,\n          rating: venueDetails.rating || 0,\n          categories: venueDetails.types || []\n        };\n      });\n      \n      // Process travel times into the format expected by the UI\n      const travelInfo = responseData.travelTimes.map((time: any) => ({\n        duration: time.duration,\n        destination: time.to // Use 'to' field from server response as the destination\n      }));\n      \n      return {\n        venues,\n        travelInfo\n      };\n    },\n    onSuccess: () => {\n      toast({\n        title: 'Success!',\n        description: 'Your itinerary has been created.',\n      });\n    },\n    onError: (error: Error) => {\n      toast({\n        title: 'Error',\n        description: error.message || 'Failed to create your itinerary. Please try again.',\n        variant: 'destructive',\n      });\n    }\n  });\n}","size_bytes":2709},"client/src/lib/calendar.ts":{"content":"import { saveAs } from 'file-saver';\n\nexport function exportToCalendar(venues: any[]) {\n  if (!venues || venues.length === 0) {\n    console.error('No venues to export to calendar');\n    return;\n  }\n\n  // Generate iCal content\n  let icalContent = [\n    'BEGIN:VCALENDAR',\n    'VERSION:2.0',\n    'PRODID:-//NYC Day Planner//EN',\n    'CALSCALE:GREGORIAN',\n  ];\n\n  // Add events for each venue\n  venues.forEach(venue => {\n    // Parse time from the venue data\n    let startTime;\n    try {\n      // Expecting time in \"HH:MM\" or \"X PM/AM\" format\n      const timeParts = venue.time.match(/(\\d+):(\\d+)|(\\d+)(?:\\s*)(am|pm)/i);\n      if (timeParts) {\n        startTime = new Date();\n        \n        if (timeParts[1] && timeParts[2]) {\n          // HH:MM format\n          startTime.setHours(parseInt(timeParts[1], 10));\n          startTime.setMinutes(parseInt(timeParts[2], 10));\n        } else if (timeParts[3]) {\n          // X AM/PM format\n          let hours = parseInt(timeParts[3], 10);\n          const isPM = timeParts[4]?.toLowerCase() === 'pm';\n          \n          if (isPM && hours < 12) hours += 12;\n          if (!isPM && hours === 12) hours = 0;\n          \n          startTime.setHours(hours);\n          startTime.setMinutes(0);\n        }\n      } else {\n        // Fallback - use current time\n        startTime = new Date();\n      }\n    } catch (error) {\n      console.error('Error parsing time:', error);\n      startTime = new Date();\n    }\n    \n    // Event duration - default 1.5 hours (90 minutes)\n    const endTime = new Date(startTime.getTime() + 90 * 60000);\n    \n    // Format dates for iCal\n    const formatDate = (date: Date) => {\n      return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';\n    };\n    \n    icalContent = icalContent.concat([\n      'BEGIN:VEVENT',\n      `DTSTART:${formatDate(startTime)}`,\n      `DTEND:${formatDate(endTime)}`,\n      `SUMMARY:${venue.name}`,\n      `LOCATION:${venue.address || 'New York, NY, USA'}`,\n      `DESCRIPTION:${venue.categories?.join(', ') || 'NYC Day Planner event'}`,\n      'END:VEVENT'\n    ]);\n  });\n  \n  icalContent.push('END:VCALENDAR');\n  \n  // Create and download the file\n  const blob = new Blob([icalContent.join('\\r\\n')], { \n    type: 'text/calendar;charset=utf-8' \n  });\n  \n  saveAs(blob, 'nyc-day-planner.ics');\n}","size_bytes":2296},"client/src/lib/dateUtils.ts":{"content":"import { format, parseISO, formatDistanceToNow } from 'date-fns';\n\n// Time format preferences\nexport type TimeFormat = '12h' | '24h';\n\nexport function formatTime(date: string | Date, timeFormat: TimeFormat = '12h'): string {\n  const parsedDate = typeof date === 'string' ? parseISO(date) : date;\n  return format(parsedDate, timeFormat === '12h' ? 'h:mm a' : 'HH:mm');\n}\n\nexport function formatDateTime(date: string | Date, timeFormat: TimeFormat = '12h'): string {\n  const parsedDate = typeof date === 'string' ? parseISO(date) : date;\n  return format(parsedDate, timeFormat === '12h' ? 'MMM d, yyyy h:mm a' : 'MMM d, yyyy HH:mm');\n}\n\nexport function getLocalTimeNow(): Date {\n  return new Date();\n}\n\nexport function isValidTime(timeString: string): boolean {\n  // Support both 12h and 24h formats\n  const time24hRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;\n  const time12hRegex = /^(0?[1-9]|1[0-2]):[0-5][0-9]\\s?(AM|PM|am|pm)$/;\n  \n  return time24hRegex.test(timeString) || time12hRegex.test(timeString);\n}\n\nexport function convertTo24Hour(timeString: string): string {\n  if (time24hRegex.test(timeString)) return timeString;\n  \n  const [time, period] = timeString.split(/\\s+/);\n  const [hours, minutes] = time.split(':').map(Number);\n  \n  let hour24 = hours;\n  if (period?.toLowerCase() === 'pm' && hours !== 12) {\n    hour24 = hours + 12;\n  } else if (period?.toLowerCase() === 'am' && hours === 12) {\n    hour24 = 0;\n  }\n  \n  return `${hour24.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n}\n\nexport function getTimeFromNow(date: string | Date): string {\n  const parsedDate = typeof date === 'string' ? parseISO(date) : date;\n  return formatDistanceToNow(parsedDate, { addSuffix: true });\n}\n\nconst time24hRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;","size_bytes":1774},"client/src/lib/env.ts":{"content":"/**\n * Centralized access to environment variables for the client-side application\n * \n * This module helps provide type safety and consistent access to both\n * environment variables and server-provided configuration.\n */\nimport { useState, useEffect } from 'react';\n\n// Directly available environment variables\nexport const BASE_URL = import.meta.env.VITE_BASE_URL || '';\n\n// Remote configuration values that must be fetched from server\ninterface ServerConfig {\n  googleClientId: string;\n  // Add other remote configuration values here\n}\n\n// Initialization state\nlet config: ServerConfig | null = null;\nlet isLoading = false;\nlet loadError: Error | null = null;\nlet loadPromise: Promise<ServerConfig> | null = null;\n\n/**\n * Fetch configuration from the server\n */\nexport async function fetchConfig(): Promise<ServerConfig> {\n  // If we already have the config, return it\n  if (config) {\n    return config;\n  }\n  \n  // If we're already loading, return the existing promise\n  if (loadPromise) {\n    return loadPromise;\n  }\n  \n  // Start a new load\n  isLoading = true;\n  loadError = null;\n  \n  loadPromise = fetch('/api/config/public')\n    .then(response => {\n      if (!response.ok) {\n        throw new Error(`Failed to load configuration: ${response.status} ${response.statusText}`);\n      }\n      return response.json();\n    })\n    .then(data => {\n      config = data;\n      isLoading = false;\n      return data;\n    })\n    .catch(error => {\n      loadError = error;\n      isLoading = false;\n      console.error('Error loading configuration:', error);\n      throw error;\n    });\n  \n  return loadPromise;\n}\n\n/**\n * Hook to access configuration values\n */\nexport function useConfig() {\n  const [localConfig, setLocalConfig] = useState<ServerConfig | null>(config);\n  const [loading, setLoading] = useState(!config && isLoading);\n  const [error, setError] = useState<Error | null>(loadError);\n  \n  useEffect(() => {\n    // If we already have the config, no need to fetch\n    if (config) {\n      setLocalConfig(config);\n      return;\n    }\n    \n    // Start loading\n    setLoading(true);\n    \n    fetchConfig()\n      .then(data => {\n        setLocalConfig(data);\n        setError(null);\n      })\n      .catch(err => {\n        setError(err);\n      })\n      .finally(() => {\n        setLoading(false);\n      });\n  }, []);\n  \n  return { config: localConfig, loading, error };\n}\n\n// Pre-fetch config on module load to speed up first access\nfetchConfig().catch(err => console.warn('Failed to prefetch config:', err));","size_bytes":2509},"client/src/lib/googleAuth.ts":{"content":"// Define the type for global window object with Google authentication\ndeclare global {\n  interface Window {\n    google?: any;\n    handleGoogleCredentialResponse?: (response: { credential: string }) => void;\n  }\n}\n\n// Keep track of initialization status\nlet isInitialized = false;\n\n/**\n * Initialize Google OAuth\n * \n * @param clientId Google OAuth client ID\n * @param callback Function to handle the credential response\n */\nexport function initializeGoogleAuth(clientId: string, callback: (credential: string) => void) {\n  if (!clientId) {\n    console.error('No Google Client ID provided');\n    return;\n  }\n\n  // Set up the global callback function that Google will call\n  window.handleGoogleCredentialResponse = (response) => {\n    if (response && response.credential) {\n      callback(response.credential);\n    }\n  };\n  \n  // We'll initialize in the loadGoogleScript function\n  loadGoogleScript(clientId);\n}\n\n/**\n * Load the Google Identity Services script\n * \n * @param clientId The Google Client ID to use for authentication\n */\nfunction loadGoogleScript(clientId: string): void {\n  const scriptId = 'google-identity-script';\n  \n  // Don't load the script multiple times\n  if (document.getElementById(scriptId)) {\n    if (window.google && window.google.accounts) {\n      initializeGoogleIdentity(clientId);\n    }\n    return;\n  }\n  \n  const script = document.createElement('script');\n  script.id = scriptId;\n  script.src = 'https://accounts.google.com/gsi/client';\n  script.async = true;\n  script.defer = true;\n  script.onload = () => {\n    // Initialize once the script is loaded\n    initializeGoogleIdentity(clientId);\n  };\n  \n  document.body.appendChild(script);\n}\n\n/**\n * Initialize the Google Identity Services\n * \n * @param clientId The Google Client ID to use for authentication\n */\nfunction initializeGoogleIdentity(clientId: string): void {\n  if (!window.google || !window.google.accounts) {\n    console.error('Google Identity Services not loaded properly');\n    return;\n  }\n  \n  try {\n    // Log the client ID for debugging\n    console.log('Initializing Google Identity Services with client ID:', clientId);\n    \n    window.google.accounts.id.initialize({\n      client_id: clientId,\n      callback: window.handleGoogleCredentialResponse,\n      auto_select: false,\n      cancel_on_tap_outside: true,\n      // Use popup mode to avoid redirect URI issues\n      ux_mode: 'popup', \n      // Additional configuration for handling redirect\n      prompt_parent_id: 'google-signin-prompt-container'\n    });\n    \n    isInitialized = true;\n    console.log('Google Identity Services initialized successfully');\n    \n    // Render any pending buttons\n    renderPendingButtons();\n  } catch (error) {\n    console.error('Error initializing Google Identity Services:', error);\n  }\n}\n\n// Store buttons to render after initialization\nconst pendingButtons: string[] = [];\n\n/**\n * Render the Google Sign-In button\n * \n * @param elementId ID of the HTML element to render the button in\n */\nexport function renderGoogleButton(elementId: string) {\n  if (!window.google || !window.google.accounts || !isInitialized) {\n    // Add to pending buttons to render later when initialized\n    if (!pendingButtons.includes(elementId)) {\n      pendingButtons.push(elementId);\n    }\n    return;\n  }\n\n  renderButton(elementId);\n}\n\n/**\n * Render all pending buttons\n */\nfunction renderPendingButtons() {\n  while (pendingButtons.length > 0) {\n    const elementId = pendingButtons.pop();\n    if (elementId) {\n      renderButton(elementId);\n    }\n  }\n}\n\n/**\n * Helper function to render a single button\n * \n * @param elementId ID of the HTML element to render the button in\n */\nfunction renderButton(elementId: string) {\n  const element = document.getElementById(elementId);\n  \n  if (!element) {\n    console.error(`Element with id ${elementId} not found`);\n    return;\n  }\n\n  try {\n    // Get the current origin to help with debugging\n    const currentOrigin = window.location.origin;\n    console.log('Current origin for Google Sign-In:', currentOrigin);\n    \n    // Render the button with popup mode to avoid redirect issues\n    window.google.accounts.id.renderButton(element, {\n      type: 'standard',\n      theme: 'outline',\n      size: 'large',\n      text: 'signin_with',\n      shape: 'rectangular',\n      logo_alignment: 'center',\n      width: 250,\n      ux_mode: 'popup', // Using popup mode to avoid redirect URI issues\n    });\n    \n    console.log('Google Sign-In button rendered successfully');\n  } catch (error) {\n    console.error('Error rendering Google Sign-In button:', error);\n  }\n}\n\n/**\n * Display the One Tap UI\n */\nexport function promptGoogleSignIn() {\n  if (!window.google || !window.google.accounts || !isInitialized) {\n    console.error('Google Identity Services not available or not initialized');\n    return;\n  }\n\n  try {\n    window.google.accounts.id.prompt();\n  } catch (error) {\n    console.error('Error prompting Google Sign-In:', error);\n  }\n}","size_bytes":4945},"client/src/lib/ics.ts":{"content":"import type { Itinerary } from \"@shared/schema\";\nimport { saveAs } from \"file-saver\";\n\nexport function generateICS(itinerary: Itinerary): void {\n  let icsContent = [\n    \"BEGIN:VCALENDAR\",\n    \"VERSION:2.0\",\n    \"PRODID:-//NYC Day Planner//EN\",\n    \"CALSCALE:GREGORIAN\",\n  ];\n\n  itinerary.places.forEach((place) => {\n    if (!place.scheduledTime) return;\n\n    const startTime = new Date(place.scheduledTime);\n    const endTime = new Date(startTime.getTime() + 90 * 60000); // 90 minutes default duration\n\n    icsContent = icsContent.concat([\n      \"BEGIN:VEVENT\",\n      `DTSTART:${startTime.toISOString().replace(/[-:]/g, \"\").split(\".\")[0]}Z`,\n      `DTEND:${endTime.toISOString().replace(/[-:]/g, \"\").split(\".\")[0]}Z`,\n      `SUMMARY:${place.name}`,\n      `LOCATION:${place.address}`,\n      \"END:VEVENT\",\n    ]);\n  });\n\n  icsContent.push(\"END:VCALENDAR\");\n\n  const blob = new Blob([icsContent.join(\"\\r\\n\")], {\n    type: \"text/calendar;charset=utf-8\",\n  });\n\n  saveAs(blob, \"nyc-itinerary.ics\");\n}","size_bytes":997},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey[0] as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","size_bytes":1376},"client/src/lib/themes.ts":{"content":"import { create } from 'zustand'\n\ntype ThemeStore = {\n  theme: 'light' | 'dark'\n  setTheme: (theme: 'light' | 'dark') => void\n}\n\nexport const useTheme = create<ThemeStore>((set) => ({\n  theme: typeof window !== 'undefined' \n    ? window.localStorage.getItem('theme') as 'light' | 'dark' || 'light'\n    : 'light',\n  setTheme: (theme) => {\n    if (theme === 'dark') {\n      document.documentElement.classList.add('dark')\n    } else {\n      document.documentElement.classList.remove('dark')\n    }\n    window.localStorage.setItem('theme', theme)\n    set({ theme })\n  },\n}))\n","size_bytes":570},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","size_bytes":166},"client/src/pages/HomePage.tsx":{"content":"import React, { useState, useEffect } from 'react';\nimport InputScreen from '../components/InputScreen';\nimport ItineraryScreen from '../components/ItineraryScreen';\nimport { usePlanMutation } from '../hooks/usePlanMutation';\nimport { exportToCalendar } from '../lib/calendar';\nimport { useAuth } from '../hooks/useAuth';\nimport { Button } from '@/components/ui/button';\nimport { useLocation } from 'wouter';\n\ninterface PlanFormData {\n  date: string;\n  time: string;\n  plans: string;\n}\n\ninterface Venue {\n  name: string;\n  time: string;\n  address: string;\n  rating: number;\n  categories: string[];\n}\n\ninterface TravelInfo {\n  duration: string;\n  destination: string;\n}\n\ninterface ItineraryData {\n  venues: Venue[];\n  travelInfo: TravelInfo[];\n}\n\nexport default function HomePage() {\n  const [itineraryData, setItineraryData] = useState<ItineraryData | null>(null);\n  const planMutation = usePlanMutation();\n  const { user, logout } = useAuth();\n  const [, setLocation] = useLocation();\n\n  // Log state changes to debug\n  useEffect(() => {\n    console.log(\"HomePage itineraryData state:\", itineraryData);\n  }, [itineraryData]);\n\n  const handlePlanSubmit = async (formData: PlanFormData) => {\n    try {\n      console.log(\"Submitting plan:\", formData);\n      const result = await planMutation.mutateAsync(formData);\n      console.log(\"Plan creation result:\", result);\n      setItineraryData(result);\n\n      // Smooth scroll to itinerary section after a brief delay\n      setTimeout(() => {\n        document.getElementById('itinerary-section')?.scrollIntoView({\n          behavior: 'smooth',\n          block: 'start'\n        });\n      }, 100);\n    } catch (error) {\n      console.error('Error creating plan:', error);\n      // Error handling is managed by the mutation\n    }\n  };\n\n  const handleLogout = async () => {\n    await logout();\n    setLocation('/login');\n  };\n\n  return (\n    <div className=\"bg-white text-foreground min-h-screen\">\n      {/* Main Content */}\n      <div className=\"max-w-6xl mx-auto px-4 py-8\">\n        <div className=\"flex flex-col gap-8\">\n          <div className=\"flex justify-between items-center mb-6\">\n            {/* Removed \"Plan Your Perfect Day\" header */}\n            {user && (\n              <div className=\"text-sm text-muted-foreground\">\n                Welcome back, {user.name?.split(' ')[0] || 'traveler'}\n              </div>\n            )}\n          </div>\n\n          {/* Input Section */}\n          <section className=\"py-4\">\n            <InputScreen \n              onSubmit={handlePlanSubmit}\n              isLoading={planMutation.isPending}\n            />\n          </section>\n\n          {/* Itinerary Section - always render but conditionally show content */}\n          <section id=\"itinerary-section\" className=\"py-4\">\n            <ItineraryScreen\n              venues={itineraryData?.venues || []}\n              travelInfo={itineraryData?.travelInfo || []}\n              onExport={() => {\n                exportToCalendar(itineraryData?.venues || []);\n              }}\n            />\n          </section>\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":3097},"client/src/pages/ItineraryPage.tsx":{"content":"import React from 'react';\nimport { useParams, Link } from 'wouter';\nimport { useQuery } from '@tanstack/react-query';\nimport { Button } from '@/components/ui/button';\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n} from '@/components/ui/card';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { Separator } from '@/components/ui/separator';\nimport { Share } from 'lucide-react';\nimport { exportToCalendar } from '../lib/calendar';\n\n// Interface for a venue/place in the itinerary\ninterface Venue {\n  name: string;\n  time: string;\n  address: string;\n  rating?: number;\n  categories?: string[];\n}\n\n// Interface for travel information between venues\ninterface TravelInfo {\n  duration: string;\n  destination: string;\n}\n\n// Interface for the complete itinerary data\ninterface ItineraryData {\n  id: number;\n  query: string;\n  places: Venue[];\n  travelTimes: TravelInfo[];\n  created_at: string;\n}\n\nconst ItineraryPage = () => {\n  const { id } = useParams<{ id: string }>();\n  \n  // Fetch the itinerary data\n  const { data: itinerary, isLoading, error } = useQuery<ItineraryData>({\n    queryKey: [`/api/itineraries/${id}`],\n    enabled: !!id,\n  });\n\n  // Format the time string for display\n  const formatTime = (timeString: string) => {\n    try {\n      const date = new Date(timeString);\n      return date.toLocaleTimeString('en-US', {\n        hour: 'numeric',\n        minute: '2-digit',\n        hour12: true\n      });\n    } catch (e) {\n      return timeString; // Return the original string if parsing fails\n    }\n  };\n\n  // Format date for display\n  const formatDate = (dateString: string) => {\n    try {\n      const date = new Date(dateString);\n      return date.toLocaleDateString('en-US', {\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n      });\n    } catch (e) {\n      return 'Unknown date'; // Fallback\n    }\n  };\n\n  // Handle exporting the itinerary to calendar\n  const handleExport = () => {\n    if (itinerary?.places) {\n      exportToCalendar(itinerary.places);\n    }\n  };\n\n  // Handle sharing the itinerary\n  const handleShare = () => {\n    if (navigator.share) {\n      navigator.share({\n        title: `London Itinerary #${id}`,\n        text: 'Check out my London day plan!',\n        url: window.location.href,\n      })\n      .catch((error) => console.log('Error sharing:', error));\n    } else {\n      // Fallback: copy to clipboard\n      navigator.clipboard.writeText(window.location.href)\n        .then(() => alert('Link copied to clipboard!'))\n        .catch(() => alert('Failed to copy link'));\n    }\n  };\n\n  return (\n    <div className=\"container mx-auto py-8 px-4 md:px-6\">\n      <div className=\"mb-6 flex flex-col md:flex-row justify-between items-start md:items-center gap-4\">\n        <div>\n          <h1 className=\"text-2xl md:text-3xl font-bold\">\n            {isLoading ? <Skeleton className=\"h-9 w-64\" /> : `London Itinerary #${id}`}\n          </h1>\n          {itinerary && (\n            <p className=\"text-muted-foreground mt-1\">\n              {formatDate(itinerary.created_at)}\n            </p>\n          )}\n        </div>\n        <div className=\"flex gap-3\">\n          <Button onClick={handleExport} disabled={isLoading || !itinerary}>\n            Export to Calendar\n          </Button>\n          <Button variant=\"outline\" onClick={handleShare} disabled={isLoading || !itinerary}>\n            <Share className=\"h-4 w-4 mr-2\" />\n            Share\n          </Button>\n          <Link href=\"/\">\n            <Button variant=\"secondary\">New Plan</Button>\n          </Link>\n        </div>\n      </div>\n\n      {isLoading ? (\n        // Loading state\n        <div className=\"space-y-4\">\n          <Skeleton className=\"h-[200px] w-full\" />\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <Skeleton className=\"h-[150px] w-full\" />\n            <Skeleton className=\"h-[150px] w-full\" />\n          </div>\n        </div>\n      ) : error ? (\n        // Error state\n        <Card>\n          <CardContent className=\"pt-6\">\n            <div className=\"text-center py-10\">\n              <h3 className=\"text-xl font-semibold text-destructive mb-2\">Failed to load itinerary</h3>\n              <p className=\"text-muted-foreground\">\n                We couldn't retrieve the requested itinerary. It may have been deleted or you may not have permission to view it.\n              </p>\n              <Link href=\"/\">\n                <Button className=\"mt-4\">Return to Planner</Button>\n              </Link>\n            </div>\n          </CardContent>\n        </Card>\n      ) : itinerary ? (\n        // Loaded state with data\n        <div className=\"space-y-6\">\n          {/* Query Card */}\n          <Card>\n            <CardHeader>\n              <CardTitle>Original Request</CardTitle>\n              <CardDescription>Your request for planning this day in London</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <p className=\"italic\">\"{itinerary.query}\"</p>\n            </CardContent>\n          </Card>\n\n          {/* Itinerary Timeline Card */}\n          <Card>\n            <CardHeader>\n              <CardTitle>Your Day in London</CardTitle>\n              <CardDescription>A personalized itinerary for your perfect day</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"space-y-8\">\n                {itinerary.places && itinerary.places.map((place, index) => (\n                  <div key={index} className=\"relative pl-6 pb-8 border-l border-muted last:border-l-transparent\">\n                    {/* Time indicator dot */}\n                    <div className=\"absolute top-0 left-0 -translate-x-1/2 w-4 h-4 rounded-full bg-primary\"></div>\n                    \n                    <div className=\"mb-1 font-medium\">{formatTime(place.time)}</div>\n                    <div className=\"font-bold text-lg\">{place.name}</div>\n                    <div className=\"text-muted-foreground text-sm mb-2\">{place.address}</div>\n                    \n                    {/* Display categories if available */}\n                    {place.categories && place.categories.length > 0 && (\n                      <div className=\"flex flex-wrap gap-2 mb-2\">\n                        {place.categories.map((category, idx) => (\n                          <span key={idx} className=\"text-xs bg-muted px-2 py-1 rounded-md\">\n                            {category}\n                          </span>\n                        ))}\n                      </div>\n                    )}\n                    \n                    {/* Show travel info if not the last place */}\n                    {index < (itinerary.places.length - 1) && itinerary.travelTimes && itinerary.travelTimes[index] && (\n                      <div className=\"mt-3 text-sm text-muted-foreground italic\">\n                        <span className=\"font-medium\">Next:</span> {itinerary.travelTimes[index].duration} travel to {itinerary.travelTimes[index].destination}\n                      </div>\n                    )}\n                  </div>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      ) : (\n        // Empty state (should never happen if isLoading is false and there's no error)\n        <div className=\"text-center py-10\">\n          <p>No itinerary data available.</p>\n          <Link href=\"/\">\n            <Button className=\"mt-4\">Return to Planner</Button>\n          </Link>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default ItineraryPage;","size_bytes":7545},"client/src/pages/LoginPage.tsx":{"content":"import React, { useEffect, useRef } from 'react';\nimport { useAuth } from '../hooks/useAuth';\nimport { useLocation } from 'wouter';\nimport { useConfig } from '../lib/env';\nimport { initializeGoogleAuth, renderGoogleButton } from '../lib/googleAuth';\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Link } from 'wouter';\n\nexport default function LoginPage() {\n  const { user, loginWithGoogle, error } = useAuth();\n  const [, setLocation] = useLocation();\n  const { config, loading: configLoading } = useConfig();\n  const googleButtonRef = useRef<HTMLDivElement>(null);\n\n  // Redirect to home if already logged in\n  useEffect(() => {\n    if (user) {\n      setLocation('/');\n    }\n  }, [user, setLocation]);\n\n  // Initialize Google Sign-In when component mounts\n  useEffect(() => {\n    // Wait for config to be loaded or if user is already logged in\n    if (configLoading || !config || user) {\n      return;\n    }\n    \n    // Set up Google Auth with the client ID from server config\n    initializeGoogleAuth(config.googleClientId, async (credential) => {\n      try {\n        await loginWithGoogle(credential);\n        setLocation('/');\n      } catch (err) {\n        console.error('Google authentication error:', err);\n      }\n    });\n    \n    // Load the Google Identity Services script if it's not already loaded\n    const scriptId = 'google-identity-script';\n    if (!document.getElementById(scriptId)) {\n      const script = document.createElement('script');\n      script.id = scriptId;\n      script.src = 'https://accounts.google.com/gsi/client';\n      script.async = true;\n      script.defer = true;\n      script.onload = () => {\n        if (googleButtonRef.current) {\n          // Small timeout to ensure Google API is fully initialized\n          setTimeout(() => {\n            renderGoogleButton('google-signin-button');\n          }, 100);\n        }\n      };\n      document.body.appendChild(script);\n    } else if (window.google && googleButtonRef.current) {\n      // Script already loaded, just render the button\n      renderGoogleButton('google-signin-button');\n    }\n    \n    return () => {\n      // We don't remove the script on unmount as it might be used by other components\n    };\n  }, [loginWithGoogle, config, configLoading, user, setLocation]);\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center p-4 bg-white\">\n      <div className=\"w-full max-w-md\">\n        <div className=\"text-center mb-8\">\n          {/* Removed \"London Day Planner\" header */}\n          <p className=\"text-muted-foreground\">\n            Sign in to save your itineraries\n          </p>\n        </div>\n\n        <Card className=\"w-full shadow-lg border-0\">\n          <CardHeader>\n            <CardTitle className=\"text-2xl text-center\">Sign in with Google</CardTitle>\n            <CardDescription className=\"text-center\">\n              Use your Google account to sign in\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            {error && (\n              <Alert variant=\"destructive\" className=\"mb-4\">\n                <AlertDescription>{error}</AlertDescription>\n              </Alert>\n            )}\n\n            {/* Main container for all Google Sign-In related elements */}\n            <div id=\"google-signin-container\">\n              {/* Button container */}\n              <div \n                id=\"google-signin-button\" \n                ref={googleButtonRef} \n                className=\"mt-2\"\n                style={{ \n                  display: 'flex', \n                  justifyContent: 'center', \n                  width: '100%', \n                  minHeight: '40px' \n                }}\n              ></div>\n              \n              {/* Prompt container */}\n              <div id=\"google-signin-prompt-container\"></div>\n            </div>\n          </CardContent>\n          <CardFooter className=\"flex justify-center\">\n            <p className=\"text-sm text-muted-foreground\">\n              <Link href=\"/\" className=\"text-blue-600 font-medium hover:underline\">\n                Continue without signing in\n              </Link>\n            </p>\n          </CardFooter>\n        </Card>\n      </div>\n    </div>\n  );\n}","size_bytes":4305},"client/src/pages/ProfilePage.tsx":{"content":"import React from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';\nimport { useAuth } from '../hooks/useAuth';\nimport { Button } from '@/components/ui/button';\nimport { useQuery } from '@tanstack/react-query';\nimport { Separator } from '@/components/ui/separator';\nimport { useToast } from '@/hooks/use-toast';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { Link } from 'wouter';\n\ninterface ItineraryHistoryItem {\n  id: number;\n  title: string;\n  created_at: string;\n  query?: string;\n}\n\nconst ProfilePage = () => {\n  const { user, logout } = useAuth();\n  const { toast } = useToast();\n  \n  // Query to fetch user's itinerary history\n  const { data: itineraries, isLoading, error } = useQuery<ItineraryHistoryItem[]>({\n    queryKey: ['/api/itineraries/user'],\n    enabled: !!user,\n  });\n\n  // Format date to a more readable format\n  const formatDate = (dateString: string) => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n  };\n\n  // Handle logout\n  const handleLogout = async () => {\n    try {\n      await logout();\n    } catch (error) {\n      toast({\n        title: 'Error',\n        description: 'Failed to log out. Please try again.',\n        variant: 'destructive',\n      });\n    }\n  };\n\n  // Generate avatar fallback from user's name\n  const getAvatarFallback = (name: string) => {\n    if (!name) return 'U';\n    return name.split(' ')\n      .map(part => part[0])\n      .join('')\n      .toUpperCase()\n      .substring(0, 2);\n  };\n\n  return (\n    <div className=\"container mx-auto py-8 px-4 md:px-6\">\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n        {/* User Profile Card */}\n        <Card className=\"md:col-span-1\">\n          <CardHeader className=\"flex flex-col items-center pb-2\">\n            <Avatar className=\"h-24 w-24 mb-4\">\n              <AvatarImage src={user?.avatar_url || ''} alt={user?.name || 'User'} />\n              <AvatarFallback className=\"text-xl\">{getAvatarFallback(user?.name || '')}</AvatarFallback>\n            </Avatar>\n            <CardTitle className=\"text-center text-2xl\">{user?.name || 'User'}</CardTitle>\n            <CardDescription className=\"text-center\">{user?.email}</CardDescription>\n          </CardHeader>\n          <CardContent className=\"flex flex-col gap-4\">\n            <Button variant=\"outline\" onClick={handleLogout}>\n              Log Out\n            </Button>\n            <Link href=\"/\">\n              <Button className=\"w-full\">Return to Planner</Button>\n            </Link>\n          </CardContent>\n        </Card>\n\n        {/* Itinerary History Card */}\n        <Card className=\"md:col-span-2\">\n          <CardHeader>\n            <CardTitle>Generation History</CardTitle>\n            <CardDescription>\n              View your previously generated travel itineraries\n            </CardDescription>\n          </CardHeader>\n          <CardContent>\n            {isLoading ? (\n              // Skeleton loading state\n              <div className=\"space-y-4\">\n                {[1, 2, 3].map((i) => (\n                  <div key={i} className=\"flex flex-col gap-2\">\n                    <Skeleton className=\"h-6 w-3/4\" />\n                    <Skeleton className=\"h-4 w-1/2\" />\n                    <Separator className=\"my-2\" />\n                  </div>\n                ))}\n              </div>\n            ) : error ? (\n              <div className=\"text-center py-8 text-muted-foreground\">\n                Failed to load itinerary history. Please try again later.\n              </div>\n            ) : itineraries && Array.isArray(itineraries) && itineraries.length > 0 ? (\n              <div className=\"space-y-4\">\n                {itineraries.map((itinerary) => (\n                  <div key={itinerary.id} className=\"space-y-2\">\n                    <div className=\"flex justify-between items-start\">\n                      <div>\n                        <h3 className=\"font-medium\">{itinerary.title || 'London Itinerary'}</h3>\n                        <p className=\"text-sm text-muted-foreground\">\n                          {formatDate(itinerary.created_at)}\n                        </p>\n                        {itinerary.query && (\n                          <p className=\"text-sm mt-1 italic\">\"{itinerary.query}\"</p>\n                        )}\n                      </div>\n                      <Link href={`/itinerary/${itinerary.id}`}>\n                        <Button variant=\"ghost\" size=\"sm\">View</Button>\n                      </Link>\n                    </div>\n                    <Separator className=\"my-2\" />\n                  </div>\n                ))}\n              </div>\n            ) : (\n              <div className=\"text-center py-8 text-muted-foreground\">\n                No itineraries generated yet. Start planning your perfect day in London!\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n};\n\nexport default ProfilePage;","size_bytes":5180},"client/src/pages/RegisterPage.tsx":{"content":"import React, { useEffect } from 'react';\nimport { useLocation } from 'wouter';\n\nexport default function RegisterPage() {\n  const [, setLocation] = useLocation();\n\n  // Immediately redirect to login page (Google login only)\n  useEffect(() => {\n    setLocation('/login');\n  }, [setLocation]);\n\n  return (\n    <div className=\"min-h-screen flex items-center justify-center p-4 bg-white\">\n      <div className=\"text-center\">\n        <p>Redirecting to sign in page...</p>\n      </div>\n    </div>\n  );\n}","size_bytes":497},"client/src/pages/home.tsx":{"content":"import { useState, ReactNode } from \"react\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { z } from \"zod\";\nimport { MapPin, Clock, Calendar, Loader2, Sparkles } from \"lucide-react\";\nimport { Form, FormControl, FormField, FormItem, FormLabel } from \"@/components/ui/form\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Button } from \"@/components/ui/button\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { apiRequest } from \"@/lib/queryClient\";\nimport { generateICS } from \"@/lib/ics\";\nimport type { Itinerary, Place, PlaceDetails } from \"@shared/schema\";\nimport { format } from \"date-fns\";\nimport { TimeInput } from \"@/components/TimeInput\";\nimport { formatDateTime, formatTime, getLocalTimeNow } from \"@/lib/dateUtils\";\nimport { Link } from \"wouter\";\n\n/**\n * Validates query for better user experience and clearer error messages\n * Checks for minimal length and location information\n */\nfunction validateQuery(query: string): { valid: boolean; message?: string } {\n  // Check for minimal query length\n  if (query.length < 5) {\n    return { \n      valid: false, \n      message: \"Please provide more details about what you'd like to do in New York City.\"\n    };\n  }\n  \n  // Check if query mentions a NYC location\n  const commonNYCLocations = [\n    \"soho\", \"times square\", \"central park\", \"brooklyn\", \"manhattan\", \n    \"midtown\", \"greenwich village\", \"east village\", \"west village\", \n    \"financial district\", \"wall street\", \"chelsea\", \"tribeca\",\n    \"dumbo\", \"williamsburg\", \"harlem\", \"chinatown\", \"little italy\",\n    \"upper east side\", \"upper west side\", \"nyc\", \"new york\"\n  ];\n  \n  const hasLocation = commonNYCLocations.some(location => \n    query.toLowerCase().includes(location)\n  );\n  \n  if (!hasLocation) {\n    return { \n      valid: false, \n      message: \"Please specify at least one NYC location (e.g., Times Square, SoHo, or Manhattan).\"\n    };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Enhances vague queries by adding location and time information\n * Helps users by providing more context for better itinerary planning\n */\nfunction enhanceVagueQuery(query: string): string {\n  // Extract the key request from a very vague query\n  const lowercaseQuery = query.toLowerCase().trim();\n  \n  // Simple extraction patterns for common activities\n  if (lowercaseQuery.length < 20) {\n    // Very short query - likely just mentions an activity\n    \n    // Food-related queries\n    if (\n      lowercaseQuery.includes(\"food\") || \n      lowercaseQuery.includes(\"eat\") ||\n      lowercaseQuery.includes(\"restaurant\") ||\n      lowercaseQuery.includes(\"lunch\") ||\n      lowercaseQuery.includes(\"dinner\") ||\n      lowercaseQuery.includes(\"sandwich\") ||\n      lowercaseQuery.includes(\"breakfast\")\n    ) {\n      return `${query} in Greenwich Village around ${new Date().getHours() < 15 ? '13:00' : '19:00'}`;\n    }\n    \n    // Coffee/cafe queries\n    if (\n      lowercaseQuery.includes(\"coffee\") ||\n      lowercaseQuery.includes(\"cafe\") ||\n      lowercaseQuery.includes(\"tea\")\n    ) {\n      return `${query} in SoHo around ${new Date().getHours() < 12 ? '10:30' : '15:00'}`;\n    }\n    \n    // Shopping queries\n    if (\n      lowercaseQuery.includes(\"shop\") ||\n      lowercaseQuery.includes(\"store\") ||\n      lowercaseQuery.includes(\"buy\")\n    ) {\n      return `${query} in Midtown in the afternoon`;\n    }\n    \n    // Attraction/sightseeing queries\n    if (\n      lowercaseQuery.includes(\"see\") ||\n      lowercaseQuery.includes(\"visit\") ||\n      lowercaseQuery.includes(\"attraction\")\n    ) {\n      return `${query} near Times Square in the afternoon`;\n    }\n    \n    // Spa/relaxation queries\n    if (\n      lowercaseQuery.includes(\"spa\") ||\n      lowercaseQuery.includes(\"massage\") ||\n      lowercaseQuery.includes(\"relax\")\n    ) {\n      return `${query} in Upper East Side in the afternoon`;\n    }\n    \n    // Nightlife queries\n    if (\n      lowercaseQuery.includes(\"bar\") ||\n      lowercaseQuery.includes(\"pub\") ||\n      lowercaseQuery.includes(\"drink\") ||\n      lowercaseQuery.includes(\"club\")\n    ) {\n      return `${query} in East Village around 20:00`;\n    }\n    \n    // For any other very short queries, make a generic enhancement\n    if (lowercaseQuery.length < 10) {\n      return `${query} in Manhattan in the ${new Date().getHours() < 12 ? 'afternoon' : 'evening'}`;\n    }\n  }\n  \n  // Return original if no enhancement was needed\n  return query;\n}\n\nconst formSchema = z.object({\n  query: z.string().min(10, \"Please provide more details about your plans\"),\n  date: z.string().optional(),\n  startTime: z.string().optional(),\n});\n\ntype FormValues = z.infer<typeof formSchema>;\n\nexport default function Home() {\n  const [itinerary, setItinerary] = useState<Itinerary | null>(null);\n  const { toast } = useToast();\n  const [currentTime, setCurrentTime] = useState<string>(\"\");\n  const [isFormSubmitting, setIsFormSubmitting] = useState(false);\n\n  useState(() => {\n    fetch(\"/api/time\")\n      .then(res => res.json())\n      .then(data => {\n        const localDate = new Date(data.currentTime);\n        setCurrentTime(format(localDate, \"yyyy-MM-dd'T'HH:mm\"));\n      })\n      .catch(console.error);\n  });\n\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      query: \"\",\n      date: format(new Date(), \"yyyy-MM-dd\"),\n      startTime: format(new Date(), \"HH:mm\"),\n    },\n  });\n\n  const planMutation = useMutation({\n    mutationFn: async (data: FormValues) => {\n      setIsFormSubmitting(true);\n      const res = await apiRequest(\"POST\", \"/api/plan\", data);\n      return res.json();\n    },\n    onSuccess: (data: Itinerary) => {\n      setItinerary(data);\n      setIsFormSubmitting(false);\n      toast({\n        title: \"Itinerary created!\",\n        description: \"Your day plan is ready.\",\n      });\n    },\n    onError: (error: Error) => {\n      setIsFormSubmitting(false);\n      toast({\n        title: \"Error creating itinerary\",\n        description: error.message || \"Please ensure you've specified a starting location and any fixed appointments.\",\n        variant: \"destructive\",\n      });\n    },\n  });\n\n  return (\n    <div className=\"min-h-screen py-4 sm:py-8 px-3 sm:px-4 relative\">\n      {/* Fixed position glass effect container */}\n      <div className=\"main-glass-effect\"></div>\n      <div className=\"container mx-auto max-w-5xl\">\n        {/* Logo Section */}\n        <div className=\"logo-container\">\n          <h1 \n            className=\"logo font-logo text-3xl sm:text-4xl font-bold text-brand-black\"\n            style={{ filter: \"drop-shadow(0 6px 18px rgba(0,0,0,0.2))\", letterSpacing: \"normal\" }}\n          >\n            PLAN\n          </h1>\n        </div>\n        \n        {/* Tagline with helper text */}\n        <div className=\"text-center mb-6 sm:mb-8\">\n          <p className=\"text-brand-black text-lg sm:text-xl font-semibold\">\n            Plan Your Perfect Day In Seconds\n          </p>\n          <p className=\"text-brand-black text-xs sm:text-sm mt-2 font-medium bg-white/30 inline-block px-3 sm:px-4 py-1 sm:py-1.5 rounded-full backdrop-blur-sm border border-brand-blue/10\">\n            Enter your activities, locations and times below\n          </p>\n        </div>\n\n        {/* Main Content */}\n        <div className=\"mb-12\">\n          {/* Form Container - With blue tint */}\n          <div className=\"form-container mb-8 sm:mb-10\">\n            <div className=\"p-4 sm:p-8\">\n              <h2 className=\"text-2xl font-bold text-brand-black mb-6 text-center\">What's The Plan?</h2>\n              <Form {...form}>\n                <form\n                  onSubmit={form.handleSubmit((data) => {\n                    // Add validation before form submission\n                    const validation = validateQuery(data.query);\n                    if (!validation.valid) {\n                      toast({\n                        title: \"Please enhance your request\",\n                        description: validation.message,\n                        variant: \"destructive\",\n                      });\n                      return;\n                    }\n                    planMutation.mutate(data);\n                  })}\n                  className={`space-y-6 ${isFormSubmitting ? 'opacity-70 pointer-events-none' : ''}`}\n                >\n                  <div className=\"grid sm:grid-cols-2 gap-6\">\n                    <div className=\"datetime-card p-3\">\n                      <FormField\n                        control={form.control}\n                        name=\"date\"\n                        render={({ field }) => (\n                          <FormItem>\n                            <FormLabel className=\"text-brand-black\">Date</FormLabel>\n                            <FormControl>\n                              <Input\n                                type=\"date\"\n                                {...field}\n                                className=\"placeholder-opacity-50\"\n                                disabled={isFormSubmitting}\n                              />\n                            </FormControl>\n                          </FormItem>\n                        )}\n                      />\n                    </div>\n\n                    <div className=\"datetime-card p-3\">\n                      <FormField\n                        control={form.control}\n                        name=\"startTime\"\n                        render={({ field }) => (\n                          <FormItem>\n                            <FormLabel className=\"text-brand-black\">Start Time</FormLabel>\n                            <FormControl>\n                              <TimeInput\n                                value={field.value || \"\"}\n                                onChange={field.onChange}\n                                className=\"w-full placeholder-opacity-50\"\n                                disabled={isFormSubmitting}\n                              />\n                            </FormControl>\n                          </FormItem>\n                        )}\n                      />\n                    </div>\n                  </div>\n\n                  <div className=\"datetime-card p-3\">\n                    <FormField\n                      control={form.control}\n                      name=\"query\"\n                      render={({ field }) => (\n                        <FormItem>\n                          <FormLabel className=\"text-brand-black\">Your Plans</FormLabel>\n                          <FormControl>\n                            <Textarea\n                              placeholder={window.innerWidth < 640 ? \n                                \"e.g. Times Square 9am, brunch in SoHo, Metropolitan Museum, dinner at Carbone 7pm\" : \n                                \"e.g. Start at Grand Central at 9am, café near SoHo for brunch, then Met Museum until dinner at Carbone at 7pm.\"\n                              }\n                              className=\"min-h-[100px] resize-y\"\n                              {...field}\n                              disabled={isFormSubmitting}\n                            />\n                          </FormControl>\n                          <div className=\"flex items-center mt-2 gap-2\">\n                            <Button\n                              type=\"button\"\n                              variant=\"outline\"\n                              size=\"sm\"\n                              onClick={() => {\n                                const currentQuery = form.getValues().query;\n                                const enhanced = enhanceVagueQuery(currentQuery);\n                                if (enhanced !== currentQuery) {\n                                  form.setValue(\"query\", enhanced);\n                                  toast({\n                                    title: \"Query enhanced\",\n                                    description: \"Added location and time details to your request\",\n                                  });\n                                }\n                              }}\n                            >\n                              <Sparkles className=\"w-4 h-4 mr-2\" />\n                              Smart Enhance\n                            </Button>\n                            <p className=\"text-xs text-muted-foreground\">\n                              Click to add location and time details to vague requests\n                            </p>\n                          </div>\n                        </FormItem>\n                      )}\n                    />\n                  </div>\n\n                  <Button\n                    type=\"submit\"\n                    className=\"w-full create-plan-btn\"\n                    style={{ background: '#17B9E6', color: 'white' }}\n                    disabled={isFormSubmitting}\n                  >\n                    {isFormSubmitting ? (\n                      <>\n                        <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                        Creating plan...\n                      </>\n                    ) : (\n                      \"Create Plan\"\n                    )}\n                  </Button>\n                </form>\n              </Form>\n            </div>\n          </div>\n\n          {/* Itinerary Display */}\n          {itinerary && (\n            <div className=\"glass-card\">\n              <div className=\"p-4 sm:p-8\">\n                <div className=\"flex flex-col sm:flex-row justify-between items-center mb-6 gap-3\">\n                  <h2 className=\"text-2xl font-bold text-brand-black\">Your Itinerary</h2>\n                  <Button\n                    variant=\"outline\"\n                    className=\"text-brand-black border-brand-blue hover:text-brand-blue bg-white/20 backdrop-blur-sm w-full sm:w-auto\"\n                    onClick={() => generateICS(itinerary)}\n                  >\n                    <Calendar className=\"w-4 h-4 mr-2\" />\n                    Export to Calendar\n                  </Button>\n                </div>\n                <div className=\"space-y-6\">\n                  {(itinerary.places as Place[]).map((place, index) => (\n                    <div key={`${place.placeId}-${index}`} className=\"relative\">\n                      {/* Timeline connector */}\n                      {index > 0 && (\n                        <div className=\"absolute top-0 left-7 h-full w-px bg-brand-blue/20 -translate-x-1/2\" />\n                      )}\n\n                      {/* Activity card */}\n                      <div className=\"venue-glass p-4 sm:p-5\">\n                        <div className=\"flex items-start gap-3 sm:gap-4 mb-3\">\n                          <div className=\"flex-shrink-0 p-1.5 sm:p-2 bg-brand-blue/20 text-brand-blue rounded-full relative z-10\">\n                            <Clock className=\"w-4 h-4 sm:w-5 sm:h-5\" />\n                          </div>\n                          <div className=\"flex-1 min-w-0\">\n                            <div className=\"flex flex-col sm:flex-row sm:items-baseline sm:justify-between gap-1 sm:gap-2\">\n                              <h3 className=\"font-semibold text-brand-black text-base sm:text-lg truncate\" style={{ letterSpacing: 'normal' }}>{place.name}</h3>\n                              {place.scheduledTime && (\n                                <span className=\"text-xs sm:text-sm text-brand-black/80 font-mono\">\n                                  {formatTime(place.scheduledTime)}\n                                </span>\n                              )}\n                            </div>\n                            <p className=\"text-xs sm:text-sm text-brand-black/70 mt-1 truncate\">\n                              {place.address}\n                            </p>\n                          </div>\n                        </div>\n                      </div>\n\n                      {/* Travel time indicator */}\n                      {Array.isArray(itinerary.travelTimes) && \n                       index < (itinerary.travelTimes as Array<{\n                        from: string;\n                        to: string;\n                        duration: number;\n                        arrivalTime: string;\n                      }>).length && (\n                        <div className=\"ml-6 sm:ml-7 my-3 sm:my-4 p-2 flex items-center gap-2 text-xs sm:text-sm text-brand-black bg-white/50 backdrop-blur-sm rounded-md border border-brand-blue/10 shadow-sm\">\n                          <MapPin className=\"w-3 h-3 sm:w-4 sm:h-4 text-brand-blue\" />\n                          <span className=\"truncate\">\n                            {(itinerary.travelTimes as Array<any>)[index].duration} minutes to{\" \"}\n                            {(itinerary.travelTimes as Array<any>)[index].to}\n                          </span>\n                        </div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":17112},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":711},"client/src/components/auth/LoginForm.tsx":{"content":"import React, { useEffect, useRef } from 'react';\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Link } from 'wouter';\nimport { useAuth } from '../../hooks/useAuth';\nimport { initializeGoogleAuth, renderGoogleButton } from '../../lib/googleAuth';\nimport { useConfig } from '../../lib/env';\n\nexport function LoginForm() {\n  const { loginWithGoogle, error, isLoading } = useAuth();\n  const { config, loading: configLoading } = useConfig();\n  const googleButtonRef = useRef<HTMLDivElement>(null);\n\n  // Initialize Google Sign-In when component mounts\n  useEffect(() => {\n    // Wait for config to be loaded\n    if (configLoading || !config) {\n      return;\n    }\n    \n    // Set up Google Auth with the client ID from server config\n    initializeGoogleAuth(config.googleClientId, async (credential) => {\n      try {\n        await loginWithGoogle(credential);\n      } catch (err) {\n        console.error('Google authentication error:', err);\n      }\n    });\n    \n    // Load the Google Identity Services script if it's not already loaded\n    const scriptId = 'google-identity-script';\n    if (!document.getElementById(scriptId)) {\n      const script = document.createElement('script');\n      script.id = scriptId;\n      script.src = 'https://accounts.google.com/gsi/client';\n      script.async = true;\n      script.defer = true;\n      script.onload = () => {\n        if (googleButtonRef.current) {\n          // Small timeout to ensure Google API is fully initialized\n          setTimeout(() => {\n            renderGoogleButton('google-signin-button');\n          }, 100);\n        }\n      };\n      document.body.appendChild(script);\n    } else if (window.google && googleButtonRef.current) {\n      // Script already loaded, just render the button\n      renderGoogleButton('google-signin-button');\n    }\n    \n    return () => {\n      // We don't remove the script on unmount as it might be used by other components\n    };\n  }, [loginWithGoogle, config, configLoading]);\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto shadow-lg border-0\">\n      <CardHeader>\n        <CardTitle className=\"text-2xl text-center\">Sign in with Google</CardTitle>\n        <CardDescription className=\"text-center\">\n          Sign in to save your itineraries\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-4\">\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {/* Main container for all Google Sign-In related elements */}\n        <div id=\"google-signin-container\">\n          {/* Button container */}\n          <div \n            id=\"google-signin-button\" \n            ref={googleButtonRef} \n            className=\"mt-2\"\n            style={{ \n              display: 'flex', \n              justifyContent: 'center', \n              width: '100%', \n              minHeight: '40px' \n            }}\n          ></div>\n          \n          {/* Prompt container */}\n          <div id=\"google-signin-prompt-container\"></div>\n        </div>\n      </CardContent>\n      <CardFooter className=\"flex justify-center\">\n        <p className=\"text-sm text-muted-foreground\">\n          <Link href=\"/\" className=\"text-primary font-medium hover:underline\">\n            Continue without signing in\n          </Link>\n        </p>\n      </CardFooter>\n    </Card>\n  );\n}","size_bytes":3498},"client/src/components/auth/ProtectedRoute.tsx":{"content":"import React, { useEffect } from 'react';\nimport { useLocation } from 'wouter';\nimport { useAuth } from '../../hooks/useAuth';\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode;\n}\n\nexport function ProtectedRoute({ children }: ProtectedRouteProps) {\n  const { user, isLoading } = useAuth();\n  const [, setLocation] = useLocation();\n\n  useEffect(() => {\n    if (!isLoading && !user) {\n      setLocation('/login');\n    }\n  }, [user, isLoading, setLocation]);\n\n  // Show nothing while checking authentication\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary\"></div>\n      </div>\n    );\n  }\n\n  // If authenticated, render children\n  return user ? <>{children}</> : null;\n}","size_bytes":828},"client/src/components/auth/RegisterForm.tsx":{"content":"import React, { useEffect, useRef } from 'react';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Separator } from '@/components/ui/separator';\nimport { Link } from 'wouter';\nimport { useAuth } from '../../hooks/useAuth';\nimport { initializeGoogleAuth, renderGoogleButton } from '../../lib/googleAuth';\nimport { useConfig } from '../../lib/env';\n\n// Create the form schema with validation\nconst registerSchema = z.object({\n  name: z.string().optional(),\n  email: z.string().email('Please enter a valid email address'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  confirmPassword: z.string().min(1, 'Please confirm your password'),\n}).refine((data) => data.password === data.confirmPassword, {\n  message: \"Passwords don't match\",\n  path: ['confirmPassword'], \n});\n\ntype RegisterFormValues = z.infer<typeof registerSchema>;\n\nexport function RegisterForm() {\n  const { register, loginWithGoogle, error, clearError, isLoading } = useAuth();\n  const { config, loading: configLoading } = useConfig();\n  const googleButtonRef = useRef<HTMLDivElement>(null);\n\n  // Initialize Google Sign-In when component mounts\n  useEffect(() => {\n    // Wait for config to be loaded\n    if (configLoading || !config) {\n      return;\n    }\n    \n    // Set up Google Auth with the client ID from server config\n    initializeGoogleAuth(config.googleClientId, async (credential) => {\n      try {\n        await loginWithGoogle(credential);\n      } catch (err) {\n        console.error('Google authentication error:', err);\n      }\n    });\n    \n    // Load the Google Identity Services script if it's not already loaded\n    const scriptId = 'google-identity-script';\n    if (!document.getElementById(scriptId)) {\n      const script = document.createElement('script');\n      script.id = scriptId;\n      script.src = 'https://accounts.google.com/gsi/client';\n      script.async = true;\n      script.defer = true;\n      script.onload = () => {\n        if (googleButtonRef.current) {\n          // Small timeout to ensure Google API is fully initialized\n          setTimeout(() => {\n            renderGoogleButton('google-register-button');\n          }, 100);\n        }\n      };\n      document.body.appendChild(script);\n    } else if (window.google && googleButtonRef.current) {\n      // Script already loaded, just render the button\n      renderGoogleButton('google-register-button');\n    }\n    \n    return () => {\n      // We don't remove the script on unmount as it might be used by other components\n    };\n  }, [loginWithGoogle, config, configLoading]);\n\n  // Initialize the form with react-hook-form\n  const form = useForm<RegisterFormValues>({\n    resolver: zodResolver(registerSchema),\n    defaultValues: {\n      name: '',\n      email: '',\n      password: '',\n      confirmPassword: '',\n    },\n  });\n\n  // Submit handler\n  const onSubmit = async (values: RegisterFormValues) => {\n    try {\n      await register(\n        values.email, \n        values.password, \n        values.confirmPassword,\n        values.name\n      );\n    } catch (err) {\n      // Error is handled in the auth context\n      console.error('Registration submission error:', err);\n    }\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader>\n        <CardTitle className=\"text-2xl text-center\">Create Account</CardTitle>\n        <CardDescription className=\"text-center\">\n          Enter your details to create a new account\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        {error && (\n          <Alert variant=\"destructive\" className=\"mb-4\">\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n        <Form {...form}>\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n            <FormField\n              control={form.control}\n              name=\"name\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Name (Optional)</FormLabel>\n                  <FormControl>\n                    <Input\n                      placeholder=\"Your name\"\n                      type=\"text\"\n                      autoComplete=\"name\"\n                      {...field}\n                      onChange={(e) => {\n                        clearError();\n                        field.onChange(e);\n                      }}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            <FormField\n              control={form.control}\n              name=\"email\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Email</FormLabel>\n                  <FormControl>\n                    <Input\n                      placeholder=\"email@example.com\"\n                      type=\"email\"\n                      autoComplete=\"email\"\n                      {...field}\n                      onChange={(e) => {\n                        clearError();\n                        field.onChange(e);\n                      }}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            <FormField\n              control={form.control}\n              name=\"password\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Password</FormLabel>\n                  <FormControl>\n                    <Input\n                      placeholder=\"Create a password\"\n                      type=\"password\"\n                      autoComplete=\"new-password\"\n                      {...field}\n                      onChange={(e) => {\n                        clearError();\n                        field.onChange(e);\n                      }}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            <FormField\n              control={form.control}\n              name=\"confirmPassword\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Confirm Password</FormLabel>\n                  <FormControl>\n                    <Input\n                      placeholder=\"Confirm your password\"\n                      type=\"password\"\n                      autoComplete=\"new-password\"\n                      {...field}\n                      onChange={(e) => {\n                        clearError();\n                        field.onChange(e);\n                      }}\n                    />\n                  </FormControl>\n                  <FormMessage />\n                </FormItem>\n              )}\n            />\n            <Button type=\"submit\" className=\"w-full\" disabled={isLoading}>\n              {isLoading ? 'Creating account...' : 'Create Account'}\n            </Button>\n          </form>\n        </Form>\n\n        <div className=\"mt-4 relative\">\n          <div className=\"absolute inset-0 flex items-center\">\n            <Separator className=\"w-full\" />\n          </div>\n          <div className=\"relative flex justify-center text-xs uppercase\">\n            <span className=\"bg-card px-2 text-muted-foreground\">Or continue with</span>\n          </div>\n        </div>\n\n        <div \n          id=\"google-register-button\" \n          ref={googleButtonRef} \n          className=\"mt-4\"\n          style={{ \n            display: 'flex', \n            justifyContent: 'center', \n            width: '100%', \n            minHeight: '40px' \n          }}\n        ></div>\n        \n        {/* Container for Google Sign-In prompt */}\n        <div id=\"google-signin-prompt-container\"></div>\n      </CardContent>\n      <CardFooter className=\"flex justify-center\">\n        <p className=\"text-sm text-muted-foreground\">\n          Already have an account?{' '}\n          <Link href=\"/login\" className=\"text-primary font-medium hover:underline\">\n            Log in\n          </Link>\n        </p>\n      </CardFooter>\n    </Card>\n  );\n}","size_bytes":8457},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","size_bytes":1977},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","size_bytes":4420},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","size_bytes":1584},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","size_bytes":140},"client/src/components/ui/avatar.tsx":{"content":"import * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","size_bytes":1405},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","size_bytes":1128},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","size_bytes":2712},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","size_bytes":1901},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ ...props }) => <ChevronLeft className=\"h-4 w-4\" />,\n        IconRight: ({ ...props }) => <ChevronRight className=\"h-4 w-4\" />,\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","size_bytes":2609},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h3\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <p\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n","size_bytes":1877},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","size_bytes":6210},"client/src/components/ui/chart.tsx":{"content":"import * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([_, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item.dataKey || item.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","size_bytes":10466},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","size_bytes":1056},"client/src/components/ui/collapsible.tsx":{"content":"import * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","size_bytes":315},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\ninterface CommandDialogProps extends DialogProps {}\n\nconst CommandDialog = ({ children, ...props }: CommandDialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","size_bytes":4879},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","size_bytes":7246},"client/src/components/ui/dialog.tsx":{"content":"import * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","size_bytes":3835},"client/src/components/ui/drawer.tsx":{"content":"import * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","size_bytes":3007},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","size_bytes":7361},"client/src/components/ui/form.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  ControllerProps,\n  FieldPath,\n  FieldValues,\n  FormProvider,\n  useFormContext,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message) : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","size_bytes":4085},"client/src/components/ui/hover-card.tsx":{"content":"import * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","size_bytes":1184},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","size_bytes":2154},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","size_bytes":845},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","size_bytes":710},"client/src/components/ui/menubar.tsx":{"content":"import * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst MenubarMenu = MenubarPrimitive.Menu\n\nconst MenubarGroup = MenubarPrimitive.Group\n\nconst MenubarPortal = MenubarPrimitive.Portal\n\nconst MenubarSub = MenubarPrimitive.Sub\n\nconst MenubarRadioGroup = MenubarPrimitive.RadioGroup\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-10 items-center space-x-1 rounded-md border bg-background p-1\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","size_bytes":7974},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","size_bytes":5046},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n}\n","size_bytes":2751},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n","size_bytes":1230},"client/src/components/ui/progress.tsx":{"content":"import * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","size_bytes":777},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","size_bytes":1467},"client/src/components/ui/resizable.tsx":{"content":"import { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","size_bytes":1709},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","size_bytes":1642},"client/src/components/ui/select.tsx":{"content":"import * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","size_bytes":5615},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","size_bytes":756},"client/src/components/ui/sheet.tsx":{"content":"import * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","size_bytes":4267},"client/src/components/ui/sidebar.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { VariantProps, cva } from \"class-variance-authority\"\nimport { PanelLeft } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport { Sheet, SheetContent } from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar:state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContext = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContext | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    defaultOpen?: boolean\n    open?: boolean\n    onOpenChange?: (open: boolean) => void\n  }\n>(\n  (\n    {\n      defaultOpen = true,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const isMobile = useIsMobile()\n    const [openMobile, setOpenMobile] = React.useState(false)\n\n    // This is the internal state of the sidebar.\n    // We use openProp and setOpenProp for control from outside the component.\n    const [_open, _setOpen] = React.useState(defaultOpen)\n    const open = openProp ?? _open\n    const setOpen = React.useCallback(\n      (value: boolean | ((value: boolean) => boolean)) => {\n        if (setOpenProp) {\n          return setOpenProp?.(\n            typeof value === \"function\" ? value(open) : value\n          )\n        }\n\n        _setOpen(value)\n\n        // This sets the cookie to keep the sidebar state.\n        document.cookie = `${SIDEBAR_COOKIE_NAME}=${open}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n      },\n      [setOpenProp, open]\n    )\n\n    // Helper to toggle the sidebar.\n    const toggleSidebar = React.useCallback(() => {\n      return isMobile\n        ? setOpenMobile((open) => !open)\n        : setOpen((open) => !open)\n    }, [isMobile, setOpen, setOpenMobile])\n\n    // Adds a keyboard shortcut to toggle the sidebar.\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n          (event.metaKey || event.ctrlKey)\n        ) {\n          event.preventDefault()\n          toggleSidebar()\n        }\n      }\n\n      window.addEventListener(\"keydown\", handleKeyDown)\n      return () => window.removeEventListener(\"keydown\", handleKeyDown)\n    }, [toggleSidebar])\n\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n    // This makes it easier to style the sidebar with Tailwind classes.\n    const state = open ? \"expanded\" : \"collapsed\"\n\n    const contextValue = React.useMemo<SidebarContext>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n    )\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH,\n                \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              \"group/sidebar-wrapper flex min-h-svh w-full text-sidebar-foreground has-[[data-variant=inset]]:bg-sidebar\",\n              className\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    )\n  }\n)\nSidebarProvider.displayName = \"SidebarProvider\"\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    side?: \"left\" | \"right\"\n    variant?: \"sidebar\" | \"floating\" | \"inset\"\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n  }\n>(\n  (\n    {\n      side = \"left\",\n      variant = \"sidebar\",\n      collapsible = \"offcanvas\",\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n    if (collapsible === \"none\") {\n      return (\n        <div\n          className={cn(\n            \"flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground\",\n            className\n          )}\n          ref={ref}\n          {...props}\n        >\n          {children}\n        </div>\n      )\n    }\n\n    if (isMobile) {\n      return (\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n          <SheetContent\n            data-sidebar=\"sidebar\"\n            data-mobile=\"true\"\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n              } as React.CSSProperties\n            }\n            side={side}\n          >\n            <div className=\"flex h-full w-full flex-col\">{children}</div>\n          </SheetContent>\n        </Sheet>\n      )\n    }\n\n    return (\n      <div\n        ref={ref}\n        className=\"group peer hidden md:block\"\n        data-state={state}\n        data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n        data-variant={variant}\n        data-side={side}\n      >\n        {/* This is what handles the sidebar gap on desktop */}\n        <div\n          className={cn(\n            \"duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear\",\n            \"group-data-[collapsible=offcanvas]:w-0\",\n            \"group-data-[side=right]:rotate-180\",\n            variant === \"floating\" || variant === \"inset\"\n              ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon]\"\n          )}\n        />\n        <div\n          className={cn(\n            \"duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex\",\n            side === \"left\"\n              ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n              : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n            // Adjust the padding for floating and inset variants.\n            variant === \"floating\" || variant === \"inset\"\n              ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n            className\n          )}\n          {...props}\n        >\n          <div\n            data-sidebar=\"sidebar\"\n            className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    )\n  }\n)\nSidebar.displayName = \"Sidebar\"\n\nconst SidebarTrigger = React.forwardRef<\n  React.ElementRef<typeof Button>,\n  React.ComponentProps<typeof Button>\n>(({ className, onClick, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      ref={ref}\n      data-sidebar=\"trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeft />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n})\nSidebarTrigger.displayName = \"SidebarTrigger\"\n\nconst SidebarRail = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\">\n>(({ className, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <button\n      ref={ref}\n      data-sidebar=\"rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex\",\n        \"[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarRail.displayName = \"SidebarRail\"\n\nconst SidebarInset = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"main\">\n>(({ className, ...props }, ref) => {\n  return (\n    <main\n      ref={ref}\n      className={cn(\n        \"relative flex min-h-svh flex-1 flex-col bg-background\",\n        \"peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInset.displayName = \"SidebarInset\"\n\nconst SidebarInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  React.ComponentProps<typeof Input>\n>(({ className, ...props }, ref) => {\n  return (\n    <Input\n      ref={ref}\n      data-sidebar=\"input\"\n      className={cn(\n        \"h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInput.displayName = \"SidebarInput\"\n\nconst SidebarHeader = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarHeader.displayName = \"SidebarHeader\"\n\nconst SidebarFooter = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarFooter.displayName = \"SidebarFooter\"\n\nconst SidebarSeparator = React.forwardRef<\n  React.ElementRef<typeof Separator>,\n  React.ComponentProps<typeof Separator>\n>(({ className, ...props }, ref) => {\n  return (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn(\"mx-2 w-auto bg-sidebar-border\", className)}\n      {...props}\n    />\n  )\n})\nSidebarSeparator.displayName = \"SidebarSeparator\"\n\nconst SidebarContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarContent.displayName = \"SidebarContent\"\n\nconst SidebarGroup = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarGroup.displayName = \"SidebarGroup\"\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupLabel.displayName = \"SidebarGroupLabel\"\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupAction.displayName = \"SidebarGroupAction\"\n\nconst SidebarGroupContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"group-content\"\n    className={cn(\"w-full text-sm\", className)}\n    {...props}\n  />\n))\nSidebarGroupContent.displayName = \"SidebarGroupContent\"\n\nconst SidebarMenu = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu\"\n    className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n    {...props}\n  />\n))\nSidebarMenu.displayName = \"SidebarMenu\"\n\nconst SidebarMenuItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    data-sidebar=\"menu-item\"\n    className={cn(\"group/menu-item relative\", className)}\n    {...props}\n  />\n))\nSidebarMenuItem.displayName = \"SidebarMenuItem\"\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:!p-0\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    isActive?: boolean\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = \"default\",\n      size = \"default\",\n      tooltip,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const Comp = asChild ? Slot : \"button\"\n    const { isMobile, state } = useSidebar()\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    )\n\n    if (!tooltip) {\n      return button\n    }\n\n    if (typeof tooltip === \"string\") {\n      tooltip = {\n        children: tooltip,\n      }\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== \"collapsed\" || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    )\n  }\n)\nSidebarMenuButton.displayName = \"SidebarMenuButton\"\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    showOnHover?: boolean\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuAction.displayName = \"SidebarMenuAction\"\n\nconst SidebarMenuBadge = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"menu-badge\"\n    className={cn(\n      \"absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none\",\n      \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n      \"peer-data-[size=sm]/menu-button:top-1\",\n      \"peer-data-[size=default]/menu-button:top-1.5\",\n      \"peer-data-[size=lg]/menu-button:top-2.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuBadge.displayName = \"SidebarMenuBadge\"\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    showIcon?: boolean\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"rounded-md h-8 flex gap-2 px-2 items-center\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 flex-1 max-w-[--skeleton-width]\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n})\nSidebarMenuSkeleton.displayName = \"SidebarMenuSkeleton\"\n\nconst SidebarMenuSub = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu-sub\"\n    className={cn(\n      \"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuSub.displayName = \"SidebarMenuSub\"\n\nconst SidebarMenuSubItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ ...props }, ref) => <li ref={ref} {...props} />)\nSidebarMenuSubItem.displayName = \"SidebarMenuSubItem\"\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<\"a\"> & {\n    asChild?: boolean\n    size?: \"sm\" | \"md\"\n    isActive?: boolean\n  }\n>(({ asChild = false, size = \"md\", isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuSubButton.displayName = \"SidebarMenuSubButton\"\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","size_bytes":23337},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","size_bytes":261},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","size_bytes":1077},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","size_bytes":1139},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","size_bytes":2765},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","size_bytes":1883},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport interface TextareaProps\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\n\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n  ({ className, ...props }, ref) => {\n    return (\n      <textarea\n        className={cn(\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","size_bytes":772},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","size_bytes":4845},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","size_bytes":772},"client/src/components/ui/toggle-group.tsx":{"content":"import * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","size_bytes":1739},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3\",\n        sm: \"h-9 px-2.5\",\n        lg: \"h-11 px-5\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","size_bytes":1435},"client/src/components/ui/tooltip.tsx":{"content":"import * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","size_bytes":1145}},"version":1}